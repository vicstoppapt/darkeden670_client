; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\CMP3.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0O@JKENFCBN@MinTrace?52003?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MNEJIGLM@__MinTrace?5Window__?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KLPNNMEP@?$CF8d?0?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LDHKDNLA@MPEGVideo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09INHAPJDF@?$CF?42d?3?$CF?42d?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?_MinTraceA@@YAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_MinTraceErrA@@YAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_MinTraceWarA@@YAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_ClMinTraceA@@YAXKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_CmdMinTraceA@@YAXHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMP3@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMP3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Close@CMP3@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CMP3@@QAEKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Play@CMP3@@QAEK_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Pause@CMP3@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@CMP3@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Home@CMP3@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?End@CMP3@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPosition@CMP3@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPosition@CMP3@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TotalLength@CMP3@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TotalLength@CMP3@@QAEKPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CurrentLength@CMP3@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CurrentLength@CMP3@@QAEKPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStatus@CMP3@@AAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MinsFromSecs@CMP3@@AAEXKPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetErrorString@CMP3@@QAEXKPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReady@CMP3@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPause@CMP3@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlay@CMP3@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStop@CMP3@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRecord@CMP3@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StatusMode@CMP3@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVolume@CMP3@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVolume@CMP3@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@JKENFCBN@MinTrace?52003?$AA@		; `string'
PUBLIC	??_C@_0BE@MNEJIGLM@__MinTrace?5Window__?$AA@	; `string'
;	COMDAT ??_C@_0O@JKENFCBN@MinTrace?52003?$AA@
CONST	SEGMENT
??_C@_0O@JKENFCBN@MinTrace?52003?$AA@ DB 'MinTrace 2003', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_g_pszMinTraceTitle DD FLAT:??_C@_0O@JKENFCBN@MinTrace?52003?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0BE@MNEJIGLM@__MinTrace?5Window__?$AA@
CONST	SEGMENT
??_C@_0BE@MNEJIGLM@__MinTrace?5Window__?$AA@ DB '__MinTrace Window__', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_g_pszMinTraceClassName DD FLAT:??_C@_0BE@MNEJIGLM@__MinTrace?5Window__?$AA@
_DATA	ENDS
PUBLIC	?Close@CMP3@@QAEXXZ				; CMP3::Close
EXTRN	__imp__mciSendCommandA@16:NEAR
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\cmp3.cpp
;	COMDAT ?Close@CMP3@@QAEXXZ
_TEXT	SEGMENT
?Close@CMP3@@QAEXXZ PROC NEAR				; CMP3::Close, COMDAT
; _this$ = ecx

; 289  : 	if (muiDeviceID != 0) {

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	74 10		 je	 SHORT $L103235

; 290  : 
; 291  : 		mciSendCommand(muiDeviceID, MCI_CLOSE, 0, (DWORD)NULL);

  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	68 04 08 00 00	 push	 2052			; 00000804H
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
$L103235:

; 292  : 	}
; 293  : 
; 294  : 	return;
; 295  : }

  00016	c3		 ret	 0
?Close@CMP3@@QAEXXZ ENDP				; CMP3::Close
_TEXT	ENDS
PUBLIC	?Pause@CMP3@@QAEKXZ				; CMP3::Pause
; Function compile flags: /Ogsy
;	COMDAT ?Pause@CMP3@@QAEKXZ
_TEXT	SEGMENT
_mciGenericParms$ = -4					; size = 4
?Pause@CMP3@@QAEKXZ PROC NEAR				; CMP3::Pause, COMDAT
; _this$ = ecx

; 381  : {

  00000	51		 push	 ecx

; 382  :   DWORD             dwResult;
; 383  :   MCI_GENERIC_PARMS mciGenericParms;
; 384  : 
; 385  : 	dwResult = mciSendCommand(muiDeviceID, MCI_PAUSE, 
; 386  : 		                      MCI_WAIT,(DWORD)(LPVOID)&mciGenericParms);

  00001	8d 04 24	 lea	 eax, DWORD PTR _mciGenericParms$[esp+4]
  00004	50		 push	 eax
  00005	6a 02		 push	 2
  00007	68 09 08 00 00	 push	 2057			; 00000809H
  0000c	ff 31		 push	 DWORD PTR [ecx]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16

; 387  : 	return dwResult;
; 388  : }

  00014	59		 pop	 ecx
  00015	c3		 ret	 0
?Pause@CMP3@@QAEKXZ ENDP				; CMP3::Pause
_TEXT	ENDS
PUBLIC	?Stop@CMP3@@QAEKXZ				; CMP3::Stop
; Function compile flags: /Ogsy
;	COMDAT ?Stop@CMP3@@QAEKXZ
_TEXT	SEGMENT
_mciGenericParms$ = -4					; size = 4
?Stop@CMP3@@QAEKXZ PROC NEAR				; CMP3::Stop, COMDAT
; _this$ = ecx

; 392  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 393  :   DWORD             dwResult;
; 394  :   MCI_GENERIC_PARMS mciGenericParms;
; 395  : 
; 396  : 	dwResult = mciSendCommand(muiDeviceID, MCI_STOP, 
; 397  : 		                      0,(DWORD)(LPVOID)&mciGenericParms);

  00002	8d 44 24 04	 lea	 eax, DWORD PTR _mciGenericParms$[esp+8]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	8b f1		 mov	 esi, ecx
  0000b	68 08 08 00 00	 push	 2056			; 00000808H
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16

; 398  : 
; 399  : 	m_bLoop = false;

  00018	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  0001c	5e		 pop	 esi

; 400  : 
; 401  : 	return dwResult;
; 402  : }

  0001d	59		 pop	 ecx
  0001e	c3		 ret	 0
?Stop@CMP3@@QAEKXZ ENDP					; CMP3::Stop
_TEXT	ENDS
PUBLIC	?Home@CMP3@@QAEHXZ				; CMP3::Home
; Function compile flags: /Ogsy
;	COMDAT ?Home@CMP3@@QAEHXZ
_TEXT	SEGMENT
?Home@CMP3@@QAEHXZ PROC NEAR				; CMP3::Home, COMDAT
; _this$ = ecx

; 406  : 	mciSendCommand(muiDeviceID,MCI_SEEK,MCI_SEEK_TO_START,(DWORD)(LPVOID)NULL);

  00000	6a 00		 push	 0
  00002	68 00 01 00 00	 push	 256			; 00000100H
  00007	68 07 08 00 00	 push	 2055			; 00000807H
  0000c	ff 31		 push	 DWORD PTR [ecx]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16

; 407  : 	return TRUE;

  00014	33 c0		 xor	 eax, eax
  00016	40		 inc	 eax

; 408  : }

  00017	c3		 ret	 0
?Home@CMP3@@QAEHXZ ENDP					; CMP3::Home
_TEXT	ENDS
PUBLIC	?End@CMP3@@QAEHXZ				; CMP3::End
; Function compile flags: /Ogsy
;	COMDAT ?End@CMP3@@QAEHXZ
_TEXT	SEGMENT
?End@CMP3@@QAEHXZ PROC NEAR				; CMP3::End, COMDAT
; _this$ = ecx

; 412  : 	mciSendCommand(muiDeviceID,MCI_SEEK,MCI_SEEK_TO_END,(DWORD)(LPVOID)NULL);

  00000	6a 00		 push	 0
  00002	68 00 02 00 00	 push	 512			; 00000200H
  00007	68 07 08 00 00	 push	 2055			; 00000807H
  0000c	ff 31		 push	 DWORD PTR [ecx]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16

; 413  : 	return TRUE;

  00014	33 c0		 xor	 eax, eax
  00016	40		 inc	 eax

; 414  : }

  00017	c3		 ret	 0
?End@CMP3@@QAEHXZ ENDP					; CMP3::End
_TEXT	ENDS
PUBLIC	?GetPosition@CMP3@@QAEKXZ			; CMP3::GetPosition
; Function compile flags: /Ogsy
;	COMDAT ?GetPosition@CMP3@@QAEKXZ
_TEXT	SEGMENT
_mciStatusParms$ = -16					; size = 16
?GetPosition@CMP3@@QAEKXZ PROC NEAR			; CMP3::GetPosition, COMDAT
; _this$ = ecx

; 417  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 418  : 	DWORD nTime;
; 419  : 	MCI_STATUS_PARMS mciStatusParms;
; 420  : 	mciStatusParms.dwItem = MCI_STATUS_POSITION;
; 421  : 	mciSendCommand(muiDeviceID,MCI_STATUS,MCI_STATUS_ITEM,(DWORD)(LPVOID)&mciStatusParms);

  00006	8d 45 f0	 lea	 eax, DWORD PTR _mciStatusParms$[ebp]
  00009	50		 push	 eax
  0000a	68 00 01 00 00	 push	 256			; 00000100H
  0000f	68 14 08 00 00	 push	 2068			; 00000814H
  00014	ff 31		 push	 DWORD PTR [ecx]
  00016	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _mciStatusParms$[ebp+8], 2
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16

; 422  : 	nTime = (LONG)mciStatusParms.dwReturn;
; 423  : 	return nTime;

  00023	8b 45 f4	 mov	 eax, DWORD PTR _mciStatusParms$[ebp+4]

; 424  : }

  00026	c9		 leave
  00027	c3		 ret	 0
?GetPosition@CMP3@@QAEKXZ ENDP				; CMP3::GetPosition
_TEXT	ENDS
PUBLIC	?SetPosition@CMP3@@QAEXK@Z			; CMP3::SetPosition
; Function compile flags: /Ogsy
;	COMDAT ?SetPosition@CMP3@@QAEXK@Z
_TEXT	SEGMENT
_mciSeekParms$ = -8					; size = 8
_dwPos$ = 8						; size = 4
?SetPosition@CMP3@@QAEXK@Z PROC NEAR			; CMP3::SetPosition, COMDAT
; _this$ = ecx

; 427  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 428  : 	MCI_SEEK_PARMS mciSeekParms;
; 429  : 	mciSeekParms.dwTo = dwPos;

  00005	8b 45 08	 mov	 eax, DWORD PTR _dwPos$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR _mciSeekParms$[ebp+4], eax

; 430  : 	
; 431  : 	mciSendCommand(muiDeviceID,MCI_SEEK,MCI_TO,(DWORD)(LPVOID)&mciSeekParms);

  0000b	8d 45 f8	 lea	 eax, DWORD PTR _mciSeekParms$[ebp]
  0000e	50		 push	 eax
  0000f	6a 08		 push	 8
  00011	68 07 08 00 00	 push	 2055			; 00000807H
  00016	ff 31		 push	 DWORD PTR [ecx]
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16

; 432  : //	Play();
; 433  : }

  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
?SetPosition@CMP3@@QAEXK@Z ENDP				; CMP3::SetPosition
_TEXT	ENDS
PUBLIC	?GetStatus@CMP3@@AAEKK@Z			; CMP3::GetStatus
; Function compile flags: /Ogsy
;	COMDAT ?GetStatus@CMP3@@AAEKK@Z
_TEXT	SEGMENT
_mciStatusParms$ = -16					; size = 16
_dwFlag$ = 8						; size = 4
?GetStatus@CMP3@@AAEKK@Z PROC NEAR			; CMP3::GetStatus, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 481  :   MCI_STATUS_PARMS mciStatusParms;
; 482  : 
; 483  : 	mciStatusParms.dwItem = dwFlag;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dwFlag$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _mciStatusParms$[ebp+8], eax

; 484  : 	mciSendCommand(muiDeviceID, MCI_STATUS, 
; 485  : 		           MCI_STATUS_ITEM, (DWORD)(LPVOID)&mciStatusParms);

  0000c	8d 45 f0	 lea	 eax, DWORD PTR _mciStatusParms$[ebp]
  0000f	50		 push	 eax
  00010	68 00 01 00 00	 push	 256			; 00000100H
  00015	68 14 08 00 00	 push	 2068			; 00000814H
  0001a	ff 31		 push	 DWORD PTR [ecx]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16

; 486  : 
; 487  : 	return mciStatusParms.dwReturn;

  00022	8b 45 f4	 mov	 eax, DWORD PTR _mciStatusParms$[ebp+4]

; 488  : }

  00025	c9		 leave
  00026	c2 04 00	 ret	 4
?GetStatus@CMP3@@AAEKK@Z ENDP				; CMP3::GetStatus
_TEXT	ENDS
PUBLIC	__real@3ef179ec9cbd821e
PUBLIC	__real@404e000000000000
PUBLIC	__real@41f0000000000000
PUBLIC	?MinsFromSecs@CMP3@@AAEXKPAD@Z			; CMP3::MinsFromSecs
PUBLIC	??_C@_09INHAPJDF@?$CF?42d?3?$CF?42d?$AA@	; `string'
EXTRN	__imp__wsprintfA:NEAR
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
CONST	ENDS
;	COMDAT __real@3ef179ec9cbd821e
CONST	SEGMENT
__real@3ef179ec9cbd821e DQ 03ef179ec9cbd821er	; 1.66667e-005
CONST	ENDS
;	COMDAT __real@404e000000000000
CONST	SEGMENT
__real@404e000000000000 DQ 0404e000000000000r	; 60
CONST	ENDS
;	COMDAT ??_C@_09INHAPJDF@?$CF?42d?3?$CF?42d?$AA@
CONST	SEGMENT
??_C@_09INHAPJDF@?$CF?42d?3?$CF?42d?$AA@ DB '%.2d:%.2d', 00H ; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?MinsFromSecs@CMP3@@AAEXKPAD@Z
_TEXT	SEGMENT
tv133 = 8						; size = 4
_iMinutes$ = 8						; size = 4
_dwLength$ = 8						; size = 4
_lpszReturn$ = 12					; size = 4
?MinsFromSecs@CMP3@@AAEXKPAD@Z PROC NEAR		; CMP3::MinsFromSecs, COMDAT
; _this$ = ecx

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 494  :   double dMilliSeconds;
; 495  :   int    iMinutes, iSeconds;
; 496  : 
; 497  : 	dMilliSeconds = (double)dwLength / 1000 / 60;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwLength$[ebp]
  00006	db 45 08	 fild	 DWORD PTR _dwLength$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	7d 06		 jge	 SHORT $L104047
  0000d	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L104047:
  00013	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3ef179ec9cbd821e

; 498  : 	iMinutes      = (int)dMilliSeconds;

  00019	d9 c0		 fld	 ST(0)
  0001b	e8 00 00 00 00	 call	 __ftol2
  00020	89 45 08	 mov	 DWORD PTR _iMinutes$[ebp], eax

; 499  : 	dMilliSeconds -= iMinutes;
; 500  : 	iSeconds      = (int)(dMilliSeconds * 60);
; 501  : 
; 502  : 	wsprintf(lpszReturn, "%.2d:%.2d", iMinutes, iSeconds);

  00023	db 45 08	 fild	 DWORD PTR _iMinutes$[ebp]
  00026	d8 e9		 fsubr	 ST(0), ST(1)
  00028	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@404e000000000000
  0002e	e8 00 00 00 00	 call	 __ftol2
  00033	dd d8		 fstp	 ST(0)
  00035	50		 push	 eax
  00036	ff 75 08	 push	 DWORD PTR _iMinutes$[ebp]
  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09INHAPJDF@?$CF?42d?3?$CF?42d?$AA@
  0003e	ff 75 0c	 push	 DWORD PTR _lpszReturn$[ebp]
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00047	83 c4 10	 add	 esp, 16			; 00000010H

; 503  : 	return;
; 504  : }

  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
?MinsFromSecs@CMP3@@AAEXKPAD@Z ENDP			; CMP3::MinsFromSecs
_TEXT	ENDS
PUBLIC	?GetErrorString@CMP3@@QAEXKPAD@Z		; CMP3::GetErrorString
EXTRN	__imp__mciGetErrorStringA@12:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?GetErrorString@CMP3@@QAEXKPAD@Z
_TEXT	SEGMENT
_dwErrCode$ = 8						; size = 4
_lpszErrString$ = 12					; size = 4
?GetErrorString@CMP3@@QAEXKPAD@Z PROC NEAR		; CMP3::GetErrorString, COMDAT
; _this$ = ecx

; 510  : 	mciGetErrorString(dwErrCode, lpszErrString, sizeof(lpszErrString));

  00000	6a 04		 push	 4
  00002	ff 74 24 0c	 push	 DWORD PTR _lpszErrString$[esp]
  00006	ff 74 24 0c	 push	 DWORD PTR _dwErrCode$[esp+4]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciGetErrorStringA@12

; 511  : 	return;
; 512  : }

  00010	c2 08 00	 ret	 8
?GetErrorString@CMP3@@QAEXKPAD@Z ENDP			; CMP3::GetErrorString
_TEXT	ENDS
PUBLIC	?IsReady@CMP3@@QAE_NXZ				; CMP3::IsReady
; Function compile flags: /Ogsy
;	COMDAT ?IsReady@CMP3@@QAE_NXZ
_TEXT	SEGMENT
?IsReady@CMP3@@QAE_NXZ PROC NEAR			; CMP3::IsReady, COMDAT
; _this$ = ecx

; 518  :   bool bReturn;
; 519  : 
; 520  : 	bReturn = (GetStatus(MCI_STATUS_MODE) == MCI_MODE_NOT_READY);

  00000	6a 04		 push	 4
  00002	e8 00 00 00 00	 call	 ?GetStatus@CMP3@@AAEKK@Z ; CMP3::GetStatus
  00007	3d 0c 02 00 00	 cmp	 eax, 524		; 0000020cH
  0000c	0f 94 c0	 sete	 al

; 521  : 
; 522  : 	return bReturn;
; 523  : }

  0000f	c3		 ret	 0
?IsReady@CMP3@@QAE_NXZ ENDP				; CMP3::IsReady
_TEXT	ENDS
PUBLIC	?IsPause@CMP3@@QAE_NXZ				; CMP3::IsPause
; Function compile flags: /Ogsy
;	COMDAT ?IsPause@CMP3@@QAE_NXZ
_TEXT	SEGMENT
?IsPause@CMP3@@QAE_NXZ PROC NEAR			; CMP3::IsPause, COMDAT
; _this$ = ecx

; 529  :   bool bReturn;
; 530  : 
; 531  : 	bReturn = (GetStatus(MCI_STATUS_MODE) == MCI_MODE_PAUSE);

  00000	6a 04		 push	 4
  00002	e8 00 00 00 00	 call	 ?GetStatus@CMP3@@AAEKK@Z ; CMP3::GetStatus
  00007	3d 11 02 00 00	 cmp	 eax, 529		; 00000211H
  0000c	0f 94 c0	 sete	 al

; 532  : 
; 533  : 	return bReturn;
; 534  : }

  0000f	c3		 ret	 0
?IsPause@CMP3@@QAE_NXZ ENDP				; CMP3::IsPause
_TEXT	ENDS
PUBLIC	?IsPlay@CMP3@@QAE_NXZ				; CMP3::IsPlay
; Function compile flags: /Ogsy
;	COMDAT ?IsPlay@CMP3@@QAE_NXZ
_TEXT	SEGMENT
?IsPlay@CMP3@@QAE_NXZ PROC NEAR				; CMP3::IsPlay, COMDAT
; _this$ = ecx

; 539  :   bool bReturn;
; 540  : 
; 541  : 	bReturn = (GetStatus(MCI_STATUS_MODE) == MCI_MODE_PLAY);

  00000	6a 04		 push	 4
  00002	e8 00 00 00 00	 call	 ?GetStatus@CMP3@@AAEKK@Z ; CMP3::GetStatus
  00007	3d 0e 02 00 00	 cmp	 eax, 526		; 0000020eH
  0000c	0f 94 c0	 sete	 al

; 542  : 
; 543  : 	return bReturn;
; 544  : }

  0000f	c3		 ret	 0
?IsPlay@CMP3@@QAE_NXZ ENDP				; CMP3::IsPlay
_TEXT	ENDS
PUBLIC	?IsStop@CMP3@@QAE_NXZ				; CMP3::IsStop
; Function compile flags: /Ogsy
;	COMDAT ?IsStop@CMP3@@QAE_NXZ
_TEXT	SEGMENT
?IsStop@CMP3@@QAE_NXZ PROC NEAR				; CMP3::IsStop, COMDAT
; _this$ = ecx

; 549  :   bool bReturn;
; 550  : 	
; 551  : 	bReturn = (GetStatus(MCI_STATUS_MODE) == MCI_MODE_STOP);

  00000	6a 04		 push	 4
  00002	e8 00 00 00 00	 call	 ?GetStatus@CMP3@@AAEKK@Z ; CMP3::GetStatus
  00007	3d 0d 02 00 00	 cmp	 eax, 525		; 0000020dH
  0000c	0f 94 c0	 sete	 al

; 552  : 
; 553  : 	return bReturn;
; 554  : }

  0000f	c3		 ret	 0
?IsStop@CMP3@@QAE_NXZ ENDP				; CMP3::IsStop
_TEXT	ENDS
PUBLIC	?IsRecord@CMP3@@QAE_NXZ				; CMP3::IsRecord
; Function compile flags: /Ogsy
;	COMDAT ?IsRecord@CMP3@@QAE_NXZ
_TEXT	SEGMENT
?IsRecord@CMP3@@QAE_NXZ PROC NEAR			; CMP3::IsRecord, COMDAT
; _this$ = ecx

; 560  :   bool bReturn;
; 561  : 
; 562  : 	bReturn = (GetStatus(MCI_STATUS_MODE) == MCI_MODE_RECORD);

  00000	6a 04		 push	 4
  00002	e8 00 00 00 00	 call	 ?GetStatus@CMP3@@AAEKK@Z ; CMP3::GetStatus
  00007	3d 0f 02 00 00	 cmp	 eax, 527		; 0000020fH
  0000c	0f 94 c0	 sete	 al

; 563  : 
; 564  : 	return bReturn;
; 565  : }

  0000f	c3		 ret	 0
?IsRecord@CMP3@@QAE_NXZ ENDP				; CMP3::IsRecord
_TEXT	ENDS
PUBLIC	?StatusMode@CMP3@@QAEKXZ			; CMP3::StatusMode
; Function compile flags: /Ogsy
;	COMDAT ?StatusMode@CMP3@@QAEKXZ
_TEXT	SEGMENT
?StatusMode@CMP3@@QAEKXZ PROC NEAR			; CMP3::StatusMode, COMDAT
; _this$ = ecx

; 577  :   DWORD dwResult;
; 578  : 	
; 579  : 	dwResult = GetStatus(MCI_STATUS_MODE);

  00000	6a 04		 push	 4
  00002	e8 00 00 00 00	 call	 ?GetStatus@CMP3@@AAEKK@Z ; CMP3::GetStatus

; 580  : 	return dwResult;
; 581  : }

  00007	c3		 ret	 0
?StatusMode@CMP3@@QAEKXZ ENDP				; CMP3::StatusMode
_TEXT	ENDS
PUBLIC	?GetVolume@CMP3@@QAEKXZ				; CMP3::GetVolume
EXTRN	__imp__waveOutGetVolume@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?GetVolume@CMP3@@QAEKXZ
_TEXT	SEGMENT
_dwVolume$ = -4						; size = 4
?GetVolume@CMP3@@QAEKXZ PROC NEAR			; CMP3::GetVolume, COMDAT
; _this$ = ecx

; 585  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 586  :   DWORD    dwVolume, dwReturn;
; 587  :   MMRESULT mmsError;
; 588  : 
; 589  : 	mmsError = waveOutGetVolume(0, (LPDWORD)&dwVolume);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _dwVolume$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetVolume@8

; 590  : 	dwReturn = LOWORD(dwVolume);
; 591  : 
; 592  : 	return dwReturn;

  00010	0f b7 45 fc	 movzx	 eax, WORD PTR _dwVolume$[ebp]

; 593  : }

  00014	c9		 leave
  00015	c3		 ret	 0
?GetVolume@CMP3@@QAEKXZ ENDP				; CMP3::GetVolume
_TEXT	ENDS
PUBLIC	?SetVolume@CMP3@@QAEXK@Z			; CMP3::SetVolume
EXTRN	__imp__waveOutSetVolume@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?SetVolume@CMP3@@QAEXK@Z
_TEXT	SEGMENT
_dwVolume$ = 8						; size = 4
?SetVolume@CMP3@@QAEXK@Z PROC NEAR			; CMP3::SetVolume, COMDAT
; _this$ = ecx

; 597  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 598  :   MMRESULT mmsError;
; 599  :   long     lLeftVol, lRightVol;
; 600  : 
; 601  :   if(m_oldVolume == 0xffffffff)

  00003	83 7e 08 ff	 cmp	 DWORD PTR [esi+8], -1
  00007	75 08		 jne	 SHORT $L103383

; 602  : 	  m_oldVolume = GetVolume();

  00009	e8 00 00 00 00	 call	 ?GetVolume@CMP3@@QAEKXZ	; CMP3::GetVolume
  0000e	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L103383:

; 603  : 
; 604  : 	lLeftVol  = dwVolume;
; 605  : 	lRightVol = dwVolume;
; 606  : 	dwVolume  = (dwVolume << 16) + lRightVol;
; 607  : 
; 608  : 	mmsError = waveOutSetVolume(0, dwVolume);

  00011	8b 44 24 08	 mov	 eax, DWORD PTR _dwVolume$[esp]
  00015	69 c0 01 00 01
	00		 imul	 eax, 65537		; 00010001H
  0001b	50		 push	 eax
  0001c	6a 00		 push	 0
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutSetVolume@8
  00024	5e		 pop	 esi

; 609  : 	return;
; 610  : }

  00025	c2 04 00	 ret	 4
?SetVolume@CMP3@@QAEXK@Z ENDP				; CMP3::SetVolume
_TEXT	ENDS
PUBLIC	??1CMP3@@QAE@XZ					; CMP3::~CMP3
; Function compile flags: /Ogsy
;	COMDAT ??1CMP3@@QAE@XZ
_TEXT	SEGMENT
??1CMP3@@QAE@XZ PROC NEAR				; CMP3::~CMP3, COMDAT
; _this$ = ecx

; 281  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 282  : 	Stop();

  00003	e8 00 00 00 00	 call	 ?Stop@CMP3@@QAEKXZ	; CMP3::Stop

; 283  : 	Close();

  00008	8b ce		 mov	 ecx, esi
  0000a	e8 00 00 00 00	 call	 ?Close@CMP3@@QAEXXZ	; CMP3::Close

; 284  : 	SetVolume(m_oldVolume);

  0000f	ff 76 08	 push	 DWORD PTR [esi+8]
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?SetVolume@CMP3@@QAEXK@Z ; CMP3::SetVolume
  00019	5e		 pop	 esi

; 285  : }

  0001a	c3		 ret	 0
??1CMP3@@QAE@XZ ENDP					; CMP3::~CMP3
_TEXT	ENDS
PUBLIC	??_C@_09LDHKDNLA@MPEGVideo?$AA@			; `string'
PUBLIC	?Open@CMP3@@QAEKPBD@Z				; CMP3::Open
;	COMDAT ??_C@_09LDHKDNLA@MPEGVideo?$AA@
CONST	SEGMENT
??_C@_09LDHKDNLA@MPEGVideo?$AA@ DB 'MPEGVideo', 00H	; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?Open@CMP3@@QAEKPBD@Z
_TEXT	SEGMENT
_mciOpenParms$ = -32					; size = 20
_mciSetParms$ = -12					; size = 12
_lpcszFileName$ = 8					; size = 4
?Open@CMP3@@QAEKPBD@Z PROC NEAR				; CMP3::Open, COMDAT
; _this$ = ecx

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 300  : /*  MCI_OPEN_PARMS mciOpenParms;
; 301  :   MCI_SET_PARMS mciSetParms;
; 302  : 	mciOpenParms.lpstrElementName = lpcszFileName;
; 303  : 	mciOpenParms.lpstrDeviceType = "MPEGVideo";
; 304  : 	mciSendCommand(NULL,MCI_OPEN,MCI_OPEN_ELEMENT|MCI_OPEN_TYPE,(DWORD)(LPVOID)&mciOpenParms);
; 305  : 	muiDeviceID = mciOpenParms.wDeviceID;
; 306  : 	MCI_STATUS_PARMS mciStatusParms;
; 307  : 	mciStatusParms.dwItem = MCI_STATUS_LENGTH;
; 308  : 	mciSendCommand(muiDeviceID,MCI_STATUS,MCI_STATUS_ITEM,(DWORD)(LPVOID)&mciStatusParms);
; 309  : //	m_nTotalTime = (LONG)mciStatusParms.dwReturn;
; 310  : 	return 0;
; 311  : */
; 312  : 
; 313  : 	
; 314  : 	
; 315  : 	
; 316  :   DWORD dwResult;
; 317  :   MCI_OPEN_PARMS mciOpenParms;
; 318  :   MCI_SET_PARMS mciSetParms;
; 319  : 
; 320  : 
; 321  : 	if (StatusMode() != MCI_MODE_NOT_READY) {

  00009	6a 04		 push	 4
  0000b	8b f9		 mov	 edi, ecx
  0000d	e8 00 00 00 00	 call	 ?GetStatus@CMP3@@AAEKK@Z ; CMP3::GetStatus
  00012	3d 0c 02 00 00	 cmp	 eax, 524		; 0000020cH
  00017	74 07		 je	 SHORT $L103244

; 322  : 
; 323  : 		Close();

  00019	8b cf		 mov	 ecx, edi
  0001b	e8 00 00 00 00	 call	 ?Close@CMP3@@QAEXXZ	; CMP3::Close
$L103244:

; 324  : 	}
; 325  : 
; 326  : 	
; 327  : 
; 328  : 
; 329  : 	// 장치오픈
; 330  : 	mciOpenParms.lpstrDeviceType = "MPEGVideo";
; 331  : 	mciOpenParms.lpstrElementName = lpcszFileName;

  00020	8b 45 08	 mov	 eax, DWORD PTR _lpcszFileName$[ebp]

; 332  : 
; 333  : 	dwResult = mciSendCommand(0,
; 334  : 		                      MCI_OPEN,
; 335  : 							  MCI_OPEN_ELEMENT|MCI_OPEN_TYPE,
; 336  : 							  (DWORD)(LPVOID)&mciOpenParms);

  00023	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__mciSendCommandA@16
  00029	89 45 ec	 mov	 DWORD PTR _mciOpenParms$[ebp+12], eax
  0002c	8d 45 e0	 lea	 eax, DWORD PTR _mciOpenParms$[ebp]
  0002f	50		 push	 eax
  00030	68 00 22 00 00	 push	 8704			; 00002200H
  00035	68 03 08 00 00	 push	 2051			; 00000803H
  0003a	6a 00		 push	 0
  0003c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _mciOpenParms$[ebp+8], OFFSET FLAT:??_C@_09LDHKDNLA@MPEGVideo?$AA@
  00043	ff d6		 call	 esi
  00045	8b d8		 mov	 ebx, eax

; 337  : 
; 338  : 	// 정상적으로 오픈되었으면 ID 발급
; 339  : 	if (dwResult == 0) {

  00047	85 db		 test	 ebx, ebx
  00049	75 19		 jne	 SHORT $L103248

; 340  : 
; 341  : 		muiDeviceID = mciOpenParms.wDeviceID;

  0004b	8b 45 e4	 mov	 eax, DWORD PTR _mciOpenParms$[ebp+4]

; 342  : 
; 343  : 		// Set Time Format
; 344  : 		mciSetParms.dwTimeFormat = MCI_FORMAT_MILLISECONDS;

  0004e	21 5d f8	 and	 DWORD PTR _mciSetParms$[ebp+4], ebx

; 345  : 		mciSendCommand(muiDeviceID, MCI_SET, 
; 346  : 			           MCI_SET_TIME_FORMAT, (DWORD)(LPVOID)&mciSetParms);

  00051	8d 4d f4	 lea	 ecx, DWORD PTR _mciSetParms$[ebp]
  00054	51		 push	 ecx
  00055	68 00 04 00 00	 push	 1024			; 00000400H
  0005a	68 0d 08 00 00	 push	 2061			; 0000080dH
  0005f	50		 push	 eax
  00060	89 07		 mov	 DWORD PTR [edi], eax
  00062	ff d6		 call	 esi
$L103248:
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi

; 347  : 	}
; 348  : 
; 349  : 	return dwResult;

  00066	8b c3		 mov	 eax, ebx
  00068	5b		 pop	 ebx

; 350  : 	
; 351  : }

  00069	c9		 leave
  0006a	c2 04 00	 ret	 4
?Open@CMP3@@QAEKPBD@Z ENDP				; CMP3::Open
_TEXT	ENDS
PUBLIC	?Play@CMP3@@QAEK_N@Z				; CMP3::Play
; Function compile flags: /Ogsy
;	COMDAT ?Play@CMP3@@QAEK_N@Z
_TEXT	SEGMENT
_mciPlayParms$ = -16					; size = 12
_dwResult$ = -4						; size = 4
_bLoop$ = 8						; size = 1
?Play@CMP3@@QAEK_N@Z PROC NEAR				; CMP3::Play, COMDAT
; _this$ = ecx

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 356  :   DWORD          dwResult, dwStatus;
; 357  :   MCI_PLAY_PARMS mciPlayParms;
; 358  : 
; 359  : 	dwStatus = StatusMode();

  00008	6a 04		 push	 4
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ?GetStatus@CMP3@@AAEKK@Z ; CMP3::GetStatus

; 360  : 
; 361  : 	Stop();

  00011	8b ce		 mov	 ecx, esi
  00013	8b f8		 mov	 edi, eax
  00015	e8 00 00 00 00	 call	 ?Stop@CMP3@@QAEKXZ	; CMP3::Stop

; 362  : 
; 363  : 	if (dwStatus != MCI_MODE_NOT_READY) {

  0001a	81 ff 0c 02 00
	00		 cmp	 edi, 524		; 0000020cH
  00020	74 21		 je	 SHORT $L104092

; 364  : 	
; 365  : //		mciPlayParms.dwFrom = dwStart;
; 366  : //		mciPlayParms.dwCallback = (DWORD)hWnddNotify;
; 367  : 		dwResult = mciSendCommand(muiDeviceID, MCI_PLAY, 
; 368  : 			                      MCI_NOTIFY, (DWORD)(LPVOID)&mciPlayParms);

  00022	8d 45 f0	 lea	 eax, DWORD PTR _mciPlayParms$[ebp]
  00025	50		 push	 eax
  00026	6a 01		 push	 1
  00028	68 06 08 00 00	 push	 2054			; 00000806H
  0002d	ff 36		 push	 DWORD PTR [esi]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16

; 369  : 
; 370  : 		if (dwResult) {

  00035	85 c0		 test	 eax, eax
  00037	89 45 fc	 mov	 DWORD PTR _dwResult$[ebp], eax
  0003a	74 07		 je	 SHORT $L104092

; 371  : 			Close();

  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?Close@CMP3@@QAEXXZ	; CMP3::Close
$L104092:

; 372  : 		}
; 373  : 	}
; 374  : 
; 375  : 	m_bLoop = bLoop;

  00043	8a 45 08	 mov	 al, BYTE PTR _bLoop$[ebp]
  00046	88 46 04	 mov	 BYTE PTR [esi+4], al

; 376  : 	return dwResult;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _dwResult$[ebp]
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 377  : }

  0004e	c9		 leave
  0004f	c2 04 00	 ret	 4
?Play@CMP3@@QAEK_N@Z ENDP				; CMP3::Play
_TEXT	ENDS
PUBLIC	?TotalLength@CMP3@@QAEKXZ			; CMP3::TotalLength
; Function compile flags: /Ogsy
;	COMDAT ?TotalLength@CMP3@@QAEKXZ
_TEXT	SEGMENT
?TotalLength@CMP3@@QAEKXZ PROC NEAR			; CMP3::TotalLength, COMDAT
; _this$ = ecx

; 439  :   DWORD dwResult;
; 440  : 
; 441  : 	dwResult = GetStatus(MCI_STATUS_LENGTH);

  00000	6a 01		 push	 1
  00002	e8 00 00 00 00	 call	 ?GetStatus@CMP3@@AAEKK@Z ; CMP3::GetStatus

; 442  : 	return dwResult;
; 443  : }

  00007	c3		 ret	 0
?TotalLength@CMP3@@QAEKXZ ENDP				; CMP3::TotalLength
_TEXT	ENDS
PUBLIC	?TotalLength@CMP3@@QAEKPAD@Z			; CMP3::TotalLength
; Function compile flags: /Ogsy
;	COMDAT ?TotalLength@CMP3@@QAEKPAD@Z
_TEXT	SEGMENT
_lpszReturn$ = 8					; size = 4
?TotalLength@CMP3@@QAEKPAD@Z PROC NEAR			; CMP3::TotalLength, COMDAT
; _this$ = ecx

; 448  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 449  :   DWORD dwResult;
; 450  : 
; 451  : 	dwResult = TotalLength();

  00002	6a 01		 push	 1
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ?GetStatus@CMP3@@AAEKK@Z ; CMP3::GetStatus

; 452  : 	MinsFromSecs(dwResult, lpszReturn);

  0000b	ff 74 24 0c	 push	 DWORD PTR _lpszReturn$[esp+4]
  0000f	8b f8		 mov	 edi, eax
  00011	57		 push	 edi
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?MinsFromSecs@CMP3@@AAEXKPAD@Z ; CMP3::MinsFromSecs

; 453  : 	return dwResult;

  00019	8b c7		 mov	 eax, edi
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 454  : }

  0001d	c2 04 00	 ret	 4
?TotalLength@CMP3@@QAEKPAD@Z ENDP			; CMP3::TotalLength
_TEXT	ENDS
PUBLIC	?CurrentLength@CMP3@@QAEKXZ			; CMP3::CurrentLength
; Function compile flags: /Ogsy
;	COMDAT ?CurrentLength@CMP3@@QAEKXZ
_TEXT	SEGMENT
?CurrentLength@CMP3@@QAEKXZ PROC NEAR			; CMP3::CurrentLength, COMDAT
; _this$ = ecx

; 460  :   DWORD dwResult;
; 461  : 
; 462  : 	dwResult = GetStatus(MCI_STATUS_POSITION);

  00000	6a 02		 push	 2
  00002	e8 00 00 00 00	 call	 ?GetStatus@CMP3@@AAEKK@Z ; CMP3::GetStatus

; 463  : 	return dwResult;
; 464  : }

  00007	c3		 ret	 0
?CurrentLength@CMP3@@QAEKXZ ENDP			; CMP3::CurrentLength
_TEXT	ENDS
PUBLIC	?CurrentLength@CMP3@@QAEKPAD@Z			; CMP3::CurrentLength
; Function compile flags: /Ogsy
;	COMDAT ?CurrentLength@CMP3@@QAEKPAD@Z
_TEXT	SEGMENT
_lpszReturn$ = 8					; size = 4
?CurrentLength@CMP3@@QAEKPAD@Z PROC NEAR		; CMP3::CurrentLength, COMDAT
; _this$ = ecx

; 469  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 470  :   DWORD dwResult;
; 471  : 
; 472  : 	dwResult = CurrentLength();

  00002	6a 02		 push	 2
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ?GetStatus@CMP3@@AAEKK@Z ; CMP3::GetStatus

; 473  : 	MinsFromSecs(dwResult, lpszReturn);

  0000b	ff 74 24 0c	 push	 DWORD PTR _lpszReturn$[esp+4]
  0000f	8b f8		 mov	 edi, eax
  00011	57		 push	 edi
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?MinsFromSecs@CMP3@@AAEXKPAD@Z ; CMP3::MinsFromSecs

; 474  : 	return dwResult;

  00019	8b c7		 mov	 eax, edi
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 475  : }

  0001d	c2 04 00	 ret	 4
?CurrentLength@CMP3@@QAEKPAD@Z ENDP			; CMP3::CurrentLength
_TEXT	ENDS
PUBLIC	??0CMP3@@QAE@PBD@Z				; CMP3::CMP3
; Function compile flags: /Ogsy
;	COMDAT ??0CMP3@@QAE@PBD@Z
_TEXT	SEGMENT
_lpcszFileName$ = 8					; size = 4
??0CMP3@@QAE@PBD@Z PROC NEAR				; CMP3::CMP3, COMDAT
; _this$ = ecx

; 270  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 271  : 	muiDeviceID = 0;

  00003	83 26 00	 and	 DWORD PTR [esi], 0

; 272  : 
; 273  : 	if(lpcszFileName != NULL)

  00006	83 7c 24 08 00	 cmp	 DWORD PTR _lpcszFileName$[esp], 0
  0000b	74 09		 je	 SHORT $L103228

; 274  : 		Open(lpcszFileName);

  0000d	ff 74 24 08	 push	 DWORD PTR _lpcszFileName$[esp]
  00011	e8 00 00 00 00	 call	 ?Open@CMP3@@QAEKPBD@Z	; CMP3::Open
$L103228:

; 275  : 
; 276  : 	m_bLoop = false;
; 277  : 	m_oldVolume = 0xffffffff;

  00016	83 4e 08 ff	 or	 DWORD PTR [esi+8], -1
  0001a	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0

; 278  : }

  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	c2 04 00	 ret	 4
??0CMP3@@QAE@PBD@Z ENDP					; CMP3::CMP3
_TEXT	ENDS
END
