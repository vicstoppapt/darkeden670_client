; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\CSystemInfo.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?theCycleCount@@YA_KXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?cpuid@@YA_NKAAK000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCpuClock@CSystemInfo@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckMMXTechnology@CSystemInfo@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Check3DNowTechnology@CSystemInfo@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckHyperThreadTechnology@CSystemInfo@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?theCycleCount@@YA_KXZ				; theCycleCount
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\csysteminfo.cpp
;	COMDAT ?theCycleCount@@YA_KXZ
_TEXT	SEGMENT
?theCycleCount@@YA_KXZ PROC NEAR			; theCycleCount, COMDAT

; 24   :     
; 25   :     _asm    _emit 0x0F

  00000	0f		 DB	 15			; 0000000fH

; 26   :     _asm    _emit 0x31

  00001	31		 DB	 49			; 00000031H

; 27   :     
; 28   :     // -_- return 은 없지만 _emits 는 __int64를 리턴합니다-_-;
; 29   : }

  00002	c3		 ret	 0
?theCycleCount@@YA_KXZ ENDP				; theCycleCount
_TEXT	ENDS
EXTRN	__SEH_prolog:NEAR
EXTRN	__except_handler3:NEAR
EXTRN	__SEH_epilog:NEAR
;	COMDAT CONST
CONST	SEGMENT
$T100059 DD	0ffffffffH
	DD	FLAT:$L100055
	DD	FLAT:$L100056
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?cpuid@@YA_NKAAK000@Z
_TEXT	SEGMENT
_local_edx$ = -44					; size = 4
_local_ecx$ = -40					; size = 4
_local_ebx$ = -36					; size = 4
_local_eax$ = -32					; size = 4
_retval$ = -25						; size = 1
__$SEHRec$ = -24					; size = 24
_function$ = 8						; size = 4
_out_eax$ = 12						; size = 4
_out_ebx$ = 16						; size = 4
_out_ecx$ = 20						; size = 4
_out_edx$ = 24						; size = 4
?cpuid@@YA_NKAAK000@Z PROC NEAR				; cpuid, COMDAT

; 32   : {

  00000	6a 1c		 push	 28			; 0000001cH
  00002	68 00 00 00 00	 push	 OFFSET FLAT:$T100059
  00007	e8 00 00 00 00	 call	 __SEH_prolog

; 33   : #ifdef _LINUX
; 34   : 	asm("cpuid": "=a" (out_eax), "=b" (out_ebx), "=c" (out_ecx), "=d" (out_edx) : "a" (function));
; 35   : 	return true;
; 36   : #else
; 37   : 	bool retval = true;

  0000c	c6 45 e7 01	 mov	 BYTE PTR _retval$[ebp], 1

; 38   : 	unsigned long local_eax, local_ebx, local_ecx, local_edx;
; 39   : 	_asm pushad;

  00010	60		 pushad

; 40   : 
; 41   : 	__try

  00011	83 65 fc 00	 and	 DWORD PTR __$SEHRec$[ebp+20], 0

; 42   : 	{
; 43   :         _asm
; 44   : 		{
; 45   : 			xor edx, edx		// Clue the compiler that EDX is about to be used.

  00015	33 d2		 xor	 edx, edx

; 46   :             mov eax, function   // set up CPUID to return processor version and features

  00017	8b 45 08	 mov	 eax, DWORD PTR _function$[ebp]

; 47   : 								//      0 = vendor string, 1 = version info, 2 = cache info
; 48   :             cpuid				// code bytes = 0fh,  0a2h

  0001a	0f a2		 cpuid

; 49   :             mov local_eax, eax	// features returned in eax

  0001c	89 45 e0	 mov	 DWORD PTR _local_eax$[ebp], eax

; 50   :             mov local_ebx, ebx	// features returned in ebx

  0001f	89 5d dc	 mov	 DWORD PTR _local_ebx$[ebp], ebx

; 51   :             mov local_ecx, ecx	// features returned in ecx

  00022	89 4d d8	 mov	 DWORD PTR _local_ecx$[ebp], ecx

; 52   :             mov local_edx, edx	// features returned in edx

  00025	89 55 d4	 mov	 DWORD PTR _local_edx$[ebp], edx
  00028	eb 0b		 jmp	 SHORT $L100065
$L100055:
$L100066:

; 53   : 		}
; 54   :     } 
; 55   : 	__except(EXCEPTION_EXECUTE_HANDLER) 

  0002a	33 c0		 xor	 eax, eax
  0002c	40		 inc	 eax
$L100064:
$L100057:
  0002d	c3		 ret	 0
$L100056:
  0002e	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 56   : 	{ 
; 57   : 		retval = false; 

  00031	c6 45 e7 00	 mov	 BYTE PTR _retval$[ebp], 0
$L100065:
  00035	83 4d fc ff	 or	 DWORD PTR __$SEHRec$[ebp+20], -1

; 58   : 	}
; 59   : 
; 60   : 	out_eax = local_eax;

  00039	8b 45 e0	 mov	 eax, DWORD PTR _local_eax$[ebp]
  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR _out_eax$[ebp]
  0003f	89 01		 mov	 DWORD PTR [ecx], eax

; 61   : 	out_ebx = local_ebx;

  00041	8b 45 dc	 mov	 eax, DWORD PTR _local_ebx$[ebp]
  00044	8b 4d 10	 mov	 ecx, DWORD PTR _out_ebx$[ebp]
  00047	89 01		 mov	 DWORD PTR [ecx], eax

; 62   : 	out_ecx = local_ecx;

  00049	8b 45 d8	 mov	 eax, DWORD PTR _local_ecx$[ebp]
  0004c	8b 4d 14	 mov	 ecx, DWORD PTR _out_ecx$[ebp]
  0004f	89 01		 mov	 DWORD PTR [ecx], eax

; 63   : 	out_edx = local_edx;

  00051	8b 45 d4	 mov	 eax, DWORD PTR _local_edx$[ebp]
  00054	8b 4d 18	 mov	 ecx, DWORD PTR _out_edx$[ebp]
  00057	89 01		 mov	 DWORD PTR [ecx], eax

; 64   : 
; 65   : 	_asm popad

  00059	61		 popad

; 66   : 
; 67   : 	return retval;

  0005a	8a 45 e7	 mov	 al, BYTE PTR _retval$[ebp]

; 68   : #endif
; 69   : 
; 70   : 
; 71   : }

  0005d	e8 00 00 00 00	 call	 __SEH_epilog
  00062	c3		 ret	 0
?cpuid@@YA_NKAAK000@Z ENDP				; cpuid
_TEXT	ENDS
PUBLIC	?GetCpuClock@CSystemInfo@@QAEJXZ		; CSystemInfo::GetCpuClock
EXTRN	__imp__Sleep@4:NEAR
EXTRN	__aulldiv:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?GetCpuClock@CSystemInfo@@QAEJXZ
_TEXT	SEGMENT
_start$ = -8						; size = 8
?GetCpuClock@CSystemInfo@@QAEJXZ PROC NEAR		; CSystemInfo::GetCpuClock, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi

; 75   : 	unsigned __int64			start;
; 76   : 	unsigned __int64			overhead;
; 77   : 
; 78   : 	start = theCycleCount();

  00008	0f		 DB	 15			; 0000000fH
  00009	31		 DB	 49			; 00000031H
  0000a	8b f2		 mov	 esi, edx
  0000c	8b c8		 mov	 ecx, eax

; 79   : 	overhead = theCycleCount()-start;

  0000e	0f		 DB	 15			; 0000000fH
  0000f	31		 DB	 49			; 00000031H
  00010	2b c1		 sub	 eax, ecx
  00012	1b d6		 sbb	 edx, esi
  00014	8b f8		 mov	 edi, eax
  00016	8b da		 mov	 ebx, edx

; 80   : 	start = theCycleCount();

  00018	0f		 DB	 15			; 0000000fH
  00019	31		 DB	 49			; 00000031H

; 81   : 	Sleep(100);

  0001a	6a 64		 push	 100			; 00000064H
  0001c	89 55 fc	 mov	 DWORD PTR _start$[ebp+4], edx
  0001f	8b f0		 mov	 esi, eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 82   : 
; 83   : 	unsigned cpuspeed100 = (unsigned)( (theCycleCount()-start-overhead) / 1000 );

  00027	0f		 DB	 15			; 0000000fH
  00028	31		 DB	 49			; 00000031H

; 84   : 	return cpuspeed100 /100;

  00029	2b c7		 sub	 eax, edi
  0002b	1b d3		 sbb	 edx, ebx
  0002d	2b c6		 sub	 eax, esi
  0002f	1b 55 fc	 sbb	 edx, DWORD PTR _start$[ebp+4]
  00032	6a 00		 push	 0
  00034	68 e8 03 00 00	 push	 1000			; 000003e8H
  00039	52		 push	 edx
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 __aulldiv
  00040	6a 64		 push	 100			; 00000064H
  00042	59		 pop	 ecx
  00043	5f		 pop	 edi
  00044	33 d2		 xor	 edx, edx
  00046	5e		 pop	 esi
  00047	f7 f1		 div	 ecx
  00049	5b		 pop	 ebx

; 85   : }

  0004a	c9		 leave
  0004b	c3		 ret	 0
?GetCpuClock@CSystemInfo@@QAEJXZ ENDP			; CSystemInfo::GetCpuClock
_TEXT	ENDS
PUBLIC	?CheckMMXTechnology@CSystemInfo@@QAE_NXZ	; CSystemInfo::CheckMMXTechnology
;	COMDAT CONST
CONST	SEGMENT
$T100097 DD	0ffffffffH
	DD	FLAT:$L100089
	DD	FLAT:$L100090
	DD	0ffffffffH
	DD	FLAT:$L100093
	DD	FLAT:$L100094
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?CheckMMXTechnology@CSystemInfo@@QAE_NXZ
_TEXT	SEGMENT
_RegEDX$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
?CheckMMXTechnology@CSystemInfo@@QAE_NXZ PROC NEAR	; CSystemInfo::CheckMMXTechnology, COMDAT
; _this$ = ecx

; 89   : {

  00000	6a 0c		 push	 12			; 0000000cH
  00002	68 00 00 00 00	 push	 OFFSET FLAT:$T100097
  00007	e8 00 00 00 00	 call	 __SEH_prolog

; 90   :     BOOL retval = TRUE;

  0000c	33 f6		 xor	 esi, esi
  0000e	46		 inc	 esi

; 91   :     DWORD RegEDX;
; 92   : 
; 93   : #ifdef CPUID
; 94   : 	_asm pushad;
; 95   : #endif
; 96   : 
; 97   :     __try

  0000f	83 65 fc 00	 and	 DWORD PTR __$SEHRec$[ebp+20], 0

; 98   : 	{
; 99   :         _asm
; 100  : 		{
; 101  : #ifdef CPUID
; 102  : 			xor edx, edx	// Clue the compiler that EDX is about to be used.
; 103  : #endif
; 104  :             mov eax, 1      // set up CPUID to return processor version and features

  00013	b8 01 00 00 00	 mov	 eax, 1

; 105  :                             //      0 = vendor string, 1 = version info, 2 = cache info
; 106  :             CPUID           // code bytes = 0fh,  0a2h

  00018	0f a2		 cpuid

; 107  :             mov RegEDX, edx // features returned in edx

  0001a	89 55 e4	 mov	 DWORD PTR _RegEDX$[ebp], edx
  0001d	eb 09		 jmp	 SHORT $L100101
$L100089:
$L100104:

; 108  : 		}
; 109  :     } 
; 110  : 	__except(EXCEPTION_EXECUTE_HANDLER) 

  0001f	33 c0		 xor	 eax, eax
  00021	40		 inc	 eax
$L100099:
$L100091:
  00022	c3		 ret	 0
$L100090:
  00023	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 111  : 	{ 
; 112  : 		retval = FALSE; 

  00026	33 f6		 xor	 esi, esi
$L100101:
  00028	83 4d fc ff	 or	 DWORD PTR __$SEHRec$[ebp+20], -1

; 113  : 	}
; 114  : 
; 115  : 	// If CPUID not supported, then certainly no MMX extensions.
; 116  :     if (retval)

  0002c	85 f6		 test	 esi, esi
  0002e	74 24		 je	 SHORT $L100102

; 117  : 	{
; 118  : 		if (RegEDX & 0x800000)          // bit 23 is set for MMX technology

  00030	f6 45 e6 80	 test	 BYTE PTR _RegEDX$[ebp+2], -128 ; ffffff80H
  00034	74 1a		 je	 SHORT $L99421

; 119  : 		{
; 120  : 		   __try 

  00036	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 1

; 121  : 		   { 
; 122  : 				// try executing the MMX instruction "emms"
; 123  : 			   _asm EMMS

  0003d	0f 77		 emms
$L100103:
  0003f	83 4d fc ff	 or	 DWORD PTR __$SEHRec$[ebp+20], -1
  00043	eb 0d		 jmp	 SHORT $L99423
$L100093:
$L100105:

; 124  : 		   } 
; 125  : 		   __except(EXCEPTION_EXECUTE_HANDLER) 

  00045	33 c0		 xor	 eax, eax
  00047	40		 inc	 eax
$L100100:
$L100095:
  00048	c3		 ret	 0
$L100094:
  00049	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 126  : 		   { 
; 127  : 			   retval = FALSE; 

  0004c	33 f6		 xor	 esi, esi

; 128  : 		   }
; 129  : 		}
; 130  : 
; 131  : 		else

  0004e	eb ef		 jmp	 SHORT $L100103
$L99421:

; 132  : 			retval = FALSE;           // processor supports CPUID but does not support MMX technology

  00050	33 f6		 xor	 esi, esi
$L99423:

; 133  : 
; 134  : 		// if retval == 0 here, it means the processor has MMX technology but
; 135  : 		// floating-point emulation is on; so MMX technology is unavailable
; 136  : 	}
; 137  : 
; 138  : #ifdef CPUID
; 139  : 	_asm popad;
; 140  : #endif
; 141  : 
; 142  :     return retval;

  00052	85 f6		 test	 esi, esi
$L100102:
  00054	0f 95 c0	 setne	 al

; 143  : }

  00057	e8 00 00 00 00	 call	 __SEH_epilog
  0005c	c3		 ret	 0
?CheckMMXTechnology@CSystemInfo@@QAE_NXZ ENDP		; CSystemInfo::CheckMMXTechnology
_TEXT	ENDS
PUBLIC	?Check3DNowTechnology@CSystemInfo@@QAE_NXZ	; CSystemInfo::Check3DNowTechnology
;	COMDAT CONST
CONST	SEGMENT
$T100119 DD	0ffffffffH
	DD	FLAT:$L100111
	DD	FLAT:$L100112
	DD	0ffffffffH
	DD	FLAT:$L100115
	DD	FLAT:$L100116
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?Check3DNowTechnology@CSystemInfo@@QAE_NXZ
_TEXT	SEGMENT
_RegEAX$ = -32						; size = 4
_retval$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
?Check3DNowTechnology@CSystemInfo@@QAE_NXZ PROC NEAR	; CSystemInfo::Check3DNowTechnology, COMDAT
; _this$ = ecx

; 276  : {

  00000	6a 10		 push	 16			; 00000010H
  00002	68 00 00 00 00	 push	 OFFSET FLAT:$T100119
  00007	e8 00 00 00 00	 call	 __SEH_prolog

; 277  :     BOOL retval = TRUE;

  0000c	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _retval$[ebp], 1

; 278  :     DWORD RegEAX;
; 279  : 
; 280  : #ifdef CPUID
; 281  : 	_asm pushad;
; 282  : #endif
; 283  : 
; 284  :     // First see if we can execute CPUID at all
; 285  : 	__try

  00013	83 65 fc 00	 and	 DWORD PTR __$SEHRec$[ebp+20], 0

; 286  : 	{
; 287  :         _asm
; 288  : 		{
; 289  : #ifdef CPUID
; 290  : //			xor edx, edx			// Clue the compiler that EDX is about to be used.
; 291  : #endif
; 292  :             mov eax, 0x80000000     // setup CPUID to return whether AMD >0x80000000 function are supported.

  00017	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H

; 293  : 									// 0x80000000 = Highest 0x80000000+ function, 0x80000001 = 3DNow support
; 294  :             CPUID					// code bytes = 0fh,  0a2h

  0001c	0f a2		 cpuid

; 295  :             mov RegEAX, eax			// result returned in eax

  0001e	89 45 e0	 mov	 DWORD PTR _RegEAX$[ebp], eax
  00021	eb 0b		 jmp	 SHORT $L100123
$L100111:
$L100126:

; 296  : 		}
; 297  :     } 
; 298  : 	__except(EXCEPTION_EXECUTE_HANDLER) 

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
$L100121:
$L100113:
  00026	c3		 ret	 0
$L100112:
  00027	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 299  : 	{ 
; 300  : 		retval = FALSE; 

  0002a	83 65 e4 00	 and	 DWORD PTR _retval$[ebp], 0
$L100123:
  0002e	83 4d fc ff	 or	 DWORD PTR __$SEHRec$[ebp+20], -1

; 301  : 	}
; 302  : 
; 303  : 	// If CPUID not supported, then there is definitely no 3DNow support
; 304  :     if (retval)

  00032	83 7d e4 00	 cmp	 DWORD PTR _retval$[ebp], 0
  00036	74 38		 je	 SHORT $L100124

; 305  : 	{
; 306  : 		// Are there any "higher" AMD CPUID functions?
; 307  : 		if (RegEAX > 0x80000000L )				

  00038	81 7d e0 00 00
	00 80		 cmp	 DWORD PTR _RegEAX$[ebp], -2147483648 ; 80000000H
  0003f	76 27		 jbe	 SHORT $L99431

; 308  : 		{
; 309  : 		   __try 

  00041	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 1

; 312  : 				{
; 313  : 					mov			eax, 0x80000001		// setup to test for CPU features

  00048	b8 01 00 00 80	 mov	 eax, -2147483647	; 80000001H

; 314  : 					CPUID							// code bytes = 0fh,  0a2h

  0004d	0f a2		 cpuid

; 315  : 					shr			edx, 31				// If bit 31 is set, we have 3DNow support!

  0004f	c1 ea 1f	 shr	 edx, 31			; 0000001fH

; 316  : 					mov			retval, edx			// Save the return value for end of function

  00052	89 55 e4	 mov	 DWORD PTR _retval$[ebp], edx
$L100125:

; 310  : 			{
; 311  : 			_asm

  00055	83 4d fc ff	 or	 DWORD PTR __$SEHRec$[ebp+20], -1
  00059	eb 11		 jmp	 SHORT $L99433
$L100115:
$L100127:

; 317  : 				}
; 318  : 			}
; 319  : 			__except(EXCEPTION_EXECUTE_HANDLER) 

  0005b	33 c0		 xor	 eax, eax
  0005d	40		 inc	 eax
$L100122:
$L100117:
  0005e	c3		 ret	 0
$L100116:
  0005f	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 320  : 			{ 
; 321  : 				retval = FALSE; 

  00062	83 65 e4 00	 and	 DWORD PTR _retval$[ebp], 0

; 322  : 			}
; 323  : 		}
; 324  : 		else

  00066	eb ed		 jmp	 SHORT $L100125
$L99431:

; 325  : 		{
; 326  : 			// processor supports CPUID but does not support AMD CPUID functions
; 327  : 			retval = FALSE;					

  00068	83 65 e4 00	 and	 DWORD PTR _retval$[ebp], 0
$L99433:

; 328  : 		}
; 329  : 	}
; 330  : 
; 331  : #ifdef CPUID
; 332  : 	_asm popad;
; 333  : #endif
; 334  : 
; 335  :     return retval;

  0006c	83 7d e4 00	 cmp	 DWORD PTR _retval$[ebp], 0
$L100124:
  00070	0f 95 c0	 setne	 al

; 336  : }

  00073	e8 00 00 00 00	 call	 __SEH_epilog
  00078	c3		 ret	 0
?Check3DNowTechnology@CSystemInfo@@QAE_NXZ ENDP		; CSystemInfo::Check3DNowTechnology
_TEXT	ENDS
PUBLIC	?CheckHyperThreadTechnology@CSystemInfo@@QAE_NXZ ; CSystemInfo::CheckHyperThreadTechnology
; Function compile flags: /Ogsy
;	COMDAT ?CheckHyperThreadTechnology@CSystemInfo@@QAE_NXZ
_TEXT	SEGMENT
_vendor_id$ = -24					; size = 12
_reg_edx$ = -12						; size = 4
_unused$ = -8						; size = 4
_reg_eax$ = -4						; size = 4
?CheckHyperThreadTechnology@CSystemInfo@@QAE_NXZ PROC NEAR ; CSystemInfo::CheckHyperThreadTechnology, COMDAT
; _this$ = ecx

; 341  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 342  : 	const unsigned int HT_BIT		 = 0x10000000;  // EDX[28] - Bit 28 set indicates Hyper-Threading Technology is supported in hardware.
; 343  : 	const unsigned int FAMILY_ID     = 0x0f00;      // EAX[11:8] - Bit 11 thru 8 contains family processor id
; 344  : 	const unsigned int EXT_FAMILY_ID = 0x0f00000;	// EAX[23:20] - Bit 23 thru 20 contains extended family  processor id
; 345  : 	const unsigned int PENTIUM4_ID   = 0x0f00;		// Pentium 4 family processor id
; 346  : 
; 347  : 	unsigned long unused,
; 348  : 				  reg_eax = 0, 
; 349  : 				  reg_edx = 0,
; 350  : 				  vendor_id[3] = {0, 0, 0};
; 351  : 
; 352  : 	// verify cpuid instruction is supported
; 353  : 	if( !cpuid(0,unused, vendor_id[0],vendor_id[2],vendor_id[1]) 
; 354  : 	 || !cpuid(1,reg_eax,unused,unused,reg_edx) )

  00006	8d 4d ec	 lea	 ecx, DWORD PTR _vendor_id$[ebp+4]
  00009	51		 push	 ecx
  0000a	8d 4d f0	 lea	 ecx, DWORD PTR _vendor_id$[ebp+8]
  0000d	51		 push	 ecx
  0000e	33 c0		 xor	 eax, eax
  00010	8d 4d e8	 lea	 ecx, DWORD PTR _vendor_id$[ebp]
  00013	51		 push	 ecx
  00014	8d 4d f8	 lea	 ecx, DWORD PTR _unused$[ebp]
  00017	51		 push	 ecx
  00018	50		 push	 eax
  00019	89 45 fc	 mov	 DWORD PTR _reg_eax$[ebp], eax
  0001c	89 45 f4	 mov	 DWORD PTR _reg_edx$[ebp], eax
  0001f	89 45 e8	 mov	 DWORD PTR _vendor_id$[ebp], eax
  00022	89 45 ec	 mov	 DWORD PTR _vendor_id$[ebp+4], eax
  00025	89 45 f0	 mov	 DWORD PTR _vendor_id$[ebp+8], eax
  00028	e8 00 00 00 00	 call	 ?cpuid@@YA_NKAAK000@Z	; cpuid
  0002d	83 c4 14	 add	 esp, 20			; 00000014H
  00030	84 c0		 test	 al, al
  00032	74 55		 je	 SHORT $L99446
  00034	8d 45 f4	 lea	 eax, DWORD PTR _reg_edx$[ebp]
  00037	50		 push	 eax
  00038	8d 45 f8	 lea	 eax, DWORD PTR _unused$[ebp]
  0003b	50		 push	 eax
  0003c	50		 push	 eax
  0003d	8d 45 fc	 lea	 eax, DWORD PTR _reg_eax$[ebp]
  00040	50		 push	 eax
  00041	6a 01		 push	 1
  00043	e8 00 00 00 00	 call	 ?cpuid@@YA_NKAAK000@Z	; cpuid
  00048	83 c4 14	 add	 esp, 20			; 00000014H
  0004b	84 c0		 test	 al, al
  0004d	74 3a		 je	 SHORT $L99446

; 356  : 
; 357  : 	//  Check to see if this is a Pentium 4 or later processor
; 358  : 	if (((reg_eax & FAMILY_ID) ==  PENTIUM4_ID) || (reg_eax & EXT_FAMILY_ID))

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _reg_eax$[ebp]
  00052	b8 00 0f 00 00	 mov	 eax, 3840		; 00000f00H
  00057	23 c8		 and	 ecx, eax
  00059	3b c8		 cmp	 ecx, eax
  0005b	74 06		 je	 SHORT $L99448
  0005d	f6 45 fe f0	 test	 BYTE PTR _reg_eax$[ebp+2], -16 ; fffffff0H
  00061	74 26		 je	 SHORT $L99446
$L99448:

; 359  : 		if (vendor_id[0] == 'uneG' && vendor_id[1] == 'Ieni' && vendor_id[2] == 'letn')

  00063	81 7d e8 47 65
	6e 75		 cmp	 DWORD PTR _vendor_id$[ebp], 1970169159 ; 756e6547H
  0006a	75 1d		 jne	 SHORT $L99446
  0006c	81 7d ec 69 6e
	65 49		 cmp	 DWORD PTR _vendor_id$[ebp+4], 1231384169 ; 49656e69H
  00073	75 14		 jne	 SHORT $L99446
  00075	81 7d f0 6e 74
	65 6c		 cmp	 DWORD PTR _vendor_id$[ebp+8], 1818588270 ; 6c65746eH
  0007c	75 0b		 jne	 SHORT $L99446

; 360  : 			return (reg_edx & HT_BIT) != 0;	// Genuine Intel Processor with Hyper-Threading Technology

  0007e	8b 45 f4	 mov	 eax, DWORD PTR _reg_edx$[ebp]
  00081	c1 e8 1c	 shr	 eax, 28			; 0000001cH
  00084	83 e0 01	 and	 eax, 1

; 361  : 
; 362  : 	return false;  // This is not a genuine Intel processor.
; 363  : }

  00087	c9		 leave
  00088	c3		 ret	 0
$L99446:

; 355  : 	 return false;

  00089	32 c0		 xor	 al, al

; 361  : 
; 362  : 	return false;  // This is not a genuine Intel processor.
; 363  : }

  0008b	c9		 leave
  0008c	c3		 ret	 0
?CheckHyperThreadTechnology@CSystemInfo@@QAE_NXZ ENDP	; CSystemInfo::CheckHyperThreadTechnology
_TEXT	ENDS
END
