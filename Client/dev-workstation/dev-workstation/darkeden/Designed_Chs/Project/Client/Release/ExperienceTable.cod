; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\ExperienceTable.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BN@ODLNCKCA@Data?2?2Info?2?2ClientConfig?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@DFPLPGPC@Data?2?2Info?2?2GuildMapper?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@LHODHNBK@Data?2?2Info?2?2GuildVersion?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@DDPLNCOL@Data?2?2Info?2?2Player?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@ILLNAPHB@Data?2?2Info?2?2Resolution?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@HEIGFDLG@Data?2?2Info?2?2SelectedChannel?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?start@CNFS@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@CNFS@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@VirtualFileHeader@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1IFileIO@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIFileIO@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iovfs_base@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Giovfs_base@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1iovfs_base@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@iovfs_base@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Givfstream@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ivfstream@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?open@ivfstream@@UAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?read@ivfstream@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Govfstream@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ovfstream@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?open@ovfstream@@UAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ExperienceTable@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ExperienceTable@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@ExperienceTable@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFileSTR@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFileDEX@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFileINT@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFileVampire@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFileOusters@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFileSlayerRank@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFileVampireRank@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFileOustersRank@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFilePetExp@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFileAdvanceMent@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSTRInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDEXInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetINTInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVampireInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOustersInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRankInfo@ExperienceTable@@QBEABVExpInfo@@HE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSlayerRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVampireRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOustersRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPetExp@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAdvanceMent@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CTypeTable@VExpInfo@@@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CTypeTable@VExpInfo@@@@QAEAAVExpInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTypeTable@VExpInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTypeTable@VExpInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVIFileIO@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVovfstream@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVivfstream@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AViovfs_base@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4IFileIO@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ovfstream@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ivfstream@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4iovfs_base@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@_STL@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ovfstream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ivfstream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7iovfs_base@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IFileIO@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pExperienceTable@@3PAVExperienceTable@@A	; g_pExperienceTable
_BSS	SEGMENT
?g_pExperienceTable@@3PAVExperienceTable@@A DD 01H DUP (?) ; g_pExperienceTable
_BSS	ENDS
PUBLIC	?read@ivfstream@@QAEXPADI@Z			; ivfstream::read
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\virtualfilesystem\vfstream.inl
;	COMDAT ?read@ivfstream@@QAEXPADI@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
?read@ivfstream@@QAEXPADI@Z PROC NEAR			; ivfstream::read, COMDAT
; _this$ = ecx

; 81   : 	if(m_pFileIO) m_pFileIO->read(buf, len);

  00000	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00004	74 08		 je	 SHORT $L100363
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 60 10	 jmp	 DWORD PTR [eax+16]
$L100363:

; 82   : }

  0000e	c2 08 00	 ret	 8
?read@ivfstream@@QAEXPADI@Z ENDP			; ivfstream::read
_TEXT	ENDS
PUBLIC	??A?$CTypeTable@VExpInfo@@@@QBEABVExpInfo@@H@Z	; CTypeTable<ExpInfo>::operator[]
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\ctypetable.h
;	COMDAT ??A?$CTypeTable@VExpInfo@@@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
??A?$CTypeTable@VExpInfo@@@@QBEABVExpInfo@@H@Z PROC NEAR ; CTypeTable<ExpInfo>::operator[], COMDAT
; _this$ = ecx

; 37   : 		const Type&	operator [] (int type) const	{ return m_pTypeInfo[type]; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR _type$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]
  0000a	c2 04 00	 ret	 4
??A?$CTypeTable@VExpInfo@@@@QBEABVExpInfo@@H@Z ENDP	; CTypeTable<ExpInfo>::operator[]
_TEXT	ENDS
PUBLIC	??A?$CTypeTable@VExpInfo@@@@QAEAAVExpInfo@@H@Z	; CTypeTable<ExpInfo>::operator[]
; Function compile flags: /Ogsy
;	COMDAT ??A?$CTypeTable@VExpInfo@@@@QAEAAVExpInfo@@H@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
??A?$CTypeTable@VExpInfo@@@@QAEAAVExpInfo@@H@Z PROC NEAR ; CTypeTable<ExpInfo>::operator[], COMDAT
; _this$ = ecx

; 38   : 		Type&	operator [] (int type)				{ return m_pTypeInfo[type]; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR _type$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]
  0000a	c2 04 00	 ret	 4
??A?$CTypeTable@VExpInfo@@@@QAEAAVExpInfo@@H@Z ENDP	; CTypeTable<ExpInfo>::operator[]
_TEXT	ENDS
PUBLIC	??0?$CTypeTable@VExpInfo@@@@QAE@XZ		; CTypeTable<ExpInfo>::CTypeTable<ExpInfo>
; Function compile flags: /Ogsy
;	COMDAT ??0?$CTypeTable@VExpInfo@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CTypeTable@VExpInfo@@@@QAE@XZ PROC NEAR		; CTypeTable<ExpInfo>::CTypeTable<ExpInfo>, COMDAT
; _this$ = ecx

; 64   : {

  00000	8b c1		 mov	 eax, ecx

; 65   : 	m_pTypeInfo	= NULL;

  00002	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 66   : 	m_Size		= 0;

  00006	83 20 00	 and	 DWORD PTR [eax], 0

; 67   : }

  00009	c3		 ret	 0
??0?$CTypeTable@VExpInfo@@@@QAE@XZ ENDP			; CTypeTable<ExpInfo>::CTypeTable<ExpInfo>
_TEXT	ENDS
PUBLIC	?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ	; CTypeTable<ExpInfo>::Release
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Ogsy
;	COMDAT ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ
_TEXT	SEGMENT
?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ PROC NEAR	; CTypeTable<ExpInfo>::Release, COMDAT
; _this$ = ecx

; 108  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 109  : 	if (m_pTypeInfo != NULL)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 0e		 je	 SHORT $L101017

; 110  : 	{
; 111  : 		// 모든 CSprite를 지운다.
; 112  : 		delete [] m_pTypeInfo;

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 113  : 		m_pTypeInfo = NULL;

  00010	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 114  : 		
; 115  : 		m_Size = 0;

  00014	83 26 00	 and	 DWORD PTR [esi], 0
  00017	59		 pop	 ecx
$L101017:
  00018	5e		 pop	 esi

; 116  : 	}
; 117  : }

  00019	c3		 ret	 0
?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ENDP		; CTypeTable<ExpInfo>::Release
_TEXT	ENDS
PUBLIC	?Release@ExperienceTable@@QAEXXZ		; ExperienceTable::Release
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\experiencetable.cpp
;	COMDAT ?Release@ExperienceTable@@QAEXXZ
_TEXT	SEGMENT
?Release@ExperienceTable@@QAEXXZ PROC NEAR		; ExperienceTable::Release, COMDAT
; _this$ = ecx

; 36   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 37   : 	m_STRExp.Release();

  00003	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release

; 38   : 	m_DEXExp.Release();

  00008	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0000b	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release

; 39   : 	m_INTExp.Release();

  00010	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00013	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release

; 40   : 	m_VampireExp.Release();

  00018	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0001b	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release

; 41   : 	m_OustersExp.Release();

  00020	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00023	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release

; 42   : 	m_SlayerRankExp.Release();

  00028	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  0002b	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release

; 43   : 	m_VampireRankExp.Release();

  00030	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00033	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release

; 44   : 	m_OustersRankExp.Release();

  00038	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  0003b	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release

; 45   : 	m_PetExp.Release();

  00040	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  00043	5e		 pop	 esi
  00044	e9 00 00 00 00	 jmp	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release
?Release@ExperienceTable@@QAEXXZ ENDP			; ExperienceTable::Release
_TEXT	ENDS
PUBLIC	?GetSTRInfo@ExperienceTable@@QBEABVExpInfo@@H@Z	; ExperienceTable::GetSTRInfo
; Function compile flags: /Ogsy
;	COMDAT ?GetSTRInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?GetSTRInfo@ExperienceTable@@QBEABVExpInfo@@H@Z PROC NEAR ; ExperienceTable::GetSTRInfo, COMDAT
; _this$ = ecx

; 268  : 	return m_STRExp[level];

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR _level$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 269  : }

  0000a	c2 04 00	 ret	 4
?GetSTRInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ENDP	; ExperienceTable::GetSTRInfo
_TEXT	ENDS
PUBLIC	?GetDEXInfo@ExperienceTable@@QBEABVExpInfo@@H@Z	; ExperienceTable::GetDEXInfo
; Function compile flags: /Ogsy
;	COMDAT ?GetDEXInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?GetDEXInfo@ExperienceTable@@QBEABVExpInfo@@H@Z PROC NEAR ; ExperienceTable::GetDEXInfo, COMDAT
; _this$ = ecx

; 277  : 	return m_DEXExp[level];

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR _level$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 278  : }

  0000a	c2 04 00	 ret	 4
?GetDEXInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ENDP	; ExperienceTable::GetDEXInfo
_TEXT	ENDS
PUBLIC	?GetINTInfo@ExperienceTable@@QBEABVExpInfo@@H@Z	; ExperienceTable::GetINTInfo
; Function compile flags: /Ogsy
;	COMDAT ?GetINTInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?GetINTInfo@ExperienceTable@@QBEABVExpInfo@@H@Z PROC NEAR ; ExperienceTable::GetINTInfo, COMDAT
; _this$ = ecx

; 286  : 	return m_INTExp[level];

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR _level$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 287  : }

  0000a	c2 04 00	 ret	 4
?GetINTInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ENDP	; ExperienceTable::GetINTInfo
_TEXT	ENDS
PUBLIC	?GetVampireInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ; ExperienceTable::GetVampireInfo
; Function compile flags: /Ogsy
;	COMDAT ?GetVampireInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?GetVampireInfo@ExperienceTable@@QBEABVExpInfo@@H@Z PROC NEAR ; ExperienceTable::GetVampireInfo, COMDAT
; _this$ = ecx

; 295  : 	return m_VampireExp[level];

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR _level$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 296  : }

  0000a	c2 04 00	 ret	 4
?GetVampireInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ENDP ; ExperienceTable::GetVampireInfo
_TEXT	ENDS
PUBLIC	?GetOustersInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ; ExperienceTable::GetOustersInfo
; Function compile flags: /Ogsy
;	COMDAT ?GetOustersInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?GetOustersInfo@ExperienceTable@@QBEABVExpInfo@@H@Z PROC NEAR ; ExperienceTable::GetOustersInfo, COMDAT
; _this$ = ecx

; 304  : 	return m_OustersExp[level];

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR _level$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 305  : }

  0000a	c2 04 00	 ret	 4
?GetOustersInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ENDP ; ExperienceTable::GetOustersInfo
_TEXT	ENDS
PUBLIC	?GetRankInfo@ExperienceTable@@QBEABVExpInfo@@HE@Z ; ExperienceTable::GetRankInfo
; Function compile flags: /Ogsy
;	COMDAT ?GetRankInfo@ExperienceTable@@QBEABVExpInfo@@HE@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
_race$ = 12						; size = 1
?GetRankInfo@ExperienceTable@@QBEABVExpInfo@@HE@Z PROC NEAR ; ExperienceTable::GetRankInfo, COMDAT
; _this$ = ecx

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 	switch(race)

  00003	0f b6 45 0c	 movzx	 eax, BYTE PTR _race$[ebp]
  00007	83 e8 00	 sub	 eax, 0
  0000a	74 10		 je	 SHORT $L100740
  0000c	48		 dec	 eax
  0000d	74 08		 je	 SHORT $L100741
  0000f	48		 dec	 eax

; 326  : 		break;
; 327  : 	}
; 328  : 
; 329  : 	return m_SlayerRankExp[level];

  00010	75 0a		 jne	 SHORT $L100740

; 321  : 		break;
; 322  : 
; 323  : 	case RACE_OUSTERS:
; 324  : 		//return m_VampireRankExp[level];
; 325  : 		return m_OustersRankExp[level];

  00012	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  00015	eb 08		 jmp	 SHORT $L101627
$L100741:

; 317  : 		break;
; 318  : 
; 319  : 	case RACE_VAMPIRE:
; 320  : 		return m_VampireRankExp[level];

  00017	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0001a	eb 03		 jmp	 SHORT $L101627
$L100740:

; 314  : 	{
; 315  : 	case RACE_SLAYER:
; 316  : 		return m_SlayerRankExp[level];

  0001c	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
$L101627:
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _level$[ebp]
  00022	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 330  : }

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
?GetRankInfo@ExperienceTable@@QBEABVExpInfo@@HE@Z ENDP	; ExperienceTable::GetRankInfo
_TEXT	ENDS
PUBLIC	?GetSlayerRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ; ExperienceTable::GetSlayerRankInfo
; Function compile flags: /Ogsy
;	COMDAT ?GetSlayerRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?GetSlayerRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z PROC NEAR ; ExperienceTable::GetSlayerRankInfo, COMDAT
; _this$ = ecx

; 338  : 	return m_SlayerRankExp[level];

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR _level$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 339  : }

  0000a	c2 04 00	 ret	 4
?GetSlayerRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ENDP ; ExperienceTable::GetSlayerRankInfo
_TEXT	ENDS
PUBLIC	?GetVampireRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ; ExperienceTable::GetVampireRankInfo
; Function compile flags: /Ogsy
;	COMDAT ?GetVampireRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?GetVampireRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z PROC NEAR ; ExperienceTable::GetVampireRankInfo, COMDAT
; _this$ = ecx

; 347  : 	return m_VampireRankExp[level];

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR _level$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 348  : }

  0000a	c2 04 00	 ret	 4
?GetVampireRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ENDP ; ExperienceTable::GetVampireRankInfo
_TEXT	ENDS
PUBLIC	?GetOustersRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ; ExperienceTable::GetOustersRankInfo
; Function compile flags: /Ogsy
;	COMDAT ?GetOustersRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?GetOustersRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z PROC NEAR ; ExperienceTable::GetOustersRankInfo, COMDAT
; _this$ = ecx

; 356  : 	return m_OustersRankExp[level];

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR _level$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 357  : }

  0000a	c2 04 00	 ret	 4
?GetOustersRankInfo@ExperienceTable@@QBEABVExpInfo@@H@Z ENDP ; ExperienceTable::GetOustersRankInfo
_TEXT	ENDS
PUBLIC	?GetPetExp@ExperienceTable@@QBEABVExpInfo@@H@Z	; ExperienceTable::GetPetExp
; Function compile flags: /Ogsy
;	COMDAT ?GetPetExp@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?GetPetExp@ExperienceTable@@QBEABVExpInfo@@H@Z PROC NEAR ; ExperienceTable::GetPetExp, COMDAT
; _this$ = ecx

; 365  : 	return m_PetExp[level];

  00000	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR _level$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 366  : }

  0000a	c2 04 00	 ret	 4
?GetPetExp@ExperienceTable@@QBEABVExpInfo@@H@Z ENDP	; ExperienceTable::GetPetExp
_TEXT	ENDS
PUBLIC	?GetAdvanceMent@ExperienceTable@@QBEABVExpInfo@@H@Z ; ExperienceTable::GetAdvanceMent
; Function compile flags: /Ogsy
;	COMDAT ?GetAdvanceMent@ExperienceTable@@QBEABVExpInfo@@H@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?GetAdvanceMent@ExperienceTable@@QBEABVExpInfo@@H@Z PROC NEAR ; ExperienceTable::GetAdvanceMent, COMDAT
; _this$ = ecx

; 375  : 	return m_advanceSkillExp[level];

  00000	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR _level$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 376  : }

  0000a	c2 04 00	 ret	 4
?GetAdvanceMent@ExperienceTable@@QBEABVExpInfo@@H@Z ENDP ; ExperienceTable::GetAdvanceMent
_TEXT	ENDS
PUBLIC	??1?$CTypeTable@VExpInfo@@@@QAE@XZ		; CTypeTable<ExpInfo>::~CTypeTable<ExpInfo>
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\ctypetable.h
;	COMDAT ??1?$CTypeTable@VExpInfo@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CTypeTable@VExpInfo@@@@QAE@XZ PROC NEAR		; CTypeTable<ExpInfo>::~CTypeTable<ExpInfo>, COMDAT
; _this$ = ecx

; 72   : 	Release();

  00000	e9 00 00 00 00	 jmp	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release
??1?$CTypeTable@VExpInfo@@@@QAE@XZ ENDP			; CTypeTable<ExpInfo>::~CTypeTable<ExpInfo>
_TEXT	ENDS
PUBLIC	?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z		; CTypeTable<ExpInfo>::Init
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
; Function compile flags: /Ogsy
;	COMDAT ?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z PROC NEAR	; CTypeTable<ExpInfo>::Init, COMDAT
; _this$ = ecx

; 87   : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 88   : 	// 개수가 없을 경우 
; 89   : 	if (size==0) 

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _size$[esp+4]
  00006	85 ff		 test	 edi, edi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 16		 je	 SHORT $L101009

; 90   : 		return;
; 91   : 
; 92   : 	// 일단 해제
; 93   : 	Release();

  0000c	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release

; 94   : 
; 95   : 	// 메모리 잡기
; 96   : 	m_Size = size;
; 97   : 	
; 98   : 	m_pTypeInfo = new Type [m_Size];	

  00011	8b c7		 mov	 eax, edi
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	89 3e		 mov	 DWORD PTR [esi], edi
  00019	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0001e	59		 pop	 ecx
  0001f	89 46 04	 mov	 DWORD PTR [esi+4], eax
$L101009:
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 99   : }

  00024	c2 04 00	 ret	 4
?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z ENDP		; CTypeTable<ExpInfo>::Init
_TEXT	ENDS
PUBLIC	??0ExperienceTable@@QAE@XZ			; ExperienceTable::ExperienceTable
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\experiencetable.cpp
;	COMDAT ??0ExperienceTable@@QAE@XZ
_TEXT	SEGMENT
??0ExperienceTable@@QAE@XZ PROC NEAR			; ExperienceTable::ExperienceTable, COMDAT
; _this$ = ecx

; 21   : {

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 08		 mov	 DWORD PTR [eax], ecx
  00009	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0000c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000f	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00012	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00015	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00018	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0001b	89 48 24	 mov	 DWORD PTR [eax+36], ecx
  0001e	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00021	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
  00024	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00027	89 48 34	 mov	 DWORD PTR [eax+52], ecx
  0002a	89 48 30	 mov	 DWORD PTR [eax+48], ecx
  0002d	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  00030	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  00033	89 48 44	 mov	 DWORD PTR [eax+68], ecx
  00036	89 48 40	 mov	 DWORD PTR [eax+64], ecx
  00039	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  0003c	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 22   : 	// 냠냠..
; 23   : }

  0003f	c3		 ret	 0
??0ExperienceTable@@QAE@XZ ENDP				; ExperienceTable::ExperienceTable
_TEXT	ENDS
PUBLIC	??1ExperienceTable@@QAE@XZ			; ExperienceTable::~ExperienceTable
; Function compile flags: /Ogsy
;	COMDAT ??1ExperienceTable@@QAE@XZ
_TEXT	SEGMENT
??1ExperienceTable@@QAE@XZ PROC NEAR			; ExperienceTable::~ExperienceTable, COMDAT
; _this$ = ecx

; 26   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 27   : 	// 음냐.. 안해도 되는데.. 걍..
; 28   : 	Release();

  00003	e8 00 00 00 00	 call	 ?Release@ExperienceTable@@QAEXXZ ; ExperienceTable::Release

; 29   : }

  00008	8d 4e 48	 lea	 ecx, DWORD PTR [esi+72]
  0000b	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release
  00010	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  00013	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release
  00018	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  0001b	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release
  00020	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00023	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release
  00028	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  0002b	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release
  00030	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00033	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release
  00038	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0003b	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release
  00040	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00043	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release
  00048	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0004b	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release
  00050	8b ce		 mov	 ecx, esi
  00052	5e		 pop	 esi
  00053	e9 00 00 00 00	 jmp	 ?Release@?$CTypeTable@VExpInfo@@@@QAEXXZ ; CTypeTable<ExpInfo>::Release
??1ExperienceTable@@QAE@XZ ENDP				; ExperienceTable::~ExperienceTable
_TEXT	ENDS
PUBLIC	?LoadFromFileSTR@ExperienceTable@@QAEXAAVivfstream@@@Z ; ExperienceTable::LoadFromFileSTR
EXTRN	?LoadFromFile@ExpInfo@@QAEXAAVivfstream@@@Z:NEAR ; ExpInfo::LoadFromFile
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFileSTR@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_level$ = -4						; size = 4
_num$ = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFileSTR@ExperienceTable@@QAEXAAVivfstream@@@Z PROC NEAR ; ExperienceTable::LoadFromFileSTR, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 54   : 	int num, level;
; 55   : 	file.read((char*)&num, 4);

  00006	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00009	57		 push	 edi
  0000a	33 ff		 xor	 edi, edi
  0000c	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  0000f	8b d9		 mov	 ebx, ecx
  00011	74 0e		 je	 SHORT $L101765
  00013	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 08	 lea	 edx, DWORD PTR _num$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L101765:

; 56   : 
; 57   : 	// file에는 1 level부터 들어가있는걸로 가정하기 때문에...
; 58   : 	m_STRExp.Init( num + 1 );

  00021	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00024	40		 inc	 eax
  00025	50		 push	 eax
  00026	8b cb		 mov	 ecx, ebx
  00028	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z ; CTypeTable<ExpInfo>::Init

; 59   : 
; 60   : 	for (int i=0; i<num; i++)

  0002d	83 7d 08 00	 cmp	 DWORD PTR _num$[ebp], 0
  00031	7e 29		 jle	 SHORT $L100597
$L101778:

; 61   : 	{
; 62   : 		file.read((char*)&level, 4);

  00033	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00037	74 0e		 je	 SHORT $L101770
  00039	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	6a 04		 push	 4
  00040	8d 55 fc	 lea	 edx, DWORD PTR _level$[ebp]
  00043	52		 push	 edx
  00044	ff 50 10	 call	 DWORD PTR [eax+16]
$L101770:

; 63   : 		
; 64   : 		// level에 맞게 loading한다.
; 65   : 		m_STRExp[level].LoadFromFile( file );		

  00047	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _level$[ebp]
  0004d	56		 push	 esi
  0004e	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00051	e8 00 00 00 00	 call	 ?LoadFromFile@ExpInfo@@QAEXAAVivfstream@@@Z ; ExpInfo::LoadFromFile
  00056	47		 inc	 edi
  00057	3b 7d 08	 cmp	 edi, DWORD PTR _num$[ebp]
  0005a	7c d7		 jl	 SHORT $L101778
$L100597:
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx

; 66   : 	}
; 67   : }

  0005f	c9		 leave
  00060	c2 04 00	 ret	 4
?LoadFromFileSTR@ExperienceTable@@QAEXAAVivfstream@@@Z ENDP ; ExperienceTable::LoadFromFileSTR
_TEXT	ENDS
PUBLIC	?LoadFromFileDEX@ExperienceTable@@QAEXAAVivfstream@@@Z ; ExperienceTable::LoadFromFileDEX
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFileDEX@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_level$ = -4						; size = 4
_num$ = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFileDEX@ExperienceTable@@QAEXAAVivfstream@@@Z PROC NEAR ; ExperienceTable::LoadFromFileDEX, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 75   : 	int num, level;
; 76   : 	file.read((char*)&num, 4);

  00006	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00009	33 db		 xor	 ebx, ebx
  0000b	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	74 0e		 je	 SHORT $L101783
  00013	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 08	 lea	 edx, DWORD PTR _num$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L101783:

; 77   : 
; 78   : 	// file에는 1 level부터 들어가있는걸로 가정하기 때문에...
; 79   : 	m_DEXExp.Init( num + 1 );

  00021	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00024	40		 inc	 eax
  00025	50		 push	 eax
  00026	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00029	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z ; CTypeTable<ExpInfo>::Init

; 80   : 
; 81   : 	for (int i=0; i<num; i++)

  0002e	83 7d 08 00	 cmp	 DWORD PTR _num$[ebp], 0
  00032	7e 29		 jle	 SHORT $L100609
$L101796:

; 82   : 	{
; 83   : 		file.read((char*)&level, 4);

  00034	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00038	74 0e		 je	 SHORT $L101788
  0003a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003f	6a 04		 push	 4
  00041	8d 55 fc	 lea	 edx, DWORD PTR _level$[ebp]
  00044	52		 push	 edx
  00045	ff 50 10	 call	 DWORD PTR [eax+16]
$L101788:

; 84   : 		
; 85   : 		// level에 맞게 loading한다.
; 86   : 		m_DEXExp[level].LoadFromFile( file );		

  00048	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _level$[ebp]
  0004e	56		 push	 esi
  0004f	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00052	e8 00 00 00 00	 call	 ?LoadFromFile@ExpInfo@@QAEXAAVivfstream@@@Z ; ExpInfo::LoadFromFile
  00057	43		 inc	 ebx
  00058	3b 5d 08	 cmp	 ebx, DWORD PTR _num$[ebp]
  0005b	7c d7		 jl	 SHORT $L101796
$L100609:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 87   : 	}
; 88   : }

  00060	c9		 leave
  00061	c2 04 00	 ret	 4
?LoadFromFileDEX@ExperienceTable@@QAEXAAVivfstream@@@Z ENDP ; ExperienceTable::LoadFromFileDEX
_TEXT	ENDS
PUBLIC	?LoadFromFileINT@ExperienceTable@@QAEXAAVivfstream@@@Z ; ExperienceTable::LoadFromFileINT
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFileINT@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_level$ = -4						; size = 4
_num$ = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFileINT@ExperienceTable@@QAEXAAVivfstream@@@Z PROC NEAR ; ExperienceTable::LoadFromFileINT, COMDAT
; _this$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 96   : 	int num, level;
; 97   : 	file.read((char*)&num, 4);

  00006	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00009	33 db		 xor	 ebx, ebx
  0000b	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	74 0e		 je	 SHORT $L101801
  00013	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 08	 lea	 edx, DWORD PTR _num$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L101801:

; 98   : 
; 99   : 	// file에는 1 level부터 들어가있는걸로 가정하기 때문에...
; 100  : 	m_INTExp.Init( num + 1 );

  00021	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00024	40		 inc	 eax
  00025	50		 push	 eax
  00026	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  00029	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z ; CTypeTable<ExpInfo>::Init

; 101  : 
; 102  : 	for (int i=0; i<num; i++)

  0002e	83 7d 08 00	 cmp	 DWORD PTR _num$[ebp], 0
  00032	7e 29		 jle	 SHORT $L100621
$L101814:

; 103  : 	{
; 104  : 		file.read((char*)&level, 4);

  00034	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00038	74 0e		 je	 SHORT $L101806
  0003a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003f	6a 04		 push	 4
  00041	8d 55 fc	 lea	 edx, DWORD PTR _level$[ebp]
  00044	52		 push	 edx
  00045	ff 50 10	 call	 DWORD PTR [eax+16]
$L101806:

; 105  : 		
; 106  : 		// level에 맞게 loading한다.
; 107  : 		m_INTExp[level].LoadFromFile( file );		

  00048	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _level$[ebp]
  0004e	56		 push	 esi
  0004f	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00052	e8 00 00 00 00	 call	 ?LoadFromFile@ExpInfo@@QAEXAAVivfstream@@@Z ; ExpInfo::LoadFromFile
  00057	43		 inc	 ebx
  00058	3b 5d 08	 cmp	 ebx, DWORD PTR _num$[ebp]
  0005b	7c d7		 jl	 SHORT $L101814
$L100621:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 108  : 	}
; 109  : }

  00060	c9		 leave
  00061	c2 04 00	 ret	 4
?LoadFromFileINT@ExperienceTable@@QAEXAAVivfstream@@@Z ENDP ; ExperienceTable::LoadFromFileINT
_TEXT	ENDS
PUBLIC	?LoadFromFileVampire@ExperienceTable@@QAEXAAVivfstream@@@Z ; ExperienceTable::LoadFromFileVampire
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFileVampire@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_level$ = -4						; size = 4
_num$ = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFileVampire@ExperienceTable@@QAEXAAVivfstream@@@Z PROC NEAR ; ExperienceTable::LoadFromFileVampire, COMDAT
; _this$ = ecx

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 117  : 	int num, level;
; 118  : 	file.read((char*)&num, 4);

  00006	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00009	33 db		 xor	 ebx, ebx
  0000b	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	74 0e		 je	 SHORT $L101819
  00013	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 08	 lea	 edx, DWORD PTR _num$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L101819:

; 119  : 
; 120  : 	// file에는 1 level부터 들어가있는걸로 가정하기 때문에...
; 121  : 	m_VampireExp.Init( num + 1 );

  00021	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00024	40		 inc	 eax
  00025	50		 push	 eax
  00026	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00029	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z ; CTypeTable<ExpInfo>::Init

; 122  : 
; 123  : 	for (int i=0; i<num; i++)

  0002e	83 7d 08 00	 cmp	 DWORD PTR _num$[ebp], 0
  00032	7e 29		 jle	 SHORT $L100633
$L101832:

; 124  : 	{
; 125  : 		file.read((char*)&level, 4);

  00034	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00038	74 0e		 je	 SHORT $L101824
  0003a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003f	6a 04		 push	 4
  00041	8d 55 fc	 lea	 edx, DWORD PTR _level$[ebp]
  00044	52		 push	 edx
  00045	ff 50 10	 call	 DWORD PTR [eax+16]
$L101824:

; 126  : 		
; 127  : 		// level에 맞게 loading한다.
; 128  : 		m_VampireExp[level].LoadFromFile( file );		

  00048	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _level$[ebp]
  0004e	56		 push	 esi
  0004f	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00052	e8 00 00 00 00	 call	 ?LoadFromFile@ExpInfo@@QAEXAAVivfstream@@@Z ; ExpInfo::LoadFromFile
  00057	43		 inc	 ebx
  00058	3b 5d 08	 cmp	 ebx, DWORD PTR _num$[ebp]
  0005b	7c d7		 jl	 SHORT $L101832
$L100633:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 129  : 	}
; 130  : }

  00060	c9		 leave
  00061	c2 04 00	 ret	 4
?LoadFromFileVampire@ExperienceTable@@QAEXAAVivfstream@@@Z ENDP ; ExperienceTable::LoadFromFileVampire
_TEXT	ENDS
PUBLIC	?LoadFromFileOusters@ExperienceTable@@QAEXAAVivfstream@@@Z ; ExperienceTable::LoadFromFileOusters
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFileOusters@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_level$ = -4						; size = 4
_num$ = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFileOusters@ExperienceTable@@QAEXAAVivfstream@@@Z PROC NEAR ; ExperienceTable::LoadFromFileOusters, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 138  : 	int num, level;
; 139  : 	file.read((char*)&num, 4);

  00006	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00009	33 db		 xor	 ebx, ebx
  0000b	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	74 0e		 je	 SHORT $L101837
  00013	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 08	 lea	 edx, DWORD PTR _num$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L101837:

; 140  : 	
; 141  : 	// file에는 1 level부터 들어가있는걸로 가정하기 때문에...
; 142  : 	m_OustersExp.Init( num + 1 );

  00021	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00024	40		 inc	 eax
  00025	50		 push	 eax
  00026	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  00029	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z ; CTypeTable<ExpInfo>::Init

; 143  : 	
; 144  : 	for (int i=0; i<num; i++)

  0002e	83 7d 08 00	 cmp	 DWORD PTR _num$[ebp], 0
  00032	7e 29		 jle	 SHORT $L100645
$L101850:

; 145  : 	{
; 146  : 		file.read((char*)&level, 4);

  00034	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00038	74 0e		 je	 SHORT $L101842
  0003a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003f	6a 04		 push	 4
  00041	8d 55 fc	 lea	 edx, DWORD PTR _level$[ebp]
  00044	52		 push	 edx
  00045	ff 50 10	 call	 DWORD PTR [eax+16]
$L101842:

; 147  : 		
; 148  : 		// level에 맞게 loading한다.
; 149  : 		m_OustersExp[level].LoadFromFile( file );		

  00048	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _level$[ebp]
  0004e	56		 push	 esi
  0004f	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00052	e8 00 00 00 00	 call	 ?LoadFromFile@ExpInfo@@QAEXAAVivfstream@@@Z ; ExpInfo::LoadFromFile
  00057	43		 inc	 ebx
  00058	3b 5d 08	 cmp	 ebx, DWORD PTR _num$[ebp]
  0005b	7c d7		 jl	 SHORT $L101850
$L100645:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 150  : 	}
; 151  : }

  00060	c9		 leave
  00061	c2 04 00	 ret	 4
?LoadFromFileOusters@ExperienceTable@@QAEXAAVivfstream@@@Z ENDP ; ExperienceTable::LoadFromFileOusters
_TEXT	ENDS
PUBLIC	?LoadFromFileSlayerRank@ExperienceTable@@QAEXAAVivfstream@@@Z ; ExperienceTable::LoadFromFileSlayerRank
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFileSlayerRank@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_level$ = -4						; size = 4
_num$ = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFileSlayerRank@ExperienceTable@@QAEXAAVivfstream@@@Z PROC NEAR ; ExperienceTable::LoadFromFileSlayerRank, COMDAT
; _this$ = ecx

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 159  : 	int num, level;
; 160  : 	file.read((char*)&num, 4);

  00006	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00009	33 db		 xor	 ebx, ebx
  0000b	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	74 0e		 je	 SHORT $L101855
  00013	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 08	 lea	 edx, DWORD PTR _num$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L101855:

; 161  : 
; 162  : 	// file에는 1 level부터 들어가있는걸로 가정하기 때문에...
; 163  : 	m_SlayerRankExp.Init( num + 1 );

  00021	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00024	40		 inc	 eax
  00025	50		 push	 eax
  00026	8d 4f 28	 lea	 ecx, DWORD PTR [edi+40]
  00029	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z ; CTypeTable<ExpInfo>::Init

; 164  : 
; 165  : 	for (int i=0; i<num; i++)

  0002e	83 7d 08 00	 cmp	 DWORD PTR _num$[ebp], 0
  00032	7e 29		 jle	 SHORT $L100657
$L101868:

; 166  : 	{
; 167  : 		file.read((char*)&level, 4);

  00034	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00038	74 0e		 je	 SHORT $L101860
  0003a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003f	6a 04		 push	 4
  00041	8d 55 fc	 lea	 edx, DWORD PTR _level$[ebp]
  00044	52		 push	 edx
  00045	ff 50 10	 call	 DWORD PTR [eax+16]
$L101860:

; 168  : 		
; 169  : 		// level에 맞게 loading한다.
; 170  : 		m_SlayerRankExp[level].LoadFromFile( file );		

  00048	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _level$[ebp]
  0004e	56		 push	 esi
  0004f	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00052	e8 00 00 00 00	 call	 ?LoadFromFile@ExpInfo@@QAEXAAVivfstream@@@Z ; ExpInfo::LoadFromFile
  00057	43		 inc	 ebx
  00058	3b 5d 08	 cmp	 ebx, DWORD PTR _num$[ebp]
  0005b	7c d7		 jl	 SHORT $L101868
$L100657:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 171  : 	}
; 172  : }

  00060	c9		 leave
  00061	c2 04 00	 ret	 4
?LoadFromFileSlayerRank@ExperienceTable@@QAEXAAVivfstream@@@Z ENDP ; ExperienceTable::LoadFromFileSlayerRank
_TEXT	ENDS
PUBLIC	?LoadFromFileVampireRank@ExperienceTable@@QAEXAAVivfstream@@@Z ; ExperienceTable::LoadFromFileVampireRank
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFileVampireRank@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_level$ = -4						; size = 4
_num$ = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFileVampireRank@ExperienceTable@@QAEXAAVivfstream@@@Z PROC NEAR ; ExperienceTable::LoadFromFileVampireRank, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 180  : 	int num, level;
; 181  : 	file.read((char*)&num, 4);

  00006	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00009	33 db		 xor	 ebx, ebx
  0000b	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	74 0e		 je	 SHORT $L101873
  00013	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 08	 lea	 edx, DWORD PTR _num$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L101873:

; 182  : 
; 183  : 	// file에는 1 level부터 들어가있는걸로 가정하기 때문에...
; 184  : 	m_VampireRankExp.Init( num + 1 );

  00021	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00024	40		 inc	 eax
  00025	50		 push	 eax
  00026	8d 4f 30	 lea	 ecx, DWORD PTR [edi+48]
  00029	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z ; CTypeTable<ExpInfo>::Init

; 185  : 
; 186  : 	for (int i=0; i<num; i++)

  0002e	83 7d 08 00	 cmp	 DWORD PTR _num$[ebp], 0
  00032	7e 29		 jle	 SHORT $L100669
$L101886:

; 187  : 	{
; 188  : 		file.read((char*)&level, 4);

  00034	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00038	74 0e		 je	 SHORT $L101878
  0003a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003f	6a 04		 push	 4
  00041	8d 55 fc	 lea	 edx, DWORD PTR _level$[ebp]
  00044	52		 push	 edx
  00045	ff 50 10	 call	 DWORD PTR [eax+16]
$L101878:

; 189  : 		
; 190  : 		// level에 맞게 loading한다.
; 191  : 		m_VampireRankExp[level].LoadFromFile( file );		

  00048	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _level$[ebp]
  0004e	56		 push	 esi
  0004f	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00052	e8 00 00 00 00	 call	 ?LoadFromFile@ExpInfo@@QAEXAAVivfstream@@@Z ; ExpInfo::LoadFromFile
  00057	43		 inc	 ebx
  00058	3b 5d 08	 cmp	 ebx, DWORD PTR _num$[ebp]
  0005b	7c d7		 jl	 SHORT $L101886
$L100669:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 192  : 	}
; 193  : }

  00060	c9		 leave
  00061	c2 04 00	 ret	 4
?LoadFromFileVampireRank@ExperienceTable@@QAEXAAVivfstream@@@Z ENDP ; ExperienceTable::LoadFromFileVampireRank
_TEXT	ENDS
PUBLIC	?LoadFromFileOustersRank@ExperienceTable@@QAEXAAVivfstream@@@Z ; ExperienceTable::LoadFromFileOustersRank
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFileOustersRank@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_level$ = -4						; size = 4
_num$ = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFileOustersRank@ExperienceTable@@QAEXAAVivfstream@@@Z PROC NEAR ; ExperienceTable::LoadFromFileOustersRank, COMDAT
; _this$ = ecx

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 201  : 	int num, level;
; 202  : 	file.read((char*)&num, 4);

  00006	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00009	33 db		 xor	 ebx, ebx
  0000b	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	74 0e		 je	 SHORT $L101891
  00013	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 08	 lea	 edx, DWORD PTR _num$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L101891:

; 203  : 	
; 204  : 	// file에는 1 level부터 들어가있는걸로 가정하기 때문에...
; 205  : 	m_OustersRankExp.Init( num + 1 );

  00021	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00024	40		 inc	 eax
  00025	50		 push	 eax
  00026	8d 4f 38	 lea	 ecx, DWORD PTR [edi+56]
  00029	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z ; CTypeTable<ExpInfo>::Init

; 206  : 	
; 207  : 	for (int i=0; i<num; i++)

  0002e	83 7d 08 00	 cmp	 DWORD PTR _num$[ebp], 0
  00032	7e 29		 jle	 SHORT $L100681
$L101904:

; 208  : 	{
; 209  : 		file.read((char*)&level, 4);

  00034	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00038	74 0e		 je	 SHORT $L101896
  0003a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003f	6a 04		 push	 4
  00041	8d 55 fc	 lea	 edx, DWORD PTR _level$[ebp]
  00044	52		 push	 edx
  00045	ff 50 10	 call	 DWORD PTR [eax+16]
$L101896:

; 210  : 		
; 211  : 		// level에 맞게 loading한다.
; 212  : 		m_OustersRankExp[level].LoadFromFile( file );		

  00048	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _level$[ebp]
  0004e	56		 push	 esi
  0004f	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00052	e8 00 00 00 00	 call	 ?LoadFromFile@ExpInfo@@QAEXAAVivfstream@@@Z ; ExpInfo::LoadFromFile
  00057	43		 inc	 ebx
  00058	3b 5d 08	 cmp	 ebx, DWORD PTR _num$[ebp]
  0005b	7c d7		 jl	 SHORT $L101904
$L100681:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 213  : 	}
; 214  : }

  00060	c9		 leave
  00061	c2 04 00	 ret	 4
?LoadFromFileOustersRank@ExperienceTable@@QAEXAAVivfstream@@@Z ENDP ; ExperienceTable::LoadFromFileOustersRank
_TEXT	ENDS
PUBLIC	?LoadFromFilePetExp@ExperienceTable@@QAEXAAVivfstream@@@Z ; ExperienceTable::LoadFromFilePetExp
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFilePetExp@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_level$ = -4						; size = 4
_num$ = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFilePetExp@ExperienceTable@@QAEXAAVivfstream@@@Z PROC NEAR ; ExperienceTable::LoadFromFilePetExp, COMDAT
; _this$ = ecx

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 222  : 	int num, level;
; 223  : 	file.read((char*)&num, 4);

  00006	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00009	33 db		 xor	 ebx, ebx
  0000b	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	74 0e		 je	 SHORT $L101909
  00013	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 08	 lea	 edx, DWORD PTR _num$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L101909:

; 224  : 	
; 225  : 	// file에는 1 level부터 들어가있는걸로 가정하기 때문에...
; 226  : 	m_PetExp.Init( num + 1 );

  00021	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00024	40		 inc	 eax
  00025	50		 push	 eax
  00026	8d 4f 40	 lea	 ecx, DWORD PTR [edi+64]
  00029	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z ; CTypeTable<ExpInfo>::Init

; 227  : 	
; 228  : 	for (int i=0; i<num; i++)

  0002e	83 7d 08 00	 cmp	 DWORD PTR _num$[ebp], 0
  00032	7e 29		 jle	 SHORT $L100693
$L101922:

; 229  : 	{
; 230  : 		file.read((char*)&level, 4);

  00034	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00038	74 0e		 je	 SHORT $L101914
  0003a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003f	6a 04		 push	 4
  00041	8d 55 fc	 lea	 edx, DWORD PTR _level$[ebp]
  00044	52		 push	 edx
  00045	ff 50 10	 call	 DWORD PTR [eax+16]
$L101914:

; 231  : 		
; 232  : 		// level에 맞게 loading한다.
; 233  : 		m_PetExp[level].LoadFromFile( file );		

  00048	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _level$[ebp]
  0004e	56		 push	 esi
  0004f	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00052	e8 00 00 00 00	 call	 ?LoadFromFile@ExpInfo@@QAEXAAVivfstream@@@Z ; ExpInfo::LoadFromFile
  00057	43		 inc	 ebx
  00058	3b 5d 08	 cmp	 ebx, DWORD PTR _num$[ebp]
  0005b	7c d7		 jl	 SHORT $L101922
$L100693:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 234  : 	}
; 235  : }

  00060	c9		 leave
  00061	c2 04 00	 ret	 4
?LoadFromFilePetExp@ExperienceTable@@QAEXAAVivfstream@@@Z ENDP ; ExperienceTable::LoadFromFilePetExp
_TEXT	ENDS
PUBLIC	?LoadFromFileAdvanceMent@ExperienceTable@@QAEXAAVivfstream@@@Z ; ExperienceTable::LoadFromFileAdvanceMent
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFileAdvanceMent@ExperienceTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_level$ = -4						; size = 4
_num$ = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFileAdvanceMent@ExperienceTable@@QAEXAAVivfstream@@@Z PROC NEAR ; ExperienceTable::LoadFromFileAdvanceMent, COMDAT
; _this$ = ecx

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 240  : 	int num, level;
; 241  : 	file.read((char*)&num, 4);

  00007	8b 7d 08	 mov	 edi, DWORD PTR _file$[ebp]
  0000a	33 db		 xor	 ebx, ebx
  0000c	39 5f 04	 cmp	 DWORD PTR [edi+4], ebx
  0000f	8b f1		 mov	 esi, ecx
  00011	74 0e		 je	 SHORT $L101927
  00013	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 08	 lea	 edx, DWORD PTR _num$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L101927:

; 242  : 	
; 243  : 	// file에는 1 level부터 들어가있는걸로 가정하기 때문에...
; 244  : 	m_advanceSkillExp.Init( num + 1+150 );

  00021	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00024	05 97 00 00 00	 add	 eax, 151		; 00000097H
  00029	50		 push	 eax
  0002a	8d 4e 48	 lea	 ecx, DWORD PTR [esi+72]
  0002d	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VExpInfo@@@@QAEXH@Z ; CTypeTable<ExpInfo>::Init

; 245  : 	
; 246  : 	for (int i=0; i<num; i++)

  00032	83 7d 08 00	 cmp	 DWORD PTR _num$[ebp], 0
  00036	7e 29		 jle	 SHORT $L100705
$L101954:

; 247  : 	{
; 248  : 		file.read((char*)&level, 4);

  00038	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0003c	74 0e		 je	 SHORT $L101932
  0003e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00041	8b 01		 mov	 eax, DWORD PTR [ecx]
  00043	6a 04		 push	 4
  00045	8d 55 fc	 lea	 edx, DWORD PTR _level$[ebp]
  00048	52		 push	 edx
  00049	ff 50 10	 call	 DWORD PTR [eax+16]
$L101932:

; 249  : 		
; 250  : 		// level에 맞게 loading한다.
; 251  : 		m_advanceSkillExp[level].LoadFromFile( file );		

  0004c	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _level$[ebp]
  00052	57		 push	 edi
  00053	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00056	e8 00 00 00 00	 call	 ?LoadFromFile@ExpInfo@@QAEXAAVivfstream@@@Z ; ExpInfo::LoadFromFile
  0005b	43		 inc	 ebx
  0005c	3b 5d 08	 cmp	 ebx, DWORD PTR _num$[ebp]
  0005f	7c d7		 jl	 SHORT $L101954
$L100705:

; 252  : 	}
; 253  : 	for (int j = 1;j<151;j++)

  00061	33 c9		 xor	 ecx, ecx
  00063	41		 inc	 ecx
$L100708:

; 254  : 	{
; 255  : 		m_advanceSkillExp[level+j].AccumExp = m_advanceSkillExp[200].AccumExp;		

  00064	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00067	8b 55 fc	 mov	 edx, DWORD PTR _level$[ebp]
  0006a	8b b8 44 06 00
	00		 mov	 edi, DWORD PTR [eax+1604]
  00070	03 d1		 add	 edx, ecx
  00072	89 7c d0 04	 mov	 DWORD PTR [eax+edx*8+4], edi

; 256  : 		m_advanceSkillExp[level+j].GoalExp = m_advanceSkillExp[200].GoalExp;	

  00076	8b 55 fc	 mov	 edx, DWORD PTR _level$[ebp]
  00079	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  0007c	8b b8 40 06 00
	00		 mov	 edi, DWORD PTR [eax+1600]
  00082	03 d1		 add	 edx, ecx
  00084	41		 inc	 ecx
  00085	81 f9 97 00 00
	00		 cmp	 ecx, 151		; 00000097H
  0008b	89 3c d0	 mov	 DWORD PTR [eax+edx*8], edi
  0008e	7c d4		 jl	 SHORT $L100708
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx

; 257  : 	}
; 258  : }

  00093	c9		 leave
  00094	c2 04 00	 ret	 4
?LoadFromFileAdvanceMent@ExperienceTable@@QAEXAAVivfstream@@@Z ENDP ; ExperienceTable::LoadFromFileAdvanceMent
_TEXT	ENDS
END
