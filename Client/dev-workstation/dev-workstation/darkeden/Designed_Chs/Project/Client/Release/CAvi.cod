; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\CAvi.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_09LDHKDNLA@MPEGVideo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MEANNGNP@AVIVideo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??0CAVI@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OpenMPG@CAVI@@QAEHPAUHWND__@@PADHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OpenAVI@CAVI@@QAEHPAUHWND__@@PADHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Close@CAVI@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Play@CAVI@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@CAVI@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0CAVI@@QAE@XZ					; CAVI::CAVI
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\cavi.cpp
;	COMDAT ??0CAVI@@QAE@XZ
_TEXT	SEGMENT
??0CAVI@@QAE@XZ PROC NEAR				; CAVI::CAVI, COMDAT
; _this$ = ecx

; 5    : {

  00000	8b c1		 mov	 eax, ecx

; 6    : 	bEndFlag=0;

  00002	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0

; 7    : }

  00006	c3		 ret	 0
??0CAVI@@QAE@XZ ENDP					; CAVI::CAVI
_TEXT	ENDS
PUBLIC	?OpenMPG@CAVI@@QAEHPAUHWND__@@PADHH@Z		; CAVI::OpenMPG
PUBLIC	??_C@_09LDHKDNLA@MPEGVideo?$AA@			; `string'
EXTRN	__imp__GetClientRect@8:NEAR
EXTRN	__imp__mciSendCommandA@16:NEAR
;	COMDAT ??_C@_09LDHKDNLA@MPEGVideo?$AA@
CONST	SEGMENT
??_C@_09LDHKDNLA@MPEGVideo?$AA@ DB 'MPEGVideo', 00H	; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?OpenMPG@CAVI@@QAEHPAUHWND__@@PADHH@Z
_TEXT	SEGMENT
_MciDgvOpenParms$ = -80					; size = 28
_MciDgvRectParms$ = -52					; size = 20
_MciDgvWindowParms$ = -32				; size = 16
_Rect$ = -16						; size = 16
_hwnd$ = 8						; size = 4
_szName$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
?OpenMPG@CAVI@@QAEHPAUHWND__@@PADHH@Z PROC NEAR		; CAVI::OpenMPG, COMDAT
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H

; 12   : 	this->hwnd=hwnd;
; 13   : 
; 14   : 	MCI_DGV_OPEN_PARMS MciDgvOpenParms;
; 15   : 	//MciDgvOpenParms.lpstrDeviceType="AVIVideo";
; 16   : 	MciDgvOpenParms.lpstrDeviceType="MPEGVideo";
; 17   : 	MciDgvOpenParms.lpstrElementName=szName;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _szName$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR _hwnd$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 18   : 
; 19   : 	if(mciSendCommand(NULL, MCI_OPEN,
; 20   : 					  MCI_OPEN_ELEMENT | 
; 21   : 					  MCI_OPEN_TYPE | 
; 22   : 					  MCI_DGV_OPEN_WS,
; 23   : 					  (DWORD)&MciDgvOpenParms))

  0000f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__mciSendCommandA@16
  00015	89 45 bc	 mov	 DWORD PTR _MciDgvOpenParms$[ebp+12], eax
  00018	8d 45 b0	 lea	 eax, DWORD PTR _MciDgvOpenParms$[ebp]
  0001b	50		 push	 eax
  0001c	68 00 22 01 00	 push	 74240			; 00012200H
  00021	68 03 08 00 00	 push	 2051			; 00000803H
  00026	8b f1		 mov	 esi, ecx
  00028	6a 00		 push	 0
  0002a	89 1e		 mov	 DWORD PTR [esi], ebx
  0002c	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _MciDgvOpenParms$[ebp+8], OFFSET FLAT:??_C@_09LDHKDNLA@MPEGVideo?$AA@
  00033	ff d7		 call	 edi
  00035	85 c0		 test	 eax, eax
  00037	74 08		 je	 SHORT $L99416

; 24   : 	{
; 25   : 		dwID=NULL;

  00039	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 26   : 		return FALSE;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 64		 jmp	 SHORT $L99412
$L99416:

; 27   : 	}
; 28   : 	dwID = MciDgvOpenParms.wDeviceID;

  00041	8b 45 b4	 mov	 eax, DWORD PTR _MciDgvOpenParms$[ebp+4]
  00044	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 29   : 
; 30   : 	// 위치 설정
; 31   : 	MCI_DGV_RECT_PARMS MciDgvRectParms;
; 32   : 	// 중간으로
; 33   : 	RECT Rect;
; 34   : 	GetClientRect(hwnd, &Rect);

  00047	8d 45 f0	 lea	 eax, DWORD PTR _Rect$[ebp]
  0004a	50		 push	 eax
  0004b	53		 push	 ebx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 35   : 	int x = (Rect.right - w) / 2;

  00052	8b 4d 10	 mov	 ecx, DWORD PTR _w$[ebp]
  00055	8b 45 f8	 mov	 eax, DWORD PTR _Rect$[ebp+8]
  00058	2b c1		 sub	 eax, ecx
  0005a	99		 cdq
  0005b	2b c2		 sub	 eax, edx
  0005d	d1 f8		 sar	 eax, 1

; 36   : 	int y = (Rect.bottom - h) / 2;
; 37   : 
; 38   : 	MciDgvRectParms.rc.left		= x;

  0005f	89 45 d0	 mov	 DWORD PTR _MciDgvRectParms$[ebp+4], eax
  00062	8b 45 fc	 mov	 eax, DWORD PTR _Rect$[ebp+12]
  00065	2b 45 14	 sub	 eax, DWORD PTR _h$[ebp]

; 39   : 	MciDgvRectParms.rc.top		= y;
; 40   : 	MciDgvRectParms.rc.right	= w;

  00068	89 4d d8	 mov	 DWORD PTR _MciDgvRectParms$[ebp+12], ecx
  0006b	99		 cdq
  0006c	2b c2		 sub	 eax, edx
  0006e	d1 f8		 sar	 eax, 1
  00070	89 45 d4	 mov	 DWORD PTR _MciDgvRectParms$[ebp+8], eax

; 41   : 	MciDgvRectParms.rc.bottom	= h;

  00073	8b 45 14	 mov	 eax, DWORD PTR _h$[ebp]
  00076	89 45 dc	 mov	 DWORD PTR _MciDgvRectParms$[ebp+16], eax

; 42   : 
; 43   : 	mciSendCommand(dwID, MCI_PUT,
; 44   : 				   MCI_ANIM_PUT_DESTINATION | MCI_DGV_RECT,
; 45   : 				   (DWORD)&MciDgvRectParms);

  00079	8d 45 cc	 lea	 eax, DWORD PTR _MciDgvRectParms$[ebp]
  0007c	50		 push	 eax
  0007d	68 00 00 05 00	 push	 327680			; 00050000H
  00082	68 42 08 00 00	 push	 2114			; 00000842H
  00087	ff 76 04	 push	 DWORD PTR [esi+4]
  0008a	ff d7		 call	 edi

; 46   : 
; 47   : 	MCI_DGV_WINDOW_PARMS MciDgvWindowParms;
; 48   : 	MciDgvWindowParms.hWnd = hwnd;
; 49   : 
; 50   : 	mciSendCommand(dwID, MCI_WINDOW, MCI_ANIM_WINDOW_HWND,
; 51   : 				   (DWORD)&MciDgvWindowParms);

  0008c	8d 45 e0	 lea	 eax, DWORD PTR _MciDgvWindowParms$[ebp]
  0008f	50		 push	 eax
  00090	68 00 00 01 00	 push	 65536			; 00010000H
  00095	68 41 08 00 00	 push	 2113			; 00000841H
  0009a	ff 76 04	 push	 DWORD PTR [esi+4]
  0009d	89 5d e4	 mov	 DWORD PTR _MciDgvWindowParms$[ebp+4], ebx
  000a0	ff d7		 call	 edi

; 52   : 
; 53   : 	return TRUE;

  000a2	33 c0		 xor	 eax, eax
  000a4	40		 inc	 eax
$L99412:
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 54   : }

  000a8	c9		 leave
  000a9	c2 10 00	 ret	 16			; 00000010H
?OpenMPG@CAVI@@QAEHPAUHWND__@@PADHH@Z ENDP		; CAVI::OpenMPG
_TEXT	ENDS
PUBLIC	?OpenAVI@CAVI@@QAEHPAUHWND__@@PADHH@Z		; CAVI::OpenAVI
PUBLIC	??_C@_08MEANNGNP@AVIVideo?$AA@			; `string'
;	COMDAT ??_C@_08MEANNGNP@AVIVideo?$AA@
CONST	SEGMENT
??_C@_08MEANNGNP@AVIVideo?$AA@ DB 'AVIVideo', 00H	; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?OpenAVI@CAVI@@QAEHPAUHWND__@@PADHH@Z
_TEXT	SEGMENT
_MciDgvOpenParms$ = -80					; size = 28
_MciDgvRectParms$ = -52					; size = 20
_MciDgvWindowParms$ = -32				; size = 16
_Rect$ = -16						; size = 16
_hwnd$ = 8						; size = 4
_szName$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
?OpenAVI@CAVI@@QAEHPAUHWND__@@PADHH@Z PROC NEAR		; CAVI::OpenAVI, COMDAT
; _this$ = ecx

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H

; 58   : 	this->hwnd=hwnd;
; 59   : 
; 60   : 	MCI_DGV_OPEN_PARMS MciDgvOpenParms;
; 61   : 	MciDgvOpenParms.lpstrDeviceType="AVIVideo";
; 62   : 	//MciDgvOpenParms.lpstrDeviceType="MPEGVideo";
; 63   : 	MciDgvOpenParms.lpstrElementName=szName;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _szName$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR _hwnd$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 64   : 
; 65   : 	if(mciSendCommand(NULL, MCI_OPEN,
; 66   : 					  MCI_OPEN_ELEMENT | 
; 67   : 					  MCI_OPEN_TYPE | 
; 68   : 					  MCI_DGV_OPEN_WS,
; 69   : 					  (DWORD)&MciDgvOpenParms))

  0000f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__mciSendCommandA@16
  00015	89 45 bc	 mov	 DWORD PTR _MciDgvOpenParms$[ebp+12], eax
  00018	8d 45 b0	 lea	 eax, DWORD PTR _MciDgvOpenParms$[ebp]
  0001b	50		 push	 eax
  0001c	68 00 22 01 00	 push	 74240			; 00012200H
  00021	68 03 08 00 00	 push	 2051			; 00000803H
  00026	8b f1		 mov	 esi, ecx
  00028	6a 00		 push	 0
  0002a	89 1e		 mov	 DWORD PTR [esi], ebx
  0002c	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _MciDgvOpenParms$[ebp+8], OFFSET FLAT:??_C@_08MEANNGNP@AVIVideo?$AA@
  00033	ff d7		 call	 edi
  00035	85 c0		 test	 eax, eax
  00037	74 08		 je	 SHORT $L99434

; 70   : 	{
; 71   : 		dwID=NULL;

  00039	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 72   : 		return FALSE;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 64		 jmp	 SHORT $L99430
$L99434:

; 73   : 	}
; 74   : 	dwID = MciDgvOpenParms.wDeviceID;

  00041	8b 45 b4	 mov	 eax, DWORD PTR _MciDgvOpenParms$[ebp+4]
  00044	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 75   : 
; 76   : 	// 위치 설정
; 77   : 	MCI_DGV_RECT_PARMS MciDgvRectParms;
; 78   : 	// 중간으로
; 79   : 	RECT Rect;
; 80   : 	GetClientRect(hwnd, &Rect);

  00047	8d 45 f0	 lea	 eax, DWORD PTR _Rect$[ebp]
  0004a	50		 push	 eax
  0004b	53		 push	 ebx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 81   : 	int x = (Rect.right - w) / 2;

  00052	8b 4d 10	 mov	 ecx, DWORD PTR _w$[ebp]
  00055	8b 45 f8	 mov	 eax, DWORD PTR _Rect$[ebp+8]
  00058	2b c1		 sub	 eax, ecx
  0005a	99		 cdq
  0005b	2b c2		 sub	 eax, edx
  0005d	d1 f8		 sar	 eax, 1

; 82   : 	int y = (Rect.bottom - h) / 2;
; 83   : 
; 84   : 	MciDgvRectParms.rc.left		= x;

  0005f	89 45 d0	 mov	 DWORD PTR _MciDgvRectParms$[ebp+4], eax
  00062	8b 45 fc	 mov	 eax, DWORD PTR _Rect$[ebp+12]
  00065	2b 45 14	 sub	 eax, DWORD PTR _h$[ebp]

; 85   : 	MciDgvRectParms.rc.top		= y;
; 86   : 	MciDgvRectParms.rc.right	= w;

  00068	89 4d d8	 mov	 DWORD PTR _MciDgvRectParms$[ebp+12], ecx
  0006b	99		 cdq
  0006c	2b c2		 sub	 eax, edx
  0006e	d1 f8		 sar	 eax, 1
  00070	89 45 d4	 mov	 DWORD PTR _MciDgvRectParms$[ebp+8], eax

; 87   : 	MciDgvRectParms.rc.bottom	= h;

  00073	8b 45 14	 mov	 eax, DWORD PTR _h$[ebp]
  00076	89 45 dc	 mov	 DWORD PTR _MciDgvRectParms$[ebp+16], eax

; 88   : 
; 89   : 	mciSendCommand(dwID, MCI_PUT,
; 90   : 				   MCI_ANIM_PUT_DESTINATION | MCI_DGV_RECT,
; 91   : 				   (DWORD)&MciDgvRectParms);

  00079	8d 45 cc	 lea	 eax, DWORD PTR _MciDgvRectParms$[ebp]
  0007c	50		 push	 eax
  0007d	68 00 00 05 00	 push	 327680			; 00050000H
  00082	68 42 08 00 00	 push	 2114			; 00000842H
  00087	ff 76 04	 push	 DWORD PTR [esi+4]
  0008a	ff d7		 call	 edi

; 92   : 
; 93   : 	MCI_DGV_WINDOW_PARMS MciDgvWindowParms;
; 94   : 	MciDgvWindowParms.hWnd = hwnd;
; 95   : 
; 96   : 	mciSendCommand(dwID, MCI_WINDOW, MCI_ANIM_WINDOW_HWND,
; 97   : 				   (DWORD)&MciDgvWindowParms);

  0008c	8d 45 e0	 lea	 eax, DWORD PTR _MciDgvWindowParms$[ebp]
  0008f	50		 push	 eax
  00090	68 00 00 01 00	 push	 65536			; 00010000H
  00095	68 41 08 00 00	 push	 2113			; 00000841H
  0009a	ff 76 04	 push	 DWORD PTR [esi+4]
  0009d	89 5d e4	 mov	 DWORD PTR _MciDgvWindowParms$[ebp+4], ebx
  000a0	ff d7		 call	 edi

; 98   : 
; 99   : 	return TRUE;

  000a2	33 c0		 xor	 eax, eax
  000a4	40		 inc	 eax
$L99430:
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 100  : }

  000a8	c9		 leave
  000a9	c2 10 00	 ret	 16			; 00000010H
?OpenAVI@CAVI@@QAEHPAUHWND__@@PADHH@Z ENDP		; CAVI::OpenAVI
_TEXT	ENDS
PUBLIC	?Close@CAVI@@QAEXXZ				; CAVI::Close
; Function compile flags: /Ogsy
;	COMDAT ?Close@CAVI@@QAEXXZ
_TEXT	SEGMENT
_MciPlayParms$99446 = -12				; size = 12
?Close@CAVI@@QAEXXZ PROC NEAR				; CAVI::Close, COMDAT
; _this$ = ecx

; 103  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 104  : 	if(dwID!=NULL)

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	85 c0		 test	 eax, eax
  0000b	74 29		 je	 SHORT $L99445
  0000d	57		 push	 edi

; 105  : 	{
; 106  : 		MCI_PLAY_PARMS MciPlayParms;
; 107  : 		mciSendCommand(dwID, MCI_STOP, MCI_NOTIFY, (DWORD)&MciPlayParms);

  0000e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__mciSendCommandA@16
  00014	8d 4c 24 08	 lea	 ecx, DWORD PTR _MciPlayParms$99446[esp+20]
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	68 08 08 00 00	 push	 2056			; 00000808H
  00020	50		 push	 eax
  00021	ff d7		 call	 edi

; 108  : 		mciSendCommand(dwID, MCI_CLOSE, 0, NULL);

  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	68 04 08 00 00	 push	 2052			; 00000804H
  0002c	ff 76 04	 push	 DWORD PTR [esi+4]
  0002f	ff d7		 call	 edi

; 109  : 		dwID=NULL;

  00031	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00035	5f		 pop	 edi
$L99445:
  00036	5e		 pop	 esi

; 110  : 	}
; 111  : }

  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	c3		 ret	 0
?Close@CAVI@@QAEXXZ ENDP				; CAVI::Close
_TEXT	ENDS
PUBLIC	?Play@CAVI@@QAEHXZ				; CAVI::Play
; Function compile flags: /Ogsy
;	COMDAT ?Play@CAVI@@QAEHXZ
_TEXT	SEGMENT
_MciPlayParms$ = -12					; size = 12
?Play@CAVI@@QAEHXZ PROC NEAR				; CAVI::Play, COMDAT
; _this$ = ecx

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 115  : 	if(dwID==NULL) return FALSE;

  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	85 c0		 test	 eax, eax
  0000b	75 02		 jne	 SHORT $L99451

; 123  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
$L99451:

; 116  : 
; 117  : 	MCI_PLAY_PARMS MciPlayParms;
; 118  : 	MciPlayParms.dwCallback=(DWORD)hwnd;

  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	89 4d f4	 mov	 DWORD PTR _MciPlayParms$[ebp], ecx

; 119  : 	mciSendCommand(dwID, MCI_PLAY, MCI_NOTIFY, 
; 120  : 				   (DWORD)&MciPlayParms);

  00014	8d 4d f4	 lea	 ecx, DWORD PTR _MciPlayParms$[ebp]
  00017	51		 push	 ecx
  00018	6a 01		 push	 1
  0001a	68 06 08 00 00	 push	 2054			; 00000806H
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16

; 121  : 
; 122  : 	return TRUE;

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax

; 123  : }

  00029	c9		 leave
  0002a	c3		 ret	 0
?Play@CAVI@@QAEHXZ ENDP					; CAVI::Play
_TEXT	ENDS
PUBLIC	?Stop@CAVI@@QAEXXZ				; CAVI::Stop
; Function compile flags: /Ogsy
;	COMDAT ?Stop@CAVI@@QAEXXZ
_TEXT	SEGMENT
_MciPlayParms$99459 = -12				; size = 12
?Stop@CAVI@@QAEXXZ PROC NEAR				; CAVI::Stop, COMDAT
; _this$ = ecx

; 127  : 	if(dwID!=NULL)

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	85 c0		 test	 eax, eax
  00008	74 12		 je	 SHORT $L99458

; 128  : 	{
; 129  : 		MCI_PLAY_PARMS MciPlayParms;
; 130  : 		mciSendCommand(dwID, MCI_STOP, MCI_WAIT,(DWORD)&MciPlayParms);

  0000a	8d 0c 24	 lea	 ecx, DWORD PTR _MciPlayParms$99459[esp+12]
  0000d	51		 push	 ecx
  0000e	6a 02		 push	 2
  00010	68 08 08 00 00	 push	 2056			; 00000808H
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
$L99458:

; 131  : 	}
; 132  : }

  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	c3		 ret	 0
?Stop@CAVI@@QAEXXZ ENDP					; CAVI::Stop
_TEXT	ENDS
END
