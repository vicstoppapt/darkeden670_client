#include "Client_PCH.h"
#include "crypt.h"

WORD CryptTable[] = {
    0x1d23, 0x261b, 0x1b1e, 0x2028, 0x3e2f, 0x4136, 0x4752, 0x4938, 0x293e, 
    0x2f3a, 0x2e1e, 0x2523, 0x2833, 0x3e33, 0x3734, 0x3a42, 0x4c41, 0x2e44, 
    0x3238, 0x3125, 0x282b, 0x3033, 0x3d2f, 0x2b39, 0x3539, 0x3527, 0x2931, 
    0x3337, 0x3224, 0x1c2c, 0x242a, 0x2517, 0x141f, 0x1a20, 0x3326, 0x242b, 
    0x2a30, 0x281c, 0x1222, 0x181e, 0x2618, 0x1c20, 0x2228, 0x2317, 0x0d1d, 
    0x1319, 0x0d01, 0x0907, 0x1219, 0x2818, 0x2521, 0x2e35, 0x5847, 0x2b4f, 
    0x333c, 0x3e2d, 0x2e35, 0x3841, 0x4835, 0x2c3f, 0x363f, 0x412c, 0x2e38, 
    0x3a43, 0x4530, 0x633c, 0x6d79, 0x7e66, 0x4e72, 0x5a66, 0x533d, 0x3e47, 
    0x4652, 0x3827, 0x222d, 0x2732, 0x3b2b, 0x2130, 0x2631, 0x2818, 0x201d, 
    0x2530, 0x3021, 0x1e28, 0x252d, 0x2c1d, 0x1924, 0x2229, 0x3323, 0x402c, 
    0x4950, 0x3827, 0x002f, 0x0007, 0x4735, 0x4940, 0x585d, 0x6c57, 0x2f69, 
    0x3e43, 0x543e, 0x504f, 0x5f64, 0x614d, 0x4a5c, 0x595e, 0x4d38, 0x3345, 
    0x4247, 0x4e3a, 0x2d49, 0x3c41, 0x1e0a, 0x0019, 0x1013, 0x230e, 0x4220, 
    0x5457, 0x3d29, 0x1938, 0x232c, 0x2a17, 0x6121, 0x6b74, 0x5f4d, 0x4758, 
    0x575a, 0x4a37, 0x2e47, 0x3f40, 0x3a28, 0x3b39, 0x494c, 0x3122, 0x4e2d, 
    0x5159, 0x7068, 0x6365, 0x5968, 0x7a78, 0x4067, 0x2b3f, 0x353a, 0x3d20, 
    0x2034, 0x3947, 0x4326, 0x2036, 0x3643, 0x3e20, 0x1c34, 0x3640, 0x3e1e, 
    0x1a35, 0x363f, 0x401b, 0x1c37, 0x333c, 0x3f18, 0x1934, 0x343f, 0x3e19, 
    0x1a32, 0x3642, 0x441e, 0x2137, 0x313d, 0x4219, 0x1c37, 0x3740, 0x3e1c, 
    0x1a35, 0x3841, 0x3d1d, 0x1934, 0x343d, 0x3a19, 0x1631, 0x323b, 0x3c17, 
    0x1a32, 0x303a, 0x3718, 0x182f, 0x3038, 0x3b19, 0x1c33, 0x343c, 0x3b1d, 
    0x1e32, 0x323a, 0x3c1b, 0x1d34, 0x333a, 0x391a, 0x1932, 0x343b, 0x3c1b, 
    0x1c35, 0x343b, 0x3b1b, 0x1b34, 0x353c, 0x3c1c, 0x1c35, 0x363d, 0x3a1d, 
    0x1a33, 0x343b, 0x3d1b, 0x1d36, 0x3138, 0x3f18, 0x1f38, 0x353c, 0x391c, 
    0x1c33, 0x353b, 0x3b1e, 0x1d36, 0x363b, 0x3c1d, 0x1e37, 0x393d, 0x3e1d, 
    0x1e3a, 0x393d, 0x3f1d, 0x1d38, 0x383f, 0x3f1d, 0x1d38, 0x383f, 0x3e1d, 
    0x1e37, 0x383f, 0x401f, 0x2138, 0x3840, 0x3f21, 0x2037, 0x3c44, 0x4125, 
    0x2239, 0x373f, 0x4320, 0x243b, 0x3941, 0x3e22, 0x1f36, 0x3b43, 0x4024, 
    0x2138, 0x373f, 0x4020, 0x2138, 0x3a42, 0x4223, 0x233a, 0x3a41, 0x4021, 
    0x2039, 0x3b42, 0x4122, 0x233c, 0x3a3f, 0x3721, 0x1932, 0x3d42, 0x4224, 
    0x243d, 0x3b40, 0x4222, 0x243d, 0x3d42, 0x4024, 0x223b, 0x3c41, 0x4023, 
    0x223b, 0x393e, 0x3f20, 0x213a, 0x3b41, 0x4224, 0x253c, 0x3b41, 0x3e24, 
    0x213a, 0x3a3e, 0x4021, 0x233c, 0x3d41, 0x4024, 0x233c, 0x3b3f, 0x3f22, 
    0x213a, 0x3a3e, 0x3d21, 0x1f38, 0x3a3e, 0x4021, 0x223b, 0x3b3f, 0x3d22, 
    0x2039, 0x3a3e, 0x3f22, 0x233b, 0x3339, 0x401c, 0x2039, 0x383f, 0x3f1f, 
    0x1f38, 0x3940, 0x4020, 0x2039, 0x383f, 0x401f, 0x2039, 0x3a41, 0x4321, 
    0x233c, 0x3b42, 0x4122, 0x213a, 0x3940, 0x3f20, 0x1f38, 0x383f, 0x411f, 
    0x213a, 0x3b42, 0x4022, 0x2039, 0x3940, 0x4020, 0x2138, 0x3a41, 0x4121, 
    0x2239, 0x3a41, 0x4021, 0x2138, 0x3940, 0x3f20, 0x2037, 0x3940, 0x3e20, 
    0x1e37, 0x383f, 0x401f, 0x2039, 0x383f, 0x401f, 0x2039, 0x383f, 0x3f1f, 
    0x213a, 0x3a3e, 0x3e21, 0x2138, 0x363a, 0x391d, 0x1c33, 0x373c, 0x3f1e, 
    0x2239, 0x383d, 0x421f, 0x243d, 0x393e, 0x3b20, 0x1d36, 0x373c, 0x3f1e, 
    0x1f38, 0x383f, 0x401f, 0x2039, 0x3a41, 0x4121, 0x2239, 0x363f, 0x3f22, 
    0x2037, 0x3840, 0x4121, 0x2239, 0x3a42, 0x4123, 0x213a, 0x373e, 0x3f1e, 
    0x1f38, 0x373e, 0x411e, 0x1f3a, 0x383f, 0x401d, 0x1e39, 0x363d, 0x401b, 
    0x1e39, 0x383f, 0x3d1d, 0x1d39, 0x393d, 0x3e1d, 0x1c37, 0x373d, 0x3e1a, 
    0x1c37, 0x3a40, 0x411d, 0x1d38, 0x363f, 0x481b, 0x263e, 0x3943, 0x4221, 
    0x2137, 0x3944, 0x4023, 0x2138, 0x373f, 0x3f20, 0x2239, 0x383f, 0x431f, 
    0x2139, 0x3b45, 0x4023, 0x1e36, 0x3943, 0x4221, 0x2038, 0x343e, 0x421c, 
    0x2038, 0x3640, 0x431e, 0x2139, 0x3842, 0x4220, 0x1e39, 0x3a43, 0x421f, 
    0x1d3a, 0x3a42, 0x431d, 0x1d3b, 0x3c44, 0x421e, 0x1c3a, 0x3840, 0x411a, 
    0x1b39, 0x3c44, 0x431e, 0x1f3e, 0x3d43, 0x4220, 0x1f3c, 0x3c43, 0x4721, 
    0x233e, 0x3c43, 0x4421, 0x203b, 0x3d46, 0x4722, 0x233e, 0x3e47, 0x4523, 
    0x213c, 0x3b43, 0x471e, 0x223f, 0x3f47, 0x4621, 0x203e, 0x3e46, 0x4820, 
    0x2240, 0x3e46, 0x4520, 0x1f3d, 0x3f47, 0x4521, 0x1f3d, 0x3e46, 0x4520, 
    0x1f3d, 0x3b43, 0x451d, 0x1f3d, 0x4149, 0x4923, 0x2341, 0x3f47, 0x4821, 
    0x213d, 0x3a45, 0x441e, 0x1d39, 0x3a45, 0x451e, 0x1e3a, 0x3843, 0x441c, 
    0x1d39, 0x3c47, 0x4820, 0x213d, 0x3d48, 0x4a21, 0x233f, 0x3a45, 0x431e, 
    0x1c38, 0x3a45, 0x441e, 0x1e39, 0x3944, 0x471d, 0x1f40, 0x3d43, 0x421a, 
    0x193c, 0x3e44, 0x4419, 0x1b3e, 0x3c42, 0x4319, 0x1a3d, 0x4046, 0x441d, 
    0x1b3e, 0x3c42, 0x3f19, 0x1639, 0x393f, 0x4216, 0x1a3b, 0x3d44, 0x441c, 
    0x1a3b, 0x3740, 0x4616, 0x1c3d, 0x3841, 0x4117, 0x1738, 0x3841, 0x3f17, 
    0x1536, 0x3841, 0x4417, 0x1c3a, 0x3842, 0x401a, 0x1836, 0x3842, 0x421a, 
    0x1a38, 0x343e, 0x3c16, 0x1233, 0x353e, 0x4114, 0x1638, 0x3942, 0x3e18, 
    0x1836, 0x363e, 0x3f18, 0x1735, 0x333e, 0x3e17, 0x1733, 0x3742, 0x421b, 
    0x1b37, 0x333e, 0x4317, 0x1c38, 0x333e, 0x3d17, 0x1632, 0x323d, 0x3f16, 
    0x1834, 0x3540, 0x3b19, 0x1633, 0x333b, 0x3e16, 0x1936, 0x353d, 0x3d18, 
    0x1835, 0x353d, 0x3b18, 0x1732, 0x313a, 0x3c16, 0x1833, 0x363f, 0x3c1b, 
    0x1631, 0x333e, 0x3e18, 0x1833, 0x313c, 0x3a16, 0x142f, 0x333e, 0x4218, 
    0x1c37, 0x3540, 0x3e19, 0x1733, 0x323c, 0x3b14, 0x1331, 0x333d, 0x3d15, 
    0x1334, 0x323b, 0x3b11, 0x1132, 0x343d, 0x3d13, 0x1334, 0x333c, 0x3f12, 
    0x1735, 0x333d, 0x4015, 0x1935, 0x313c, 0x3c15, 0x1531, 0x2f3a, 0x3813, 
    0x1230, 0x3038, 0x3912, 0x1331, 0x323a, 0x3a14, 0x1532, 0x3139, 0x3a14, 
    0x132f, 0x303b, 0x3a14, 0x132f, 0x2f37, 0x3612, 0x0f2b, 0x3038, 0x3413, 
    0x0e29, 0x333e, 0x3918, 0x132e, 0x2b36, 0x3910, 0x132e, 0x2d38, 0x3912, 
    0x132e, 0x2f3a, 0x3a14, 0x142f, 0x2d38, 0x3812, 0x112d, 0x2d38, 0x3611, 
    0x0f2b, 0x323d, 0x3916, 0x122e, 0x313c, 0x3515, 0x0e2a, 0x2d38, 0x3511, 
    0x0e2a, 0x2833, 0x350c, 0x102d, 0x2d35, 0x3510, 0x102d, 0x2f37, 0x3a12, 
    0x132f, 0x2e39, 0x3512, 0x0e2a, 0x2833, 0x330c, 0x0c28, 0x2833, 0x330c, 
    0x0c28, 0x2a35, 0x350e, 0x0e2a, 0x2732, 0x3009, 0x0824, 0x2632, 0x340a, 
    0x0c28, 0x2833, 0x320c, 0x0b27, 0x242f, 0x2f08, 0x0824, 0x2631, 0x320a, 
    0x0c27, 0x2631, 0x300b, 0x0a25, 0x2833, 0x2a0d, 0x0621, 0x252e, 0x280a, 
    0x041f, 0x252e, 0x2d0a, 0x0924, 0x242d, 0x2c09, 0x0823, 0x222b, 0x2b07, 
    0x0722, 0x232c, 0x2d08, 0x0924, 0x252e, 0x2a0a, 0x0a23, 0x2128, 0x2a06, 
    0x0823, 0x2027, 0x2905, 0x0922, 0x252c, 0x280c, 0x0a23, 0x1f24, 0x2306, 
    0x051e, 0x2025, 0x2a07, 0x0b22, 0x1e26, 0x2407, 0x071b, 0x1d25, 0x2506, 
    0x081c, 0x1b24, 0x0007, 0x3022, 0x232c, 0x292c, 0x2d24, 0x182a, 0x2023, 
    0x2418, 0x1f1e, 0x252b, 0x4b3e, 0x4a43, 0x4f5a, 0x3d2d, 0x1732, 0x1b28, 
    0x2918, 0x211c, 0x2532, 0x3827, 0x2d2b, 0x323d, 0x4131, 0x1d36, 0x242c, 
    0x3526, 0x2c2d, 0x3238, 0x3a2c, 0x3c36, 0x4749, 0x493b, 0x2947, 0x373a, 
    0x3824, 0x1b33, 0x262d, 0x2e1e, 0x1d27, 0x242c, 0x4d3f, 0x3942, 0x3c44, 
    0x2316, 0x121b, 0x1921, 0x1908, 0x1c10, 0x242a, 0x2a1c, 0x1524, 0x1b1e, 
    0x372b, 0x1b31, 0x242b, 0x3e2b, 0x2135, 0x2932, 0x1302, 0x0008, 0x0611, 
    0x2c1b, 0x1421, 0x1a25, 0x3f2e, 0x3534, 0x3b46, 0x5541, 0x4549, 0x4f58, 
    0x4530, 0x3d3c, 0x4952, 0x4530, 0x613c, 0x6f79, 0x826b, 0x587a, 0x656d, 
    0x4937, 0x3142, 0x3a41, 0x3827, 0x292f, 0x3038, 0x2718, 0x131f, 0x1a22, 
    0x2b1d, 0x2325, 0x2e32, 0x3223, 0x202e, 0x2d31, 0x3524, 0x3231, 0x4146, 
    0x2b16, 0x2523, 0x313a, 0x6651, 0x415e, 0x5055, 0x4c38, 0x0647, 0x1317, 
    0x4b37, 0x3246, 0x3f43, 0x4130, 0x2f3d, 0x3c40, 0x6d5c, 0x4969, 0x575a, 
    0x5e4b, 0x605b, 0x7073, 0x7b66, 0x5278, 0x6567, 0x240e, 0x0022, 0x1214, 
    0x462f, 0x2642, 0x333b, 0x4735, 0x5740, 0x6468, 0x6857, 0x4165, 0x4f52, 
    0x3f2f, 0x3c3e, 0x4b4c, 0x3e30, 0x323c, 0x3d41, 0x6051, 0x6d58, 0x6b77, 
    0x736b, 0x6462, 0x5167, 0x504f, 0x3736, 0x1735, 0x353b, 0x3f18, 0x1e34, 
    0x343f, 0x3e20, 0x1d33, 0x3742, 0x4621, 0x243c, 0x3842, 0x4020, 0x1c37, 
    0x4049, 0x4025, 0x1c37, 0x3841, 0x411d, 0x1d38, 0x353e, 0x3e1a, 0x1a35, 
    0x3740, 0x401c, 0x1e36, 0x343e, 0x3d1c, 0x1934, 0x363f, 0x401b, 0x1c37, 
    0x363f, 0x3e1b, 0x1a35, 0x363f, 0x3f1b, 0x1d35, 0x333d, 0x3d1b, 0x1b33, 
    0x343e, 0x3f1c, 0x1e34, 0x2f3a, 0x3d19, 0x1c32, 0x343f, 0x3d1e, 0x2034, 
    0x2f37, 0x3d18, 0x1c32, 0x353f, 0x391d, 0x172f, 0x343e, 0x3d1c, 0x1b33, 
    0x2e38, 0x3f16, 0x1d35, 0x333d, 0x391b, 0x1932, 0x3239, 0x3e19, 0x1e37, 
    0x3239, 0x3c19, 0x1f36, 0x353b, 0x391e, 0x1c33, 0x373d, 0x3e20, 0x1f36, 
    0x3941, 0x3c22, 0x1d34, 0x3940, 0x3f20, 0x1f38, 0x333a, 0x3e1a, 0x1e37, 
    0x353c, 0x3d1c, 0x1d36, 0x363d, 0x3e1d, 0x1e37, 0x3a41, 0x4121, 0x2239, 
    0x373f, 0x3e20, 0x1f36, 0x373f, 0x3e20, 0x2039, 0x3b40, 0x4022, 0x223b, 
    0x393e, 0x3f20, 0x2239, 0x393f, 0x3f22, 0x2239, 0x3a40, 0x3f23, 0x213a, 
    0x3b40, 0x4122, 0x213a, 0x3c43, 0x4223, 0x223b, 0x3f46, 0x4424, 0x223d, 
    0x3d44, 0x3f22, 0x213a, 0x4044, 0x4228, 0x253e, 0x4145, 0x4228, 0x243d, 
    0x3b40, 0x4222, 0x223b, 0x3b42, 0x4122, 0x213a, 0x3d44, 0x4124, 0x243b, 
    0x3a40, 0x3d23, 0x2037, 0x383f, 0x3e24, 0x2337, 0x363d, 0x4122, 0x243b, 
    0x3b41, 0x3d24, 0x2037, 0x3b41, 0x4324, 0x253e, 0x3e43, 0x4025, 0x1e39, 
    0x3f43, 0x4423, 0x243d, 0x393e, 0x4220, 0x233a, 0x3c42, 0x3f25, 0x2239, 
    0x373e, 0x4023, 0x2539, 0x3940, 0x4025, 0x2138, 0x343c, 0x401d, 0x2138, 
    0x3941, 0x4322, 0x243b, 0x3a42, 0x4323, 0x233c, 0x373e, 0x441e, 0x243d, 
    0x3a41, 0x4221, 0x233a, 0x363e, 0x401f, 0x2138, 0x3d45, 0x4226, 0x233a, 
    0x3a42, 0x4123, 0x2239, 0x3941, 0x4122, 0x2438, 0x3941, 0x4022, 0x2337, 
    0x373f, 0x4120, 0x2438, 0x3b43, 0x4224, 0x2539, 0x3e46, 0x4227, 0x233a, 
    0x3f47, 0x4028, 0x2138, 0x3941, 0x3f22, 0x1e34, 0x3b43, 0x4024, 0x2138, 
    0x373d, 0x3f20, 0x2236, 0x383e, 0x3e21, 0x2135, 0x373f, 0x4120, 0x2438, 
    0x3941, 0x4222, 0x233a, 0x3840, 0x3e21, 0x1f36, 0x373f, 0x3f20, 0x2037, 
    0x3840, 0x3f21, 0x1f38, 0x3940, 0x4120, 0x2239, 0x3840, 0x4221, 0x233a, 
    0x3840, 0x4321, 0x243b, 0x3840, 0x4121, 0x2239, 0x3840, 0x3f21, 0x1f38, 
    0x3b42, 0x4122, 0x213a, 0x373e, 0x3e1e, 0x1e37, 0x3940, 0x4220, 0x223b, 
    0x3940, 0x3e20, 0x2039, 0x3a3f, 0x4021, 0x223b, 0x3a3e, 0x401e, 0x223b, 
    0x4044, 0x4024, 0x2039, 0x333a, 0x401a, 0x2039, 0x3b42, 0x3e22, 0x1e37, 
    0x3b42, 0x4022, 0x2138, 0x3a42, 0x4023, 0x2138, 0x363e, 0x411f, 0x2036, 
    0x3842, 0x3f20, 0x1f38, 0x383f, 0x421f, 0x223b, 0x363d, 0x421d, 0x223b, 
    0x373e, 0x401e, 0x1e39, 0x3b42, 0x4120, 0x1f3a, 0x3940, 0x441e, 0x203b, 
    0x3c45, 0x4321, 0x1f3a, 0x3942, 0x431e, 0x1e3b, 0x3b43, 0x471e, 0x223f, 
    0x3d45, 0x4620, 0x213e, 0x3e47, 0x4423, 0x203b, 0x414b, 0x4929, 0x253d, 
    0x3b45, 0x4623, 0x203b, 0x3c47, 0x4a21, 0x243f, 0x404b, 0x4725, 0x223f, 
    0x3e46, 0x4f21, 0x2844, 0x3e49, 0x4822, 0x213d, 0x414c, 0x4a25, 0x233f, 
    0x3c47, 0x4620, 0x213e, 0x424a, 0x4725, 0x223f, 0x3d45, 0x4520, 0x203d, 
    0x4048, 0x4b23, 0x2643, 0x424a, 0x4725, 0x223f, 0x3c44, 0x431f, 0x1e3b, 
    0x3f47, 0x4722, 0x223f, 0x3c44, 0x4a1f, 0x2542, 0x3e46, 0x4521, 0x213c, 
    0x3f48, 0x4524, 0x213c, 0x3b44, 0x4620, 0x223d, 0x3c45, 0x4621, 0x223d, 
    0x3942, 0x431e, 0x2139, 0x3b44, 0x4420, 0x1e3c, 0x3d44, 0x461c, 0x1e3f, 
    0x3e44, 0x451b, 0x1b3c, 0x3942, 0x4918, 0x1f40, 0x3d46, 0x431c, 0x193a, 
    0x3c45, 0x461b, 0x1c3d, 0x3c45, 0x441b, 0x1a3b, 0x3b44, 0x461a, 0x1b3b, 
    0x3c45, 0x431b, 0x1c38, 0x3a42, 0x421d, 0x1d3a, 0x3840, 0x401a, 0x1839, 
    0x3b42, 0x411a, 0x193a, 0x363e, 0x4218, 0x1a38, 0x3742, 0x401b, 0x1935, 
    0x333e, 0x3e17, 0x1634, 0x3740, 0x3f16, 0x1436, 0x353e, 0x3f13, 0x1738, 
    0x363d, 0x3e15, 0x1637, 0x363e, 0x3c18, 0x1734, 0x3a42, 0x3e1d, 0x1a35, 
    0x3740, 0x3f1c, 0x1b36, 0x3841, 0x3c1d, 0x1833, 0x3941, 0x3f1c, 0x1834, 
    0x333d, 0x3e15, 0x1634, 0x353f, 0x4117, 0x1937, 0x303a, 0x3e12, 0x1836, 
    0x353d, 0x3b17, 0x1633, 0x353d, 0x3818, 0x1532, 0x353b, 0x3918, 0x1431, 
    0x373f, 0x3d1a, 0x1835, 0x363e, 0x4019, 0x1935, 0x313c, 0x3e15, 0x1733, 
    0x323d, 0x3b16, 0x1533, 0x363d, 0x4015, 0x1839, 0x343b, 0x3a13, 0x1233, 
    0x333a, 0x3c12, 0x1435, 0x3138, 0x3d10, 0x1334, 0x2f38, 0x3a0e, 0x1230, 
    0x323c, 0x3914, 0x112f, 0x333d, 0x3815, 0x102e, 0x353f, 0x3f17, 0x1735, 
    0x313b, 0x3b13, 0x1331, 0x2f39, 0x3811, 0x1330, 0x353d, 0x3b18, 0x1633, 
    0x3139, 0x3914, 0x1431, 0x3137, 0x3614, 0x112e, 0x2b31, 0x340e, 0x0f2c, 
    0x3038, 0x3913, 0x1431, 0x3038, 0x3713, 0x122f, 0x2d35, 0x3910, 0x1431, 
    0x2b33, 0x340e, 0x0f2c, 0x2b33, 0x350e, 0x102d, 0x2f37, 0x3512, 0x0f2d, 
    0x2c34, 0x360e, 0x102e, 0x2e36, 0x3310, 0x0d2b, 0x2b33, 0x340d, 0x0e2c, 
    0x2a32, 0x340c, 0x0d29, 0x2a35, 0x2c0e, 0x0724, 0x2c34, 0x330f, 0x0e2b, 
    0x2c34, 0x2d0f, 0x0825, 0x2c34, 0x340f, 0x0f2c, 0x2a32, 0x2f0d, 0x0927, 
    0x2931, 0x2e0b, 0x0826, 0x2a33, 0x3309, 0x0b29, 0x2a34, 0x300c, 0x0925, 
    0x2831, 0x300d, 0x0b28, 0x262e, 0x2f09, 0x0a27, 0x262e, 0x2f09, 0x0824, 
    0x2631, 0x330a, 0x0d28, 0x2530, 0x2e0a, 0x0c24, 0x242e, 0x2c0c, 0x0823, 
    0x232c, 0x2d08, 0x0825, 0x232b, 0x2c06, 0x0926, 0x2229, 0x2707, 0x0520, 
    0x2229, 0x2a09, 0x0a23, 0x2229, 0x2809, 0x0920, 0x2229, 0x2c09, 0x0c25, 
    0x232a, 0x280a, 0x0621, 0x2229, 0x2607, 0x0622, 0x2024, 0x2404, 0x061f, 
    0x2126, 0x2508, 0x0720, 0x1f24, 0x2606, 0x071e, 0x1e25, 0x2205, 0x051c, 
    0x1e24, 0x0007, 0x3126, 0x2a2e, 0x3033, 0x2c23, 0x1829, 0x2023, 0x2416, 
    0x1a1e, 0x2026, 0x2c1f, 0x2324, 0x2631, 0x3123, 0x0e26, 0x121f, 0x2918, 
    0x171c, 0x1c29, 0x3321, 0x1026, 0x1824, 0x3723, 0x212b, 0x2932, 0x3c2d, 
    0x3834, 0x3e44, 0x3a2c, 0x2436, 0x3032, 0x4838, 0x3547, 0x474a, 0x4732, 
    0x3444, 0x4348, 0x2f1d, 0x1728, 0x1e26, 0x2416, 0x1219, 0x151d, 0x2215, 
    0x1f1a, 0x262e, 0x1e0e, 0x0117, 0x0a11, 0x1b0d, 0x0517, 0x0d10, 0x261b, 
    0x2a23, 0x333a, 0x725f, 0x4a69, 0x505b, 0x2a19, 0x591f, 0x5f6a, 0x3a29, 
    0x252f, 0x2b36, 0x4231, 0x4537, 0x4b56, 0x6756, 0x2c5c, 0x363f, 0x4f3c, 
    0x4d46, 0x5760, 0x3520, 0x392c, 0x464e, 0x523d, 0x114a, 0x1e26, 0x5f4a, 
    0x1657, 0x2128, 0x1a0a, 0x1713, 0x2027, 0x2818, 0x1d21, 0x262d, 0x3829, 
    0x2c34, 0x373b, 0x3829, 0x1934, 0x272a, 0x2c18, 0x0b27, 0x1a1f, 0x3923, 
    0x3434, 0x434b, 0x4f3a, 0x2447, 0x2f36, 0x4432, 0x123d, 0x1f23, 0x4938, 
    0x4945, 0x565a, 0x4b3a, 0x2147, 0x2e32, 0x3d2c, 0x4839, 0x5659, 0x8675, 
    0x7c83, 0x8c8f, 0x8e79, 0x758b, 0x878a, 0x8570, 0x5a82, 0x6d71, 0x846f, 
    0x5a81, 0x696e, 0x3420, 0x292f, 0x393c, 0x6b5a, 0x4368, 0x5154, 0x2110, 
    0x481d, 0x5357, 0x7668, 0x4f70, 0x525a, 0x6e66, 0x4063, 0x3546, 0x2624, 
    0x2e12, 0x162e, 0x3c3f, 0x3a20, 0x1635, 0x3941, 0x3f1c, 0x1d35, 0x3742, 
    0x3e21, 0x1d33, 0x3540, 0x411f, 0x1f37, 0x3640, 0x3c1e, 0x1833, 0x3942, 
    0x401e, 0x1c37, 0x3841, 0x401d, 0x1c37, 0x353e, 0x3d1a, 0x1934, 0x353e, 
    0x3f1a, 0x1d35, 0x343e, 0x391c, 0x1732, 0x363d, 0x411b, 0x1d38, 0x3740, 
    0x3e1c, 0x1a35, 0x353e, 0x3f1a, 0x1d35, 0x3640, 0x3f1e, 0x1d35, 0x353f, 
    0x401d, 0x1f35, 0x303b, 0x3e1a, 0x1d33, 0x343f, 0x3e1e, 0x1f36, 0x323a, 
    0x3b1b, 0x1931, 0x313b, 0x3619, 0x142c, 0x2f39, 0x3c17, 0x1a32, 0x303a, 
    0x3d18, 0x1b33, 0x303a, 0x3a18, 0x1a33, 0x343b, 0x3f1b, 0x1f38, 0x373e, 
    0x3e1e, 0x2138, 0x363c, 0x3a1f, 0x1d34, 0x353b, 0x3c1e, 0x1d34, 0x363e, 
    0x3c1f, 0x1d34, 0x3840, 0x4021, 0x2039, 0x363d, 0x411d, 0x213a, 0x3a41, 
    0x3f21, 0x1f38, 0x3940, 0x4020, 0x2039, 0x3a41, 0x4121, 0x2239, 0x3a42, 
    0x4123, 0x2239, 0x3941, 0x3c22, 0x1e37, 0x3a3f, 0x4021, 0x223b, 0x3a3f, 
    0x4021, 0x233a, 0x3a40, 0x4023, 0x233a, 0x3c42, 0x4125, 0x233c, 0x3e43, 
    0x4325, 0x233c, 0x3c43, 0x4223, 0x203b, 0x3d44, 0x4222, 0x203b, 0x3a41, 
    0x3d1f, 0x1f38, 0x3c40, 0x3e24, 0x213a, 0x3a3e, 0x4121, 0x233c, 0x3c41, 
    0x4523, 0x253e, 0x3d44, 0x4024, 0x2039, 0x3d44, 0x4224, 0x253c, 0x3b41, 
    0x3d24, 0x2236, 0x3940, 0x3f25, 0x2538, 0x3940, 0x3d25, 0x2037, 0x3a40, 
    0x4123, 0x243b, 0x3b41, 0x4424, 0x243d, 0x3a41, 0x4121, 0x1f3a, 0x3f46, 
    0x4424, 0x243d, 0x3a41, 0x4321, 0x243b, 0x3d45, 0x4026, 0x2539, 0x373e, 
    0x3f23, 0x2538, 0x383f, 0x4124, 0x2239, 0x373f, 0x3e20, 0x1f36, 0x3c44, 
    0x4225, 0x233a, 0x3d45, 0x4126, 0x213a, 0x353c, 0x401c, 0x2039, 0x3940, 
    0x4120, 0x2239, 0x3840, 0x4121, 0x2239, 0x3c44, 0x4325, 0x243b, 0x3b43, 
    0x4124, 0x2438, 0x363f, 0x3e22, 0x2135, 0x353e, 0x3d21, 0x2034, 0x343d, 
    0x3e20, 0x2135, 0x363f, 0x3f22, 0x2236, 0x363f, 0x3d22, 0x1e35, 0x3941, 
    0x4122, 0x2239, 0x3941, 0x4122, 0x2036, 0x3843, 0x3e22, 0x1f36, 0x373f, 
    0x4120, 0x2438, 0x3a43, 0x4126, 0x2438, 0x3740, 0x3f23, 0x2236, 0x353e, 
    0x4121, 0x2239, 0x373f, 0x3e20, 0x1f36, 0x373f, 0x4120, 0x2239, 0x3840, 
    0x4021, 0x2039, 0x3a41, 0x4021, 0x2138, 0x3840, 0x4121, 0x2239, 0x3840, 
    0x4021, 0x2138, 0x373f, 0x3f20, 0x2037, 0x373f, 0x4220, 0x223b, 0x3b42, 
    0x4122, 0x213a, 0x373e, 0x3e1e, 0x1e37, 0x383f, 0x3f1f, 0x1f38, 0x363d, 
    0x401d, 0x233a, 0x3b41, 0x4024, 0x223b, 0x3b40, 0x3f22, 0x213a, 0x3a3f, 
    0x3f21, 0x213a, 0x3a3f, 0x3e21, 0x1e37, 0x3a41, 0x3f21, 0x1f38, 0x3940, 
    0x4020, 0x2138, 0x3840, 0x4221, 0x2539, 0x3941, 0x4322, 0x2238, 0x3742, 
    0x4021, 0x2039, 0x373e, 0x421e, 0x223b, 0x3940, 0x4120, 0x233c, 0x3b40, 
    0x3e22, 0x1c37, 0x3940, 0x401e, 0x1e39, 0x3940, 0x451e, 0x233b, 0x3a44, 
    0x4122, 0x1f37, 0x353e, 0x431a, 0x1e3b, 0x3c44, 0x441f, 0x1f3c, 0x3d45, 
    0x4720, 0x233e, 0x3d46, 0x4822, 0x243c, 0x3e4a, 0x4826, 0x243c, 0x3c48, 
    0x4924, 0x233e, 0x3e49, 0x4923, 0x233e, 0x3e49, 0x4723, 0x223f, 0x3f47, 
    0x4a22, 0x233f, 0x3b46, 0x471f, 0x203c
};

CCryptManager::CCryptManager()
{
	m_pCryptTable = NULL;
	m_nTableSize = 0;
	m_nTotalSize = 0;
	m_dwMakeRandKey = 0;		
	m_pRandomTable = NULL;
}

CCryptManager::~CCryptManager()
{
}

DWORD CCryptManager::GetMakeRandKey() {
	return m_dwMakeRandKey;
}

int CCryptManager::GetRandKey()
{
	return (rand() % m_nTableSize);
}

BOOL CCryptManager::LoadTable()
{
	m_nTotalSize = 4096;
	if(m_nTotalSize == 0)
		return false;

	m_nTableSize = m_nTotalSize / MAX_TABLE_DATA_SIZE;
	if(m_nTableSize > MAX_CRYPT_TABLE_SIZE)
		return false;

	m_pCryptTable = (BYTE*) CryptTable;
	if(m_pCryptTable == NULL)
		return false;

	return TRUE;
}

void CCryptManager::LoadTable2(DWORD seed)
{
	m_pCryptTable = new BYTE[4096];
	CRNGRand random;
	random.srand(seed);
	int temp = 4096/4;
	for(int i = 0; i < temp; i++)
	{
		*((DWORD*)(m_pCryptTable + i*sizeof(DWORD))) = random.rand();
	}
}

void CCryptManager::Encrypt(PACKETDATA* data)
{
//	if((data->m_wMsgType == 0x0101) || 
//		(data->m_wMsgType == 0x0102) ||
//		(data->m_wMsgType == 0x0103))
//	{
//		data->m_wMsgType = (WORD)(data->m_wMsgType ^ data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY);
//#ifdef __LINUX__
//		data->m_Key.dwKey = data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
//#else
//		data->m_Key.dwKey = _lrotl(data->m_Key.dwKey, *(data->m_Buffer)%32) ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
//#endif
//		return;
//	}
	if(data->m_wMsgSize == 0)
	{
		data->m_Key.dwKey = 0;
		data->m_wMsgType = (WORD)(data->m_wMsgType ^ data->m_Key.dwKey ^ CRYPTION_KEY);
		return;
	}

	switch(rand()%3)
	{
	case 0:
		Encrypt1(data);
		break;
	case 1:
		Encrypt2(data);
		break;
	case 2:
		Encrypt3(data);
		break;
	}
}

DWORD CCryptManager::GetKey()
{
	//// 랜덤키 생성
	KEY_TYPE key;
	key.KeyValue.key1 = GetRandKey();
	key.KeyValue.key2 = GetRandKey();
	key.KeyValue.key3 = GetRandKey();
	key.KeyValue.key4 = GetRandKey();
	key.KeyValue.index = rand() % MAX_TABLE_DATA_SIZE;
	key.KeyValue.type = rand() % CRYPT_TYPE3;
	return key.dwKey;
}

void CCryptManager::EncryptHeader(PACKETDATA* data)
{
	data->m_Key.dwKey = GetKey();
	data->m_wMsgType = (WORD)(data->m_wMsgType ^ data->m_Key.dwKey ^ CRYPTION_KEY);
	data->m_wMsgSize = (DWORD)(data->m_wMsgSize ^ data->m_Key.dwKey ^ CRYPTION_KEY);
	data->m_Key.dwKey = (DWORD)(data->m_Key.dwKey ^ CRYPTION_KEY);

//	m_Rand1->srand(data->m_Key.dwKey);
}


void CCryptManager::DecryptHeader(PACKETDATA* data)
{
	data->m_Key.dwKey = (DWORD)(data->m_Key.dwKey ^ CRYPTION_KEY);
	data->m_wMsgType = (WORD)(data->m_wMsgType ^ data->m_Key.dwKey ^ CRYPTION_KEY);
	data->m_wMsgSize = (DWORD)(data->m_wMsgSize ^ data->m_Key.dwKey ^ CRYPTION_KEY);
//	m_Rand1->srand(data->m_Key.dwKey);
}

void CCryptManager::CryptBuf(char* data, int len, KEY_TYPE key)
{
//	KEY_TYPE key;
	int iEncryptSize = 0;
	int iPtr = 0;
	BYTE index = 0;

	//// 랜덤키 생성
	//key.KeyValue.key1 = GetRandKey();
	//key.KeyValue.key2 = GetRandKey();
	//key.KeyValue.key3 = GetRandKey();
	//key.KeyValue.key4 = GetRandKey();
	//key.KeyValue.index = rand() % MAX_TABLE_DATA_SIZE;
	//key.KeyValue.type = CRYPT_TYPE2;

//	random.srand(key.dwKey);

	int iMod = len % sizeof(DWORD);

	// 암호화할 길이를 구한다.
	if(iMod == 0)
	{
		iEncryptSize = len / sizeof(DWORD);
		index = key.KeyValue.index;

		for(int i = 0; i < iEncryptSize; i++)
		{
			// 치환할 값을 rand 함수에서 만든다.

			*((DWORD*)(data + iPtr)) = *((DWORD*)(data + iPtr)) ^ key.dwKey ^ m_Rand1->rand();

			index++;
			iPtr += sizeof(DWORD);
		}
	}
	else if(iMod == 2)
	{
		iEncryptSize = len / sizeof(WORD);
		index = key.KeyValue.index;

		for(int i = 0; i < iEncryptSize; i++)
		{
			// 치환할 값을 rand 함수에서 만든다.

			*((WORD*)(data + iPtr)) = *((WORD*)(data + iPtr)) ^ key.wKeyValue.wKey1 ^ (WORD)m_Rand1->rand();

			index++;
			iPtr += sizeof(WORD);
		}
	}
	else
	{
		iEncryptSize = len;
		index = key.KeyValue.index;

		for(int i = 0; i < iEncryptSize; i++)
		{
			// 치환할 값을 rand 함수에서 만든다.

			*(data + iPtr) = *(data + iPtr) ^ key.KeyValue.index ^ (BYTE)m_Rand1->rand();

			index++;
			iPtr += sizeof(BYTE);
		}
	}

}

int CCryptManager::Decrypt(PACKETDATA* data)
{
/*	if(data->m_wMsgSize == 0)
	{
		data->m_Key.dwKey = 0;
		data->m_wMsgType = (WORD)(data->m_wMsgType ^ data->m_Key.dwKey ^ CRYPTION_KEY);
		return true;
	}
//	data->m_Key.dwKey = data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
#ifndef __LINUX__
	data->m_Key.dwKey = _lrotr(data->m_Key.dwKey, *(data->m_Buffer)%32);
#endif
//	data->m_wMsgType = data->m_wMsgType ^ data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
	data->m_wMsgType = (WORD)(data->m_wMsgType ^ data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY);
*/
	if(data->m_wMsgSize <= 0)
		return true;
	//if((data->m_wMsgType == 0x0101) || 
	//	(data->m_wMsgType == 0x0102) ||
	//	(data->m_wMsgType == 0x0103))
	//	return true;

	switch(data->m_Key.KeyValue.type)
	{
	case CRYPT_TYPE1:
		{
			Decrypt1(data);
		}
		break;
	case CRYPT_TYPE2:
		{
			Decrypt2(data);
		}
		break;
	case CRYPT_TYPE3:
		{
			Decrypt3(data);
		}
		break;
	default:
		return false;
	}

	return true;
}
void CCryptManager::Encrypt1(PACKETDATA* data)
{
	KEY_TYPE key;
	int iEncryptSize = 0;
	int iPtr = 0;
	BYTE index = 0;
	TABLE_VALUE vt;

	// 랜덤키 생성
	key.KeyValue.key1 = GetRandKey();
	key.KeyValue.key2 = GetRandKey();
	key.KeyValue.key3 = GetRandKey();
	key.KeyValue.key4 = GetRandKey();
	key.KeyValue.index = rand() % MAX_TABLE_DATA_SIZE;
	key.KeyValue.type = CRYPT_TYPE1;

	// 4바이트로 데이타를 맞춘다.
	int iMod = data->m_wMsgSize % sizeof(DWORD);
	if(iMod)
		data->m_wMsgSize = (data->m_wMsgSize + sizeof(DWORD)); 

	// 암호화할 길이를 구한다.
	iEncryptSize = data->m_wMsgSize / sizeof(DWORD);

	index = key.KeyValue.index;

	for(int i = 0; i < iEncryptSize; i++)
	{
		// 치환할 값을 테이블에서 만든다.
		vt.Value.value1 = *(m_pCryptTable + index + (key.KeyValue.key1 * MAX_TABLE_DATA_SIZE));
		vt.Value.value2 = *(m_pCryptTable + index + (key.KeyValue.key2 * MAX_TABLE_DATA_SIZE));
		vt.Value.value3 = *(m_pCryptTable + index + (key.KeyValue.key3 * MAX_TABLE_DATA_SIZE));
		vt.Value.value4 = *(m_pCryptTable + index + (key.KeyValue.key4 * MAX_TABLE_DATA_SIZE));

	//CString str;
	//str.Format("%d %d %d %d", key.KeyValue.key1
	//	,key.KeyValue.key2
	//	,key.KeyValue.key3
	//	,key.KeyValue.key4);
	//MessageBox(NULL, str, "", MB_OK);
	//str.Format("%d %d %d %d", vt.Value.value1
	//	,vt.Value.value2
	//	,vt.Value.value3
	//	,vt.Value.value4);
	//MessageBox(NULL, str, "", MB_OK);
	//str.Format("%d", vt.dwValue);
	//MessageBox(NULL, str, "", MB_OK);
		*((DWORD*)(data->m_Buffer + iPtr)) = *((DWORD*)(data->m_Buffer + iPtr)) ^ key.dwKey ^ vt.dwValue;

		index++;
		iPtr += 4;
	}

//	data->m_wMsgType = data->m_wMsgType ^ key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
	data->m_wMsgType = (WORD)(data->m_wMsgType ^ key.dwKey ^ CRYPTION_KEY);
//#ifdef __LINUX__
	data->m_Key.dwKey = key.dwKey;// ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
//#else
//	data->m_Key.dwKey = _lrotl(key.dwKey, *(data->m_Buffer)%32) ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
//#endif
}

void CCryptManager::Decrypt1(PACKETDATA* data)
{
	KEY_TYPE key;
	int iEncryptSize = 0;
	int iPtr = 0;
	BYTE index = 0;
	TABLE_VALUE vt;
	vt.dwValue = 0;

	// Decrypt 함수로 옮김.
	//data->m_Key.dwKey = data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
	//data->m_Key.dwKey = _lrotr(data->m_Key.dwKey, *(data->m_Buffer)%32);
	key.dwKey = data->m_Key.dwKey;
//	data->m_wMsgType = data->m_wMsgType ^ key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;


	// 암호해제 할 길이를 구한다.
	iEncryptSize = (data->m_wMsgSize) / sizeof(DWORD);

	index = key.KeyValue.index;

	for(int i = 0; i < iEncryptSize; i++)
	{
		vt.Value.value1 = *(m_pCryptTable + index + (key.KeyValue.key1 * MAX_TABLE_DATA_SIZE));
		vt.Value.value2 = *(m_pCryptTable + index + (key.KeyValue.key2 * MAX_TABLE_DATA_SIZE));
		vt.Value.value3 = *(m_pCryptTable + index + (key.KeyValue.key3 * MAX_TABLE_DATA_SIZE));
		vt.Value.value4 = *(m_pCryptTable + index + (key.KeyValue.key4 * MAX_TABLE_DATA_SIZE));

	//CString str;
	//str.Format("%d %d %d %d", key.KeyValue.key1
	//	,key.KeyValue.key2
	//	,key.KeyValue.key3
	//	,key.KeyValue.key4);
	//MessageBox(NULL, str, "", MB_OK);
	//str.Format("%d %d %d %d", vt.Value.value1
	//	,vt.Value.value2
	//	,vt.Value.value3
	//	,vt.Value.value4);
	//MessageBox(NULL, str, "", MB_OK);
	//str.Format("%d", htonl(vt.dwValue));
	//MessageBox(NULL, str, "", MB_OK);
		*((DWORD*)(data->m_Buffer + iPtr)) = *((DWORD*)(data->m_Buffer + iPtr)) ^ key.dwKey ^ vt.dwValue;

		index++;
		iPtr += 4;
	}

	int iMod = data->m_wMsgSize % sizeof(DWORD);
	if(iMod)
		data->m_wMsgSize = data->m_wMsgSize - sizeof(DWORD);

}

void CCryptManager::Encrypt2(PACKETDATA* data)
{
	KEY_TYPE key;
	int iEncryptSize = 0;
	int iPtr = 0;
	BYTE index = 0;
	CRNGRand random;

	// 랜덤키 생성
	key.KeyValue.key1 = GetRandKey();
	key.KeyValue.key2 = GetRandKey();
	key.KeyValue.key3 = GetRandKey();
	key.KeyValue.key4 = GetRandKey();
	key.KeyValue.index = rand() % MAX_TABLE_DATA_SIZE;
	key.KeyValue.type = CRYPT_TYPE2;

	random.srand(key.dwKey);

	int iMod = data->m_wMsgSize % sizeof(DWORD);
	if(iMod)
		data->m_wMsgSize = (data->m_wMsgSize + sizeof(DWORD)); 

	// 암호화할 길이를 구한다.
	iEncryptSize = data->m_wMsgSize / sizeof(DWORD);

	index = key.KeyValue.index;

	for(int i = 0; i < iEncryptSize; i++)
	{
		// 치환할 값을 rand 함수에서 만든다.

		*((DWORD*)(data->m_Buffer + iPtr)) = *((DWORD*)(data->m_Buffer + iPtr)) ^ key.dwKey ^ random.rand();

		index++;
		iPtr += 4;
	}

//	data->m_wMsgType = data->m_wMsgType ^ key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
	data->m_wMsgType = (WORD)(data->m_wMsgType ^ key.dwKey ^ CRYPTION_KEY);
//#ifdef __LINUX__
	data->m_Key.dwKey = key.dwKey;// ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
//#else
//	data->m_Key.dwKey = _lrotl(key.dwKey, *(data->m_Buffer)%32) ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
//#endif
}

void CCryptManager::Decrypt2(PACKETDATA* data)
{
	KEY_TYPE key;
	int iEncryptSize = 0;
	int iPtr = 0;
	BYTE index = 0;
	CRNGRand random;

	//data->m_Key.dwKey = data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
	//data->m_Key.dwKey = _lrotr(data->m_Key.dwKey, *(data->m_Buffer)%32);

	key.dwKey = data->m_Key.dwKey;
//	data->m_wMsgType = data->m_wMsgType ^ key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;

	random.srand(key.dwKey);

	//key.KeyValue.key1 = data->m_Key.KeyValue.key1;
	//key.KeyValue.key2 = data->m_Key.KeyValue.key2;
	//key.KeyValue.key3 = data->m_Key.KeyValue.key3;
	//key.KeyValue.key4 = data->m_Key.KeyValue.key4;
	//key.KeyValue.index = data->m_Key.KeyValue.index;

	// 암호해제 할 길이를 구한다.
	iEncryptSize = (data->m_wMsgSize) / sizeof(DWORD);

	index = key.KeyValue.index;

	for(int i = 0; i < iEncryptSize; i++)
	{
		// 치환할 값을 rand 함수에서 만든다.

		*((DWORD*)(data->m_Buffer + iPtr)) = *((DWORD*)(data->m_Buffer + iPtr)) ^ key.dwKey ^ random.rand();

		index++;
		iPtr += 4;
	}

	int iMod = data->m_wMsgSize % sizeof(DWORD);
	if(iMod)
		data->m_wMsgSize = data->m_wMsgSize - sizeof(DWORD);

}

void CCryptManager::Encrypt3(PACKETDATA* data)
{
	KEY_TYPE key;
	int iEncryptSize = 0;
	int iPtr = 0;
	BYTE index = 0;
	CRandom random;

	// 랜덤키 생성
	key.KeyValue.key1 = GetRandKey();
	key.KeyValue.key2 = GetRandKey();
	key.KeyValue.key3 = GetRandKey();
	key.KeyValue.key4 = GetRandKey();
	key.KeyValue.index = rand() % MAX_TABLE_DATA_SIZE;
	key.KeyValue.type = CRYPT_TYPE3;

	random.SeedMT(key.dwKey);

	int iMod = data->m_wMsgSize % sizeof(DWORD);
	if(iMod)
		data->m_wMsgSize = (data->m_wMsgSize + sizeof(DWORD)); 

	// 암호화할 길이를 구한다.
	iEncryptSize = data->m_wMsgSize / sizeof(DWORD);

	index = key.KeyValue.index;

	for(int i = 0; i < iEncryptSize; i++)
	{
		// 치환할 값을 rand 함수에서 만든다.

		*((DWORD*)(data->m_Buffer + iPtr)) = *((DWORD*)(data->m_Buffer + iPtr)) ^ key.dwKey ^ random.RandomMT();

		index++;
		iPtr += 4;
	}

//	data->m_wMsgType = data->m_wMsgType ^ key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
	data->m_wMsgType = (WORD)(data->m_wMsgType ^ key.dwKey ^ CRYPTION_KEY);
//#ifdef __LINUX__
	data->m_Key.dwKey = key.dwKey;// ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
//#else
//	data->m_Key.dwKey = _lrotl(key.dwKey, *(data->m_Buffer)%32) ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
//#endif
}

void CCryptManager::Decrypt3(PACKETDATA* data)
{
	KEY_TYPE key;
	int iEncryptSize = 0;
	int iPtr = 0;
	BYTE index = 0;
	CRandom random;

	//data->m_Key.dwKey = data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
	//data->m_Key.dwKey = _lrotr(data->m_Key.dwKey, *(data->m_Buffer)%32);

	key.dwKey = data->m_Key.dwKey;
	//data->m_wMsgType = data->m_wMsgType ^ key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;

	random.SeedMT(key.dwKey);

	//key.KeyValue.key1 = data->m_Key.KeyValue.key1;
	//key.KeyValue.key2 = data->m_Key.KeyValue.key2;
	//key.KeyValue.key3 = data->m_Key.KeyValue.key3;
	//key.KeyValue.key4 = data->m_Key.KeyValue.key4;
	//key.KeyValue.index = data->m_Key.KeyValue.index;

	// 암호해제 할 길이를 구한다.
	iEncryptSize = (data->m_wMsgSize) / sizeof(DWORD);

	index = key.KeyValue.index;

	for(int i = 0; i < iEncryptSize; i++)
	{
		// 치환할 값을 rand 함수에서 만든다.

		*((DWORD*)(data->m_Buffer + iPtr)) = *((DWORD*)(data->m_Buffer + iPtr)) ^ key.dwKey ^ random.RandomMT();

		index++;
		iPtr += 4;
	}

	int iMod = data->m_wMsgSize % sizeof(DWORD);
	if(iMod)
		data->m_wMsgSize = data->m_wMsgSize - sizeof(DWORD);

}

int CCryptManager::InitCryptManager(bool bMakeRandomTable)
{
	if(!LoadTable())
	{
		return false;
	}
	//LoadTable2();
//#ifndef __LINUX__
//	srand((unsigned)time(NULL));
//#endif
	
	if(bMakeRandomTable)
		return MakeRandomKeyTable();

	return true;
}

int CCryptManager::MakeRandomKeyTable()
{
	m_dwMakeRandKey = GetTickCount();
	if(m_dwMakeRandKey == 0)
		return false;

	int iTransformSize = m_nTotalSize / sizeof(DWORD);
	if(iTransformSize == 0)
		return false;

	if(m_nTotalSize == 0)
		return false;

	m_pRandomTable = new BYTE[m_nTotalSize];
#ifdef __LINUX__
	memset(m_pRandomTable, 0, m_nTotalSize);
#else
	ZeroMemory(m_pRandomTable, m_nTotalSize);
#endif
	CRandom random;

	random.SeedMT(m_dwMakeRandKey);

	for(int i = 0; i < iTransformSize; i++)
		*((DWORD*)(m_pRandomTable + i*sizeof(DWORD))) = *((DWORD*)(m_pCryptTable + i*sizeof(DWORD))) ^ random.RandomMT();

	return true;
}

void CCryptManager::StopManager(void)
{
	if(m_pRandomTable)
		delete [] m_pRandomTable;
}

DWORD CRNGRand::rand()
{
	LONGLONG n;
	n = (1103515245 * m_dwRandom + 12345);
	m_dwRandom = (DWORD)(n % 2147483648);     // 2^32
	return m_dwRandom;
}

void CRNGRand::srand(DWORD seed)
{
	m_dwRandom = seed;
}

CRandom::CRandom()
{
	memset( &m_state , 0 , sizeof(m_state) );
	m_pNext = NULL;
	m_left	=	-1;	
}

CRandom::~CRandom()
{

}


//----------------------------------------------------------------------------------------------
//		Name	:	SeedMT
//		Desc	:	* 시드 값을 초기화 한다.
//					- 시드 값이 같으면 같은 난수를 발생 시킨다.
//----------------------------------------------------------------------------------------------
void CRandom::SeedMT( DWORD seed )
{
	DWORD x = (seed | 1U) & 0xFFFFFFFFU, *s = m_state;
	int    j = 0 ;

	for(m_left=0, *s++=x, j=LENTH_OF_STATE_VECTOR; --j;
		*s++ = (x*=69069U) & 0xFFFFFFFFU);
}

//----------------------------------------------------------------------------------------------
//		Name	:	ReloadMT
//		Desc	:	* 시드가 셋팅된 상태로 다시 초기화를 하여 난수를 발생시키고 싶을때 호출
//					- 예를 들면 게임 시작전에 모두 시드값을 같은 값으로 초기화 하고 게임을 진행했을때,
//					  로직에 따라서 렌덤 함수를 더 호출한 사람과 들 호출한 사람이 있을수 있다.
//					  다음 게임을 시작할때 고정 인원이라고 하면 다시 시드값을 줄필요 없이 이 함수만 호출하여 주면 된다.
//----------------------------------------------------------------------------------------------
DWORD CRandom::ReloadMT(void)
{
	DWORD *p0=m_state, *p2=m_state+2, *pM=m_state+M, s0, s1;
	int    j = 0 ;

	if(m_left < -1)
		SeedMT(4357U);

	m_left=LENTH_OF_STATE_VECTOR-1, m_pNext=m_state+1;

	for(s0=m_state[0], s1=m_state[1], j=LENTH_OF_STATE_VECTOR-M+1; --j; s0=s1, s1=*p2++)
		*p0++ = *pM++ ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);

	for(pM=m_state, j=M; --j; s0=s1, s1=*p2++)
		*p0++ = *pM++ ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);

	s1=m_state[0], *p0 = *pM ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);
	s1 ^= (s1 >> 11);
	s1 ^= (s1 <<  7) & 0x9D2C5680U;
	s1 ^= (s1 << 15) & 0xEFC60000U;

	return(s1 ^ (s1 >> 18));
}

//----------------------------------------------------------------------------------------------
//		Name	:	RandomMT
//		Desc	:	* 난수 발생
//----------------------------------------------------------------------------------------------
DWORD CRandom::RandomMT(void)
{
	DWORD y;

	if(--m_left < 0)
		return( ReloadMT() );

	y  = *m_pNext++;
	y ^= (y >> 11);
	y ^= (y <<  7) & 0x9D2C5680U;
	y ^= (y << 15) & 0xEFC60000U;
	return(y ^ (y >> 18));
	// This change made so the value returned is in the same range as what rand() returns
	// return(y ^ (y >> 18)) % 32767;
}

//----------------------------------------------------------------------------------------------
//		Name	:	FrandomMT
//		Desc	:	* float 형 난수 발생
//----------------------------------------------------------------------------------------------
float CRandom::FrandomMT(void) 
{
	return (float)((double)RandomMT() / 4294967296.0);
}

//#ifdef __LINUX__
// external variable declaration
CCryptManager * g_pCryptManager = NULL;
//#endif

