; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\APICheck.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@JOMACIEF@GetTickCount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NNLBIFOO@WINMM?4dll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@DEPJBPP@timeGetTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??0APICheck@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPICheck@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1APICheck@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTimeAddr@APICheck@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@APICheck@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckApi@APICheck@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3APICheck@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2APICheck@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@APICheck@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVAPICheck@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4APICheck@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7APICheck@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0APICheck@@QAE@XZ				; APICheck::APICheck
PUBLIC	??_7APICheck@@6B@				; APICheck::`vftable'
PUBLIC	??_GAPICheck@@UAEPAXI@Z				; APICheck::`scalar deleting destructor'
PUBLIC	??_R4APICheck@@6B@				; APICheck::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVAPICheck@@@8				; APICheck `RTTI Type Descriptor'
PUBLIC	??_R3APICheck@@8				; APICheck::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2APICheck@@8				; APICheck::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@APICheck@@8			; APICheck::`RTTI Base Class Descriptor at (0,-1,0,0)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EAPICheck@@UAEPAXI@Z:NEAR			; APICheck::`vector deleting destructor'
;	COMDAT ??_7APICheck@@6B@
; File c:\darkeden\designed_common\project\client\apicheck.cpp
CONST	SEGMENT
??_7APICheck@@6B@ DD FLAT:??_R4APICheck@@6B@		; APICheck::`vftable'
	DD	FLAT:??_EAPICheck@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4APICheck@@6B@
rdata$r	SEGMENT
??_R4APICheck@@6B@ DD 00H				; APICheck::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAPICheck@@@8
	DD	FLAT:??_R3APICheck@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAPICheck@@@8
_DATA	SEGMENT
??_R0?AVAPICheck@@@8 DD FLAT:??_7type_info@@6B@		; APICheck `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAPICheck@@', 00H
_DATA	ENDS
;	COMDAT ??_R3APICheck@@8
rdata$r	SEGMENT
??_R3APICheck@@8 DD 00H					; APICheck::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2APICheck@@8
rdata$r	ENDS
;	COMDAT ??_R2APICheck@@8
rdata$r	SEGMENT
??_R2APICheck@@8 DD FLAT:??_R1A@?0A@A@APICheck@@8	; APICheck::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@APICheck@@8
rdata$r	SEGMENT
??_R1A@?0A@A@APICheck@@8 DD FLAT:??_R0?AVAPICheck@@@8	; APICheck::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Ogsy
rdata$r	ENDS
;	COMDAT ??0APICheck@@QAE@XZ
_TEXT	SEGMENT
??0APICheck@@QAE@XZ PROC NEAR				; APICheck::APICheck, COMDAT
; _this$ = ecx

; 15   : {

  00000	8b c1		 mov	 eax, ecx

; 16   : 	m_HookCount = 0;

  00002	83 a0 d4 00 00
	00 00		 and	 DWORD PTR [eax+212], 0
  00009	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7APICheck@@6B@

; 17   : }

  0000f	c3		 ret	 0
??0APICheck@@QAE@XZ ENDP				; APICheck::APICheck
_TEXT	ENDS
PUBLIC	??1APICheck@@UAE@XZ				; APICheck::~APICheck
; Function compile flags: /Ogsy
;	COMDAT ??1APICheck@@UAE@XZ
_TEXT	SEGMENT
??1APICheck@@UAE@XZ PROC NEAR				; APICheck::~APICheck, COMDAT
; _this$ = ecx

; 20   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7APICheck@@6B@

; 21   : 
; 22   : }

  00006	c3		 ret	 0
??1APICheck@@UAE@XZ ENDP				; APICheck::~APICheck
_TEXT	ENDS
PUBLIC	?GetTimeAddr@APICheck@@AAEHXZ			; APICheck::GetTimeAddr
PUBLIC	??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@		; `string'
PUBLIC	??_C@_0N@JOMACIEF@GetTickCount?$AA@		; `string'
PUBLIC	??_C@_09NNLBIFOO@WINMM?4dll?$AA@		; `string'
PUBLIC	??_C@_0M@DEPJBPP@timeGetTime?$AA@		; `string'
EXTRN	__imp__GetProcAddress@8:NEAR
EXTRN	__imp__LoadLibraryA@4:NEAR
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@
CONST	SEGMENT
??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@ DB 'kernel32.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JOMACIEF@GetTickCount?$AA@
CONST	SEGMENT
??_C@_0N@JOMACIEF@GetTickCount?$AA@ DB 'GetTickCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NNLBIFOO@WINMM?4dll?$AA@
CONST	SEGMENT
??_C@_09NNLBIFOO@WINMM?4dll?$AA@ DB 'WINMM.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DEPJBPP@timeGetTime?$AA@
CONST	SEGMENT
??_C@_0M@DEPJBPP@timeGetTime?$AA@ DB 'timeGetTime', 00H	; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?GetTimeAddr@APICheck@@AAEHXZ
_TEXT	SEGMENT
?GetTimeAddr@APICheck@@AAEHXZ PROC NEAR			; APICheck::GetTimeAddr, COMDAT
; _this$ = ecx

; 26   : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 27   : 	HMODULE hModule = LoadLibrary("kernel32.dll");

  00002	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__LoadLibraryA@4
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@
  0000d	8b f1		 mov	 esi, ecx
  0000f	ff d7		 call	 edi

; 28   : 	if(hModule == NULL)		return FALSE;

  00011	85 c0		 test	 eax, eax
  00013	74 79		 je	 SHORT $L99431
$L99434:
  00015	53		 push	 ebx

; 29   : 	(FARPROC&)m_hGetTickCount = GetProcAddress(hModule, "GetTickCount");

  00016	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetProcAddress@8
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@JOMACIEF@GetTickCount?$AA@
  00021	50		 push	 eax
  00022	ff d3		 call	 ebx

; 30   : 	if(m_hGetTickCount == NULL)		return FALSE;	

  00024	85 c0		 test	 eax, eax
  00026	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00029	75 04		 jne	 SHORT $L99437
$L100091:
  0002b	33 c0		 xor	 eax, eax
  0002d	eb 5e		 jmp	 SHORT $L100090
$L99437:

; 31   : 	memcpy(&m_buffGetTickCount[0], m_hGetTickCount, 100);

  0002f	6a 64		 push	 100			; 00000064H
  00031	50		 push	 eax
  00032	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _memcpy
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32   : 
; 33   : 	hModule = LoadLibrary("WINMM.dll");

  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09NNLBIFOO@WINMM?4dll?$AA@
  00043	ff d7		 call	 edi

; 34   : 	if(hModule == NULL)		return FALSE;

  00045	85 c0		 test	 eax, eax
  00047	74 e2		 je	 SHORT $L100091

; 35   : 	(FARPROC&)m_htimeGetTime = GetProcAddress(hModule, "timeGetTime");

  00049	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@DEPJBPP@timeGetTime?$AA@
  0004e	50		 push	 eax
  0004f	ff d3		 call	 ebx

; 36   : 	if(m_htimeGetTime == NULL) return FALSE;

  00051	85 c0		 test	 eax, eax
  00053	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00056	74 d3		 je	 SHORT $L100091

; 37   : 	memcpy(&m_bufftimeGetTime[0], m_htimeGetTime, 100);

  00058	6a 64		 push	 100			; 00000064H
  0005a	50		 push	 eax
  0005b	8d 7e 70	 lea	 edi, DWORD PTR [esi+112]
  0005e	57		 push	 edi
  0005f	e8 00 00 00 00	 call	 _memcpy
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	6a 90		 push	 -112			; ffffff90H
  00069	59		 pop	 ecx
  0006a	2b ce		 sub	 ecx, esi
$L99444:

; 38   : 
; 39   : 	for(int i = 0; i<5; i++)
; 40   : 	{
; 41   : 		if(m_buffGetTickCount[i] == 0xE9 ||
; 42   : 			m_buffGetTickCount[i] == 0xE8 ||
; 43   : 			m_bufftimeGetTime[i] == 0xE9 ||
; 44   : 			m_bufftimeGetTime[i] == 0xE8)

  0006c	8a 47 9c	 mov	 al, BYTE PTR [edi-100]
  0006f	3c e9		 cmp	 al, 233			; 000000e9H
  00071	74 b8		 je	 SHORT $L100091
  00073	3c e8		 cmp	 al, 232			; 000000e8H
  00075	74 b4		 je	 SHORT $L100091
  00077	8a 07		 mov	 al, BYTE PTR [edi]
  00079	3c e9		 cmp	 al, 233			; 000000e9H
  0007b	74 ae		 je	 SHORT $L100091
  0007d	3c e8		 cmp	 al, 232			; 000000e8H
  0007f	74 aa		 je	 SHORT $L100091
  00081	47		 inc	 edi
  00082	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00085	83 f8 05	 cmp	 eax, 5
  00088	7c e2		 jl	 SHORT $L99444

; 45   : 			return FALSE;
; 46   : 	}
; 47   : 
; 48   : 	return TRUE;

  0008a	33 c0		 xor	 eax, eax
  0008c	40		 inc	 eax
$L100090:
  0008d	5b		 pop	 ebx
$L99431:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi

; 49   : }

  00090	c3		 ret	 0
?GetTimeAddr@APICheck@@AAEHXZ ENDP			; APICheck::GetTimeAddr
_TEXT	ENDS
PUBLIC	?init@APICheck@@QAEHXZ				; APICheck::init
; Function compile flags: /Ogsy
;	COMDAT ?init@APICheck@@QAEHXZ
_TEXT	SEGMENT
?init@APICheck@@QAEHXZ PROC NEAR			; APICheck::init, COMDAT
; _this$ = ecx

; 53   : 	return GetTimeAddr();

  00000	e9 00 00 00 00	 jmp	 ?GetTimeAddr@APICheck@@AAEHXZ ; APICheck::GetTimeAddr
?init@APICheck@@QAEHXZ ENDP				; APICheck::init
_TEXT	ENDS
PUBLIC	?CheckApi@APICheck@@QAEHXZ			; APICheck::CheckApi
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?CheckApi@APICheck@@QAEHXZ
_TEXT	SEGMENT
_timeGetTimeHand$ = -204				; size = 100
_GetTickCountHand$ = -104				; size = 100
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?CheckApi@APICheck@@QAEHXZ PROC NEAR			; APICheck::CheckApi, COMDAT
; _this$ = ecx

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b f1		 mov	 esi, ecx

; 58   : #ifndef _DEBUG//by viva
; 59   : //	VM_START_WITHLEVEL(0)
; 60   : #endif
; 61   : 	BOOL isHook = FALSE;
; 62   : 	BYTE GetTickCountHand[100], timeGetTimeHand[100];
; 63   : 	memcpy(&GetTickCountHand[0], m_hGetTickCount, 100);

  00012	6a 64		 push	 100			; 00000064H
  00014	ff 76 04	 push	 DWORD PTR [esi+4]
  00017	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001a	8d 45 98	 lea	 eax, DWORD PTR _GetTickCountHand$[ebp]
  0001d	50		 push	 eax
  0001e	33 ff		 xor	 edi, edi
  00020	e8 00 00 00 00	 call	 _memcpy

; 64   : 	memcpy(&timeGetTimeHand[0], m_htimeGetTime, 100);

  00025	6a 64		 push	 100			; 00000064H
  00027	ff 76 08	 push	 DWORD PTR [esi+8]
  0002a	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _timeGetTimeHand$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _memcpy
  00036	83 c4 18	 add	 esp, 24			; 00000018H

; 65   : 
; 66   : 	for(int i=0; i<100; i++)

  00039	33 c0		 xor	 eax, eax
$L99459:

; 67   : 	{
; 68   : 		if(GetTickCountHand[i] != m_buffGetTickCount[i])

  0003b	8a 4c 05 98	 mov	 cl, BYTE PTR _GetTickCountHand$[ebp+eax]
  0003f	3a 4c 06 0c	 cmp	 cl, BYTE PTR [esi+eax+12]
  00043	75 15		 jne	 SHORT $L100102

; 69   : 		{
; 70   : 			isHook = TRUE;
; 71   : 			break;
; 72   : 		}
; 73   : 		if(timeGetTimeHand[i] != m_bufftimeGetTime[i])

  00045	8a 8c 05 34 ff
	ff ff		 mov	 cl, BYTE PTR _timeGetTimeHand$[ebp+eax]
  0004c	3a 4c 30 70	 cmp	 cl, BYTE PTR [eax+esi+112]
  00050	75 08		 jne	 SHORT $L100102
  00052	40		 inc	 eax
  00053	83 f8 64	 cmp	 eax, 100		; 00000064H
  00056	7c e3		 jl	 SHORT $L99459
  00058	eb 03		 jmp	 SHORT $L99461
$L100102:

; 74   : 		{
; 75   : 			isHook = TRUE;

  0005a	33 ff		 xor	 edi, edi
  0005c	47		 inc	 edi
$L99461:

; 76   : 			break;
; 77   : 		}
; 78   : 	}
; 79   : /*	BOOL isHook = FALSE;
; 80   : 	BYTE GetTickCountHand[5], timeGetTimeHand[5];
; 81   : 	memcpy(&GetTickCountHand[0], m_hGetTickCount, 5);
; 82   : 	memcpy(&timeGetTimeHand[0], m_htimeGetTime, 5);
; 83   : 
; 84   : 	for(int i = 0; i<5; i++)
; 85   : 	{
; 86   : 		if(GetTickCountHand[i] == 0xE9 ||
; 87   : 			GetTickCountHand[i] == 0xE8 ||
; 88   : 			timeGetTimeHand[i] ==0xE9 ||
; 89   : 			timeGetTimeHand[i] == 0xE8)
; 90   : 		{
; 91   : 			m_HookCount++;
; 92   : 			isHook = TRUE;
; 93   : 			break;
; 94   : 		}
; 95   : 	}
; 96   : 
; 97   : 	if(isHook)
; 98   : 	{
; 99   : 		if(m_HookCount >= 10)
; 100  : 			return FALSE;
; 101  : 		::WriteProcessMemory(::GetCurrentProcess(),
; 102  : 								(LPVOID)m_hGetTickCount,
; 103  : 								&m_buffGetTickCount,
; 104  : 								5,
; 105  : 								NULL);
; 106  : 		::WriteProcessMemory(::GetCurrentProcess(),
; 107  : 								(LPVOID)m_htimeGetTime,
; 108  : 								&m_bufftimeGetTime,
; 109  : 								5,
; 110  : 								NULL);
; 111  : 	}
; 112  : 	*/
; 113  : #ifndef _DEBUG//by viva
; 114  : //	VM_END
; 115  : #endif
; 116  : 	return isHook;
; 117  : }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	8b c7		 mov	 eax, edi
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	c9		 leave
  0006a	c3		 ret	 0
?CheckApi@APICheck@@QAEHXZ ENDP				; APICheck::CheckApi
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogsy
;	COMDAT ??_GAPICheck@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GAPICheck@@UAEPAXI@Z PROC NEAR			; APICheck::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	f6 44 24 04 01	 test	 BYTE PTR ___flags$[esp-4], 1
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7APICheck@@6B@
  0000e	74 07		 je	 SHORT $L99425
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	59		 pop	 ecx
$L99425:
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??_GAPICheck@@UAEPAXI@Z ENDP				; APICheck::`scalar deleting destructor'
_TEXT	ENDS
END
