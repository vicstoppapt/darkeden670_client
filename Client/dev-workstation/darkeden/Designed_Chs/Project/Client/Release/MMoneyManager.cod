; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\MMoneyManager.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BN@ODLNCKCA@Data?2?2Info?2?2ClientConfig?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@DFPLPGPC@Data?2?2Info?2?2GuildMapper?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@LHODHNBK@Data?2?2Info?2?2GuildVersion?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@DDPLNCOL@Data?2?2Info?2?2Player?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@ILLNAPHB@Data?2?2Info?2?2Resolution?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@HEIGFDLG@Data?2?2Info?2?2SelectedChannel?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?start@CNFS@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@CNFS@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@VirtualFileHeader@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1IFileIO@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIFileIO@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iovfs_base@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Giovfs_base@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1iovfs_base@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@iovfs_base@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Givfstream@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ivfstream@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?open@ivfstream@@UAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Govfstream@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ovfstream@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?open@ovfstream@@UAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MHelpNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MHelpNode@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMHelpNode@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MCompareHelpNode@@QAE@W4HELP_COMPARE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MCompareHelpNode@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@MCompareHelpNode@@UBE?AW4NODE_TYPE@MHelpNode@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMCompareHelpNode@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MOutputHelpNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MOutputHelpNode@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@MOutputHelpNode@@UBE?AW4NODE_TYPE@MHelpNode@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMOutputHelpNode@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MMoneyManager@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MMoneyManager@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MMoneyManager@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMoney@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMoney@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UseMoney@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanAddMoney@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanUseMoney@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDianJuan@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDianJuan@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UseDianJuan@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanAddDianJuan@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanUseDianJuan@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetJiFen@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddJiFen@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UseJiFen@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanAddJiFen@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanUseJiFen@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@W4HELP_OUTPUT@@V?$allocator@W4HELP_OUTPUT@@@_STL@@@_STL@@QAE@ABV?$allocator@W4HELP_OUTPUT@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@W4HELP_OUTPUT@@V?$allocator@W4HELP_OUTPUT@@@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@W4HELP_OUTPUT@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@W4HELP_OUTPUT@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CTypeTable@_N@@QAEAA_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_base@W4HELP_OUTPUT@@V?$allocator@W4HELP_OUTPUT@@@_STL@@@_STL@@QAE@ABV?$allocator@W4HELP_OUTPUT@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_List_base@W4HELP_OUTPUT@@V?$allocator@W4HELP_OUTPUT@@@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PAU?$_List_node@W4HELP_OUTPUT@@@_STL@@U12@V?$allocator@U?$_List_node@W4HELP_OUTPUT@@@_STL@@@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PAU?$_List_node@W4HELP_OUTPUT@@@_STL@@U12@V?$allocator@U?$_List_node@W4HELP_OUTPUT@@@_STL@@@2@@_STL@@QAE@ABV?$allocator@U?$_List_node@W4HELP_OUTPUT@@@_STL@@@1@PAU?$_List_node@W4HELP_OUTPUT@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@U?$_List_node@W4HELP_OUTPUT@@@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U?$_List_node@W4HELP_OUTPUT@@@_STL@@@_STL@@QAEPAU?$_List_node@W4HELP_OUTPUT@@@2@IPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U?$_List_node@W4HELP_OUTPUT@@@_STL@@@_STL@@QAEXPAU?$_List_node@W4HELP_OUTPUT@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$_List_node@W4HELP_OUTPUT@@@_STL@@@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_List_base@W4HELP_OUTPUT@@V?$allocator@W4HELP_OUTPUT@@@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0W4HELP_OUTPUT@@@?$allocator@U?$_List_node@W4HELP_OUTPUT@@@_STL@@@_STL@@QAE@ABV?$allocator@W4HELP_OUTPUT@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@W4HELP_OUTPUT@@@_STL@@YAXPAW4HELP_OUTPUT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3MHelpNode@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3MOutputHelpNode@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3MCompareHelpNode@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2MHelpNode@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2MOutputHelpNode@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2MCompareHelpNode@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R13?0A@A@?$_List_base@W4HELP_OUTPUT@@V?$allocator@W4HELP_OUTPUT@@@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R13?0A@A@?$list@W4HELP_OUTPUT@@V?$allocator@W4HELP_OUTPUT@@@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@MOutputHelpNode@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@MHelpNode@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@MCompareHelpNode@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVIFileIO@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVovfstream@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVivfstream@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$_List_base@W4HELP_OUTPUT@@V?$allocator@W4HELP_OUTPUT@@@_STL@@@_STL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$list@W4HELP_OUTPUT@@V?$allocator@W4HELP_OUTPUT@@@_STL@@@_STL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVMOutputHelpNode@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AViovfs_base@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVMHelpNode@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVMCompareHelpNode@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4MHelpNode@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IFileIO@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ovfstream@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ivfstream@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4MOutputHelpNode@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4iovfs_base@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4MCompareHelpNode@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@_STL@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanBuyStorage@?4??SetMoney@MMoneyManager@@QAE_NH@Z@4_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7MOutputHelpNode@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MCompareHelpNode@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MHelpNode@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ovfstream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ivfstream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7iovfs_base@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IFileIO@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pMoneyManager@@3PAVMMoneyManager@@A		; g_pMoneyManager
_BSS	SEGMENT
?g_pMoneyManager@@3PAVMMoneyManager@@A DD 01H DUP (?)	; g_pMoneyManager
_BSS	ENDS
PUBLIC	??0MMoneyManager@@QAE@XZ			; MMoneyManager::MMoneyManager
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mmoneymanager.cpp
;	COMDAT ??0MMoneyManager@@QAE@XZ
_TEXT	SEGMENT
??0MMoneyManager@@QAE@XZ PROC NEAR			; MMoneyManager::MMoneyManager, COMDAT
; _this$ = ecx

; 20   : {

  00000	8b c1		 mov	 eax, ecx

; 21   : 	m_MaxLimit	= 2000000000;		// 20억
; 22   : 	m_Money			= 0;

  00002	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 23   : 	m_DianJuan		= 0;

  00006	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0000a	c7 00 00 94 35
	77		 mov	 DWORD PTR [eax], 2000000000 ; 77359400H

; 24   : }

  00010	c3		 ret	 0
??0MMoneyManager@@QAE@XZ ENDP				; MMoneyManager::MMoneyManager
_TEXT	ENDS
PUBLIC	??0MMoneyManager@@QAE@ABV0@@Z			; MMoneyManager::MMoneyManager
; Function compile flags: /Ogsy
;	COMDAT ??0MMoneyManager@@QAE@ABV0@@Z
_TEXT	SEGMENT
_mm$ = 8						; size = 4
??0MMoneyManager@@QAE@ABV0@@Z PROC NEAR			; MMoneyManager::MMoneyManager, COMDAT
; _this$ = ecx

; 27   : {

  00000	8b c1		 mov	 eax, ecx

; 28   : 	m_MaxLimit = mm.m_MaxLimit;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR _mm$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 29   : 	m_Money = mm.m_Money;

  0000a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 30   : }

  00010	c2 04 00	 ret	 4
??0MMoneyManager@@QAE@ABV0@@Z ENDP			; MMoneyManager::MMoneyManager
_TEXT	ENDS
PUBLIC	??1MMoneyManager@@QAE@XZ			; MMoneyManager::~MMoneyManager
; Function compile flags: /Ogsy
;	COMDAT ??1MMoneyManager@@QAE@XZ
_TEXT	SEGMENT
??1MMoneyManager@@QAE@XZ PROC NEAR			; MMoneyManager::~MMoneyManager, COMDAT
; _this$ = ecx

; 34   : }

  00000	c3		 ret	 0
??1MMoneyManager@@QAE@XZ ENDP				; MMoneyManager::~MMoneyManager
_TEXT	ENDS
PUBLIC	?SetMoney@MMoneyManager@@QAE_NH@Z		; MMoneyManager::SetMoney
EXTRN	?ExecuteHelpEvent@@YAXW4HELP_EVENT@@@Z:NEAR	; ExecuteHelpEvent
;	COMDAT ?CanBuyStorage@?4??SetMoney@MMoneyManager@@QAE_NH@Z@4_NA
_BSS	SEGMENT
?CanBuyStorage@?4??SetMoney@MMoneyManager@@QAE_NH@Z@4_NA DB 01H DUP (?) ; `MMoneyManager::SetMoney'::`5'::CanBuyStorage
; Function compile flags: /Ogsy
_BSS	ENDS
;	COMDAT ?SetMoney@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_money$ = 8						; size = 4
?SetMoney@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::SetMoney, COMDAT
; _this$ = ecx

; 47   : 	// 0이하거나 한계를 넘어가면 안된다.
; 48   : 	if (money<0 || money > m_MaxLimit)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _money$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 2a		 jl	 SHORT $L101347
  00008	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000a	7f 26		 jg	 SHORT $L101347

; 51   : 	}
; 52   : 
; 53   : 	m_Money = money;
; 54   : 
; 55   : 	// 2004, 5, 6, sobeit add start - 돈이 10 만이 넘으면 보관함 도움말
; 56   : #ifdef __GAME_CLIENT__
; 57   : 	static bool CanBuyStorage = false;
; 58   : 	if( false == CanBuyStorage && m_Money>100000 )

  0000c	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?CanBuyStorage@?4??SetMoney@MMoneyManager@@QAE_NH@Z@4_NA, 0
  00013	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00016	75 16		 jne	 SHORT $L101350
  00018	3d a0 86 01 00	 cmp	 eax, 100000		; 000186a0H
  0001d	7e 0f		 jle	 SHORT $L101350

; 59   : 	{
; 60   : 		ExecuteHelpEvent(HELP_EVENT_STORAGE_BUY);

  0001f	6a 08		 push	 8
  00021	e8 00 00 00 00	 call	 ?ExecuteHelpEvent@@YAXW4HELP_EVENT@@@Z ; ExecuteHelpEvent
  00026	59		 pop	 ecx

; 61   : 		CanBuyStorage = true;

  00027	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?CanBuyStorage@?4??SetMoney@MMoneyManager@@QAE_NH@Z@4_NA, 1
$L101350:

; 62   : 	}
; 63   : #endif
; 64   : 	//2004, 5, 6 sobeit add end
; 65   : 	return true;

  0002e	b0 01		 mov	 al, 1
  00030	eb 02		 jmp	 SHORT $L101345
$L101347:

; 49   : 	{
; 50   : 		return false; 

  00032	32 c0		 xor	 al, al
$L101345:

; 66   : }

  00034	c2 04 00	 ret	 4
?SetMoney@MMoneyManager@@QAE_NH@Z ENDP			; MMoneyManager::SetMoney
_TEXT	ENDS
PUBLIC	?AddMoney@MMoneyManager@@QAE_NH@Z		; MMoneyManager::AddMoney
; Function compile flags: /Ogsy
;	COMDAT ?AddMoney@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_money$ = 8						; size = 4
?AddMoney@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::AddMoney, COMDAT
; _this$ = ecx

; 74   : 	return SetMoney( m_Money + money );

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	03 44 24 04	 add	 eax, DWORD PTR _money$[esp-4]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?SetMoney@MMoneyManager@@QAE_NH@Z ; MMoneyManager::SetMoney

; 75   : }

  0000d	c2 04 00	 ret	 4
?AddMoney@MMoneyManager@@QAE_NH@Z ENDP			; MMoneyManager::AddMoney
_TEXT	ENDS
PUBLIC	?UseMoney@MMoneyManager@@QAE_NH@Z		; MMoneyManager::UseMoney
; Function compile flags: /Ogsy
;	COMDAT ?UseMoney@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_money$ = 8						; size = 4
?UseMoney@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::UseMoney, COMDAT
; _this$ = ecx

; 83   : 	return SetMoney( m_Money - money );

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 44 24 04	 sub	 eax, DWORD PTR _money$[esp-4]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?SetMoney@MMoneyManager@@QAE_NH@Z ; MMoneyManager::SetMoney

; 84   : }

  0000d	c2 04 00	 ret	 4
?UseMoney@MMoneyManager@@QAE_NH@Z ENDP			; MMoneyManager::UseMoney
_TEXT	ENDS
PUBLIC	?CanAddMoney@MMoneyManager@@QAE_NH@Z		; MMoneyManager::CanAddMoney
; Function compile flags: /Ogsy
;	COMDAT ?CanAddMoney@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_money$ = 8						; size = 4
?CanAddMoney@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::CanAddMoney, COMDAT
; _this$ = ecx

; 92   : 	int left = m_Money + money;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	03 44 24 04	 add	 eax, DWORD PTR _money$[esp-4]

; 93   : 
; 94   : 	if (left > m_MaxLimit)

  00007	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00009	0f 9e c0	 setle	 al

; 95   : 	{
; 96   : 		return false; 
; 97   : 	}
; 98   : 
; 99   : 	return true;
; 100  : }

  0000c	c2 04 00	 ret	 4
?CanAddMoney@MMoneyManager@@QAE_NH@Z ENDP		; MMoneyManager::CanAddMoney
_TEXT	ENDS
PUBLIC	?CanUseMoney@MMoneyManager@@QAE_NH@Z		; MMoneyManager::CanUseMoney
; Function compile flags: /Ogsy
;	COMDAT ?CanUseMoney@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_money$ = 8						; size = 4
?CanUseMoney@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::CanUseMoney, COMDAT
; _this$ = ecx

; 108  : 	int left = m_Money - money;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 44 24 04	 sub	 eax, DWORD PTR _money$[esp-4]

; 109  : 
; 110  : 	if (left<0)

  00007	0f 99 c0	 setns	 al

; 111  : 	{
; 112  : 		return false; 
; 113  : 	}
; 114  : 
; 115  : 	return true;
; 116  : }

  0000a	c2 04 00	 ret	 4
?CanUseMoney@MMoneyManager@@QAE_NH@Z ENDP		; MMoneyManager::CanUseMoney
_TEXT	ENDS
PUBLIC	?SetDianJuan@MMoneyManager@@QAE_NH@Z		; MMoneyManager::SetDianJuan
; Function compile flags: /Ogsy
;	COMDAT ?SetDianJuan@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_dianjuan$ = 8						; size = 4
?SetDianJuan@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::SetDianJuan, COMDAT
; _this$ = ecx

; 126  : 	// 0이하거나 한계를 넘어가면 안된다.
; 127  : 	if (dianjuan<0 || dianjuan > m_MaxLimit)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dianjuan$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 0b		 jl	 SHORT $L101376
  00008	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000a	7f 07		 jg	 SHORT $L101376

; 130  : 	}
; 131  : 
; 132  : 	m_DianJuan = dianjuan;

  0000c	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 133  : 
; 134  : 	//2004, 5, 6 sobeit add end
; 135  : 	return true;

  0000f	b0 01		 mov	 al, 1
  00011	eb 02		 jmp	 SHORT $L101374
$L101376:

; 128  : 	{
; 129  : 		return false; 

  00013	32 c0		 xor	 al, al
$L101374:

; 136  : }

  00015	c2 04 00	 ret	 4
?SetDianJuan@MMoneyManager@@QAE_NH@Z ENDP		; MMoneyManager::SetDianJuan
_TEXT	ENDS
PUBLIC	?AddDianJuan@MMoneyManager@@QAE_NH@Z		; MMoneyManager::AddDianJuan
; Function compile flags: /Ogsy
;	COMDAT ?AddDianJuan@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_dianjuan$ = 8						; size = 4
?AddDianJuan@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::AddDianJuan, COMDAT
; _this$ = ecx

; 144  : 	return SetDianJuan( m_DianJuan + dianjuan );

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	03 44 24 04	 add	 eax, DWORD PTR _dianjuan$[esp-4]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?SetDianJuan@MMoneyManager@@QAE_NH@Z ; MMoneyManager::SetDianJuan

; 145  : }

  0000d	c2 04 00	 ret	 4
?AddDianJuan@MMoneyManager@@QAE_NH@Z ENDP		; MMoneyManager::AddDianJuan
_TEXT	ENDS
PUBLIC	?UseDianJuan@MMoneyManager@@QAE_NH@Z		; MMoneyManager::UseDianJuan
; Function compile flags: /Ogsy
;	COMDAT ?UseDianJuan@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_dianjuan$ = 8						; size = 4
?UseDianJuan@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::UseDianJuan, COMDAT
; _this$ = ecx

; 153  : 	return SetDianJuan( m_DianJuan - dianjuan );

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 44 24 04	 sub	 eax, DWORD PTR _dianjuan$[esp-4]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?SetDianJuan@MMoneyManager@@QAE_NH@Z ; MMoneyManager::SetDianJuan

; 154  : }

  0000d	c2 04 00	 ret	 4
?UseDianJuan@MMoneyManager@@QAE_NH@Z ENDP		; MMoneyManager::UseDianJuan
_TEXT	ENDS
PUBLIC	?CanAddDianJuan@MMoneyManager@@QAE_NH@Z		; MMoneyManager::CanAddDianJuan
; Function compile flags: /Ogsy
;	COMDAT ?CanAddDianJuan@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_dianjuan$ = 8						; size = 4
?CanAddDianJuan@MMoneyManager@@QAE_NH@Z PROC NEAR	; MMoneyManager::CanAddDianJuan, COMDAT
; _this$ = ecx

; 162  : 	int left = m_DianJuan + dianjuan;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	03 44 24 04	 add	 eax, DWORD PTR _dianjuan$[esp-4]

; 163  : 
; 164  : 	if (left > m_MaxLimit)

  00007	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00009	0f 9e c0	 setle	 al

; 165  : 	{
; 166  : 		return false; 
; 167  : 	}
; 168  : 
; 169  : 	return true;
; 170  : }

  0000c	c2 04 00	 ret	 4
?CanAddDianJuan@MMoneyManager@@QAE_NH@Z ENDP		; MMoneyManager::CanAddDianJuan
_TEXT	ENDS
PUBLIC	?CanUseDianJuan@MMoneyManager@@QAE_NH@Z		; MMoneyManager::CanUseDianJuan
; Function compile flags: /Ogsy
;	COMDAT ?CanUseDianJuan@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_dianjuan$ = 8						; size = 4
?CanUseDianJuan@MMoneyManager@@QAE_NH@Z PROC NEAR	; MMoneyManager::CanUseDianJuan, COMDAT
; _this$ = ecx

; 178  : 	int left = m_DianJuan - dianjuan;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 44 24 04	 sub	 eax, DWORD PTR _dianjuan$[esp-4]

; 179  : 
; 180  : 	if (left<0)

  00007	0f 99 c0	 setns	 al

; 181  : 	{
; 182  : 		return false; 
; 183  : 	}
; 184  : 
; 185  : 	return true;
; 186  : }

  0000a	c2 04 00	 ret	 4
?CanUseDianJuan@MMoneyManager@@QAE_NH@Z ENDP		; MMoneyManager::CanUseDianJuan
_TEXT	ENDS
PUBLIC	?SetJiFen@MMoneyManager@@QAE_NH@Z		; MMoneyManager::SetJiFen
; Function compile flags: /Ogsy
;	COMDAT ?SetJiFen@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_jifen$ = 8						; size = 4
?SetJiFen@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::SetJiFen, COMDAT
; _this$ = ecx

; 198  : 	// 0이하거나 한계를 넘어가면 안된다.
; 199  : 	if (jifen<0 || jifen > m_MaxLimit)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _jifen$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 0b		 jl	 SHORT $L101402
  00008	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000a	7f 07		 jg	 SHORT $L101402

; 202  : 	}
; 203  : 
; 204  : 	m_JiFen = jifen;

  0000c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 205  : 
; 206  : 	//2004, 5, 6 sobeit add end
; 207  : 	return true;

  0000f	b0 01		 mov	 al, 1
  00011	eb 02		 jmp	 SHORT $L101400
$L101402:

; 200  : 	{
; 201  : 		return false; 

  00013	32 c0		 xor	 al, al
$L101400:

; 208  : }

  00015	c2 04 00	 ret	 4
?SetJiFen@MMoneyManager@@QAE_NH@Z ENDP			; MMoneyManager::SetJiFen
_TEXT	ENDS
PUBLIC	?AddJiFen@MMoneyManager@@QAE_NH@Z		; MMoneyManager::AddJiFen
; Function compile flags: /Ogsy
;	COMDAT ?AddJiFen@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_jifen$ = 8						; size = 4
?AddJiFen@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::AddJiFen, COMDAT
; _this$ = ecx

; 216  : 	return SetJiFen( m_JiFen + jifen );

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	03 44 24 04	 add	 eax, DWORD PTR _jifen$[esp-4]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?SetJiFen@MMoneyManager@@QAE_NH@Z ; MMoneyManager::SetJiFen

; 217  : }

  0000d	c2 04 00	 ret	 4
?AddJiFen@MMoneyManager@@QAE_NH@Z ENDP			; MMoneyManager::AddJiFen
_TEXT	ENDS
PUBLIC	?UseJiFen@MMoneyManager@@QAE_NH@Z		; MMoneyManager::UseJiFen
; Function compile flags: /Ogsy
;	COMDAT ?UseJiFen@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_jifen$ = 8						; size = 4
?UseJiFen@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::UseJiFen, COMDAT
; _this$ = ecx

; 225  : 	return SetJiFen( m_JiFen - jifen );

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	2b 44 24 04	 sub	 eax, DWORD PTR _jifen$[esp-4]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?SetJiFen@MMoneyManager@@QAE_NH@Z ; MMoneyManager::SetJiFen

; 226  : }

  0000d	c2 04 00	 ret	 4
?UseJiFen@MMoneyManager@@QAE_NH@Z ENDP			; MMoneyManager::UseJiFen
_TEXT	ENDS
PUBLIC	?CanAddJiFen@MMoneyManager@@QAE_NH@Z		; MMoneyManager::CanAddJiFen
; Function compile flags: /Ogsy
;	COMDAT ?CanAddJiFen@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_jifen$ = 8						; size = 4
?CanAddJiFen@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::CanAddJiFen, COMDAT
; _this$ = ecx

; 234  : 	int left = m_JiFen + jifen;

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	03 44 24 04	 add	 eax, DWORD PTR _jifen$[esp-4]

; 235  : 
; 236  : 	if (left > m_MaxLimit)

  00007	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00009	0f 9e c0	 setle	 al

; 237  : 	{
; 238  : 		return false; 
; 239  : 	}
; 240  : 
; 241  : 	return true;
; 242  : }

  0000c	c2 04 00	 ret	 4
?CanAddJiFen@MMoneyManager@@QAE_NH@Z ENDP		; MMoneyManager::CanAddJiFen
_TEXT	ENDS
PUBLIC	?CanUseJiFen@MMoneyManager@@QAE_NH@Z		; MMoneyManager::CanUseJiFen
; Function compile flags: /Ogsy
;	COMDAT ?CanUseJiFen@MMoneyManager@@QAE_NH@Z
_TEXT	SEGMENT
_jifen$ = 8						; size = 4
?CanUseJiFen@MMoneyManager@@QAE_NH@Z PROC NEAR		; MMoneyManager::CanUseJiFen, COMDAT
; _this$ = ecx

; 250  : 	int left = m_JiFen - jifen;

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	2b 44 24 04	 sub	 eax, DWORD PTR _jifen$[esp-4]

; 251  : 
; 252  : 	if (left<0)

  00007	0f 99 c0	 setns	 al

; 253  : 	{
; 254  : 		return false; 
; 255  : 	}
; 256  : 
; 257  : 	return true;
; 258  : }

  0000a	c2 04 00	 ret	 4
?CanUseJiFen@MMoneyManager@@QAE_NH@Z ENDP		; MMoneyManager::CanUseJiFen
_TEXT	ENDS
END
