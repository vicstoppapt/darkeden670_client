; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\UtilityFunction.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_02DAHBKLOJ@?W?$PM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LJDDIHIK@?4bmp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GNPKBLNA@?4jpg?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OFMADDDJ@jpeg?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?Is565@CDirectDraw@@SA_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Color@CDirectDraw@@SAGABE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Red@CDirectDraw@@SAEABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Green@CDirectDraw@@SAEABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blue@CDirectDraw@@SAEABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSurfacePointer@CDirectDrawSurface@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSurfacePitch@CDirectDrawSurface@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWidth@CDirectDrawSurface@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHeight@CDirectDrawSurface@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClipLeftTop@CDirectDrawSurface@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClipRightBottom@CDirectDrawSurface@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveStringSpace@@YAXAAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidSSN@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidID@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidPassword@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadImageToSurface@@YA_NPBDAAVCDirectDrawSurface@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveSurfaceToImage@@YA_NPBDAAVCDirectDrawSurface@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ima_jpeg_error_exit@@YAXPAUjpeg_common_struct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadJPG@@YA_NPBDAAH11PAPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveJPG@@YA_NPBDAAH11PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDiskFreeSpaceA@@YAKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Color@CDirectDraw@@SAGABE00@Z			; CDirectDraw::Color
EXTRN	?s_bSHIFT_R@CDirectDraw@@2EA:BYTE		; CDirectDraw::s_bSHIFT_R
EXTRN	?s_bSHIFT_G@CDirectDraw@@2EA:BYTE		; CDirectDraw::s_bSHIFT_G
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\cdirectdraw.h
;	COMDAT ?Color@CDirectDraw@@SAGABE00@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
?Color@CDirectDraw@@SAGABE00@Z PROC NEAR		; CDirectDraw::Color, COMDAT

; 150  : 		return (r << s_bSHIFT_R) | (g << s_bSHIFT_G) | b;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _r$[esp-4]
  00004	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00007	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?s_bSHIFT_R@CDirectDraw@@2EA ; CDirectDraw::s_bSHIFT_R
  0000d	d3 e0		 shl	 eax, cl
  0000f	8b 4c 24 08	 mov	 ecx, DWORD PTR _g$[esp-4]
  00013	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00016	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?s_bSHIFT_G@CDirectDraw@@2EA ; CDirectDraw::s_bSHIFT_G
  0001c	d3 e2		 shl	 edx, cl
  0001e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _b$[esp-4]
  00022	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00025	0b c2		 or	 eax, edx
  00027	0b c1		 or	 eax, ecx

; 151  : 	}

  00029	c3		 ret	 0
?Color@CDirectDraw@@SAGABE00@Z ENDP			; CDirectDraw::Color
_TEXT	ENDS
PUBLIC	?Red@CDirectDraw@@SAEABG@Z			; CDirectDraw::Red
; Function compile flags: /Ogsy
;	COMDAT ?Red@CDirectDraw@@SAEABG@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
?Red@CDirectDraw@@SAEABG@Z PROC NEAR			; CDirectDraw::Red, COMDAT

; 156  : 		return (c >> s_bSHIFT_R);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _c$[esp-4]
  00004	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00007	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?s_bSHIFT_R@CDirectDraw@@2EA ; CDirectDraw::s_bSHIFT_R
  0000d	d3 e8		 shr	 eax, cl

; 157  : 	}

  0000f	c3		 ret	 0
?Red@CDirectDraw@@SAEABG@Z ENDP				; CDirectDraw::Red
_TEXT	ENDS
PUBLIC	?Green@CDirectDraw@@SAEABG@Z			; CDirectDraw::Green
; Function compile flags: /Ogsy
;	COMDAT ?Green@CDirectDraw@@SAEABG@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
?Green@CDirectDraw@@SAEABG@Z PROC NEAR			; CDirectDraw::Green, COMDAT

; 162  : 		//return ((c >> s_bSHIFT_G) & s_bMASK_G);	
; 163  : 
; 164  : 		BYTE g;
; 165  : 		g = c >> s_bSHIFT_G;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _c$[esp-4]
  00004	66 8b 00	 mov	 ax, WORD PTR [eax]
  00007	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?s_bSHIFT_G@CDirectDraw@@2EA ; CDirectDraw::s_bSHIFT_G
  0000d	66 d3 e8	 shr	 ax, cl

; 166  : 		g &= 0x1F;

  00010	24 1f		 and	 al, 31			; 0000001fH

; 167  : 		return g;			
; 168  : 	}

  00012	c3		 ret	 0
?Green@CDirectDraw@@SAEABG@Z ENDP			; CDirectDraw::Green
_TEXT	ENDS
PUBLIC	?Blue@CDirectDraw@@SAEABG@Z			; CDirectDraw::Blue
; Function compile flags: /Ogsy
;	COMDAT ?Blue@CDirectDraw@@SAEABG@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
?Blue@CDirectDraw@@SAEABG@Z PROC NEAR			; CDirectDraw::Blue, COMDAT

; 173  : 		return (c & 0x1F);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _c$[esp-4]
  00004	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00007	83 e0 1f	 and	 eax, 31			; 0000001fH

; 174  : 	}

  0000a	c3		 ret	 0
?Blue@CDirectDraw@@SAEABG@Z ENDP			; CDirectDraw::Blue
_TEXT	ENDS
PUBLIC	?GetSurfacePointer@CDirectDrawSurface@@QAEPAXXZ	; CDirectDrawSurface::GetSurfacePointer
EXTRN	?m_ddsd@CDirectDraw@@1U_DDSURFACEDESC2@@A:BYTE	; CDirectDraw::m_ddsd
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\cdirectdrawsurface.h
;	COMDAT ?GetSurfacePointer@CDirectDrawSurface@@QAEPAXXZ
_TEXT	SEGMENT
?GetSurfacePointer@CDirectDrawSurface@@QAEPAXXZ PROC NEAR ; CDirectDrawSurface::GetSurfacePointer, COMDAT
; _this$ = ecx

; 125  : 	inline void *	GetSurfacePointer() { return m_ddsd.lpSurface; }

  00000	a1 24 00 00 00	 mov	 eax, DWORD PTR ?m_ddsd@CDirectDraw@@1U_DDSURFACEDESC2@@A+36
  00005	c3		 ret	 0
?GetSurfacePointer@CDirectDrawSurface@@QAEPAXXZ ENDP	; CDirectDrawSurface::GetSurfacePointer
_TEXT	ENDS
PUBLIC	?GetSurfacePitch@CDirectDrawSurface@@QAEJXZ	; CDirectDrawSurface::GetSurfacePitch
; Function compile flags: /Ogsy
;	COMDAT ?GetSurfacePitch@CDirectDrawSurface@@QAEJXZ
_TEXT	SEGMENT
?GetSurfacePitch@CDirectDrawSurface@@QAEJXZ PROC NEAR	; CDirectDrawSurface::GetSurfacePitch, COMDAT
; _this$ = ecx

; 126  : 	inline long		GetSurfacePitch() { return m_ddsd.lPitch; }

  00000	a1 10 00 00 00	 mov	 eax, DWORD PTR ?m_ddsd@CDirectDraw@@1U_DDSURFACEDESC2@@A+16
  00005	c3		 ret	 0
?GetSurfacePitch@CDirectDrawSurface@@QAEJXZ ENDP	; CDirectDrawSurface::GetSurfacePitch
_TEXT	ENDS
PUBLIC	?GetWidth@CDirectDrawSurface@@QBEHXZ		; CDirectDrawSurface::GetWidth
; Function compile flags: /Ogsy
;	COMDAT ?GetWidth@CDirectDrawSurface@@QBEHXZ
_TEXT	SEGMENT
?GetWidth@CDirectDrawSurface@@QBEHXZ PROC NEAR		; CDirectDrawSurface::GetWidth, COMDAT
; _this$ = ecx

; 129  : 	inline int		GetWidth() const	{ return m_Width; } // no const...

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetWidth@CDirectDrawSurface@@QBEHXZ ENDP		; CDirectDrawSurface::GetWidth
_TEXT	ENDS
PUBLIC	?GetHeight@CDirectDrawSurface@@QBEHXZ		; CDirectDrawSurface::GetHeight
; Function compile flags: /Ogsy
;	COMDAT ?GetHeight@CDirectDrawSurface@@QBEHXZ
_TEXT	SEGMENT
?GetHeight@CDirectDrawSurface@@QBEHXZ PROC NEAR		; CDirectDrawSurface::GetHeight, COMDAT
; _this$ = ecx

; 130  : 	inline int		GetHeight() const	{ return m_Height; } // no const...

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetHeight@CDirectDrawSurface@@QBEHXZ ENDP		; CDirectDrawSurface::GetHeight
_TEXT	ENDS
PUBLIC	?RemoveStringSpace@@YAXAAPAD@Z			; RemoveStringSpace
EXTRN	_strlen:NEAR
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\utilityfunction.cpp
;	COMDAT ?RemoveStringSpace@@YAXAAPAD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?RemoveStringSpace@@YAXAAPAD@Z PROC NEAR		; RemoveStringSpace, COMDAT

; 22   : 	// 앞쪽 공백 제거
; 23   : 	int bExistChar = 0;
; 24   : 	while (*str != '\0')

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _str$[esp-4]
  00004	eb 0a		 jmp	 SHORT $L109532
$L107846:

; 25   : 	{
; 26   : 		if (*str == ' ')

  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 39 20	 cmp	 BYTE PTR [ecx], 32	; 00000020H
  0000b	75 0b		 jne	 SHORT $L107848

; 27   : 		{
; 28   : 			str++;

  0000d	41		 inc	 ecx
  0000e	89 08		 mov	 DWORD PTR [eax], ecx
$L109532:
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00015	75 ef		 jne	 SHORT $L107846

; 49   : 	}
; 50   : }

  00017	c3		 ret	 0
$L107848:
  00018	56		 push	 esi

; 29   : 		}
; 30   : 		else
; 31   : 		{
; 32   : 			bExistChar = 1;
; 33   : 			break;
; 34   : 		}
; 35   : 	}
; 36   : 
; 37   : 	// 뒤쪽 공백 제거 
; 38   : 	if (bExistChar)
; 39   : 	{
; 40   : 		char* strTemp = str;

  00019	8b 30		 mov	 esi, DWORD PTR [eax]

; 41   : 		strTemp += strlen(str)-1;

  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 _strlen
  00021	59		 pop	 ecx
  00022	8d 44 06 ff	 lea	 eax, DWORD PTR [esi+eax-1]
  00026	5e		 pop	 esi

; 44   : 		{
; 45   : 			strTemp--;

  00027	eb 01		 jmp	 SHORT $L109533
$L107853:
  00029	48		 dec	 eax
$L109533:

; 42   : 
; 43   : 		while (*strTemp == ' ')

  0002a	80 38 20	 cmp	 BYTE PTR [eax], 32	; 00000020H
  0002d	74 fa		 je	 SHORT $L107853

; 46   : 		}
; 47   : 
; 48   : 		*(strTemp+1) = '\0';

  0002f	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 49   : 	}
; 50   : }

  00033	c3		 ret	 0
?RemoveStringSpace@@YAXAAPAD@Z ENDP			; RemoveStringSpace
_TEXT	ENDS
PUBLIC	?IsValidSSN@@YAHPBD0@Z				; IsValidSSN
; Function compile flags: /Ogsy
;	COMDAT ?IsValidSSN@@YAHPBD0@Z
_TEXT	SEGMENT
tv293 = 8						; size = 4
_strSSN1$ = 8						; size = 4
_strSSN2$ = 12						; size = 4
?IsValidSSN@@YAHPBD0@Z PROC NEAR			; IsValidSSN, COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 64   : 	if (strSSN1==0 || strSSN2==0)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _strSSN1$[ebp]
  00008	85 ff		 test	 edi, edi
  0000a	0f 84 b5 00 00
	00		 je	 $L107860
  00010	8b 75 0c	 mov	 esi, DWORD PTR _strSSN2$[ebp]
  00013	85 f6		 test	 esi, esi
  00015	0f 84 aa 00 00
	00		 je	 $L107860

; 67   : 	}
; 68   : 
; 69   : 	//----------------------------------------------------------
; 70   : 	// SSN1 의 길이 체크. 6자여야 한다.
; 71   : 	//----------------------------------------------------------
; 72   : 	int lenSSN1 = strlen(strSSN1);

  0001b	57		 push	 edi
  0001c	e8 00 00 00 00	 call	 _strlen

; 73   : 
; 74   : 	if (lenSSN1 != 6)

  00021	83 f8 06	 cmp	 eax, 6
  00024	59		 pop	 ecx

; 75   : 	{
; 76   : 		return 0;

  00025	0f 85 9a 00 00
	00		 jne	 $L107860

; 77   : 	}
; 78   : 
; 79   : 	//----------------------------------------------------------
; 80   : 	// SSN2의 길이 체크. 7자여야 한다.
; 81   : 	//----------------------------------------------------------
; 82   : 	int lenSSN2 = strlen(strSSN2);

  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 _strlen

; 83   : 
; 84   : 	if (lenSSN2 != 7)

  00031	83 f8 07	 cmp	 eax, 7
  00034	59		 pop	 ecx

; 85   : 	{
; 86   : 		return 0;

  00035	0f 85 8a 00 00
	00		 jne	 $L107860

; 87   : 	}
; 88   : 
; 89   : 	//----------------------------------------------------------
; 90   : 	// 각 자리의 숫자를 읽는다.
; 91   : 	//----------------------------------------------------------
; 92   : 	const int chZero = '0';
; 93   : 
; 94   : 	int n1_0 = strSSN1[0] - chZero;
; 95   : 	int n1_1 = strSSN1[1] - chZero;
; 96   : 	int n1_2 = strSSN1[2] - chZero;
; 97   : 	int n1_3 = strSSN1[3] - chZero;
; 98   : 	int n1_4 = strSSN1[4] - chZero;
; 99   : 	int n1_5 = strSSN1[5] - chZero;
; 100  : 
; 101  : 	int n2_0 = strSSN2[0] - chZero;
; 102  : 	int n2_1 = strSSN2[1] - chZero;
; 103  : 	int n2_2 = strSSN2[2] - chZero;
; 104  : 	int n2_3 = strSSN2[3] - chZero;
; 105  : 	int n2_4 = strSSN2[4] - chZero;
; 106  : 	int n2_5 = strSSN2[5] - chZero;
; 107  : 	int n2_6 = strSSN2[6] - chZero;		// check number
; 108  : 
; 109  : 	//----------------------------------------------------------
; 110  : 	// check할려는 숫자를 계산한다.
; 111  : 	//----------------------------------------------------------
; 112  : 	int sum = n1_0*2 + n1_1*3 + n1_2*4 + n1_3*5 + n1_4*6 + n1_5*7 
; 113  : 			+ n2_0*8 + n2_1*9 + n2_2*2 + n2_3*3 + n2_4*4 + n2_5*5;
; 114  : 
; 115  :     int parity = sum % 11;
; 116  : 
; 117  : 	//----------------------------------------------------------
; 118  : 	// 다른 경우
; 119  : 	//----------------------------------------------------------
; 120  :     if ( ((11-n2_6)) % 10 != (parity % 10) ) 

  0003b	0f be 46 01	 movsx	 eax, BYTE PTR [esi+1]
  0003f	0f be 4f 04	 movsx	 ecx, BYTE PTR [edi+4]
  00043	0f be 56 05	 movsx	 edx, BYTE PTR [esi+5]
  00047	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0004a	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0004d	0f be 4f 01	 movsx	 ecx, BYTE PTR [edi+1]
  00051	03 c1		 add	 eax, ecx
  00053	0f be 4e 03	 movsx	 ecx, BYTE PTR [esi+3]
  00057	03 c1		 add	 eax, ecx
  00059	0f be 4f 03	 movsx	 ecx, BYTE PTR [edi+3]
  0005d	03 ca		 add	 ecx, edx
  0005f	0f be 57 02	 movsx	 edx, BYTE PTR [edi+2]
  00063	53		 push	 ebx
  00064	0f be 1e	 movsx	 ebx, BYTE PTR [esi]
  00067	8d 94 5a 48 fd
	ff ff		 lea	 edx, DWORD PTR [edx+ebx*2-696]
  0006e	0f be 5e 04	 movsx	 ebx, BYTE PTR [esi+4]
  00072	89 4d 08	 mov	 DWORD PTR tv293[ebp], ecx
  00075	0f be 4e 02	 movsx	 ecx, BYTE PTR [esi+2]
  00079	03 d3		 add	 edx, ebx
  0007b	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  0007e	0f be 17	 movsx	 edx, BYTE PTR [edi]
  00081	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00084	03 ca		 add	 ecx, edx
  00086	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00089	8b 4d 08	 mov	 ecx, DWORD PTR tv293[ebp]
  0008c	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  0008f	03 c1		 add	 eax, ecx
  00091	0f be 4f 05	 movsx	 ecx, BYTE PTR [edi+5]
  00095	6b c9 07	 imul	 ecx, 7
  00098	03 c1		 add	 eax, ecx
  0009a	99		 cdq
  0009b	6a 0b		 push	 11			; 0000000bH
  0009d	59		 pop	 ecx
  0009e	f7 f9		 idiv	 ecx
  000a0	6a 0a		 push	 10			; 0000000aH
  000a2	59		 pop	 ecx
  000a3	6a 3b		 push	 59			; 0000003bH
  000a5	8b c2		 mov	 eax, edx
  000a7	99		 cdq
  000a8	f7 f9		 idiv	 ecx
  000aa	58		 pop	 eax
  000ab	6a 0a		 push	 10			; 0000000aH
  000ad	8b ca		 mov	 ecx, edx
  000af	0f be 56 06	 movsx	 edx, BYTE PTR [esi+6]
  000b3	2b c2		 sub	 eax, edx
  000b5	99		 cdq
  000b6	5e		 pop	 esi
  000b7	f7 fe		 idiv	 esi
  000b9	5b		 pop	 ebx
  000ba	8b c2		 mov	 eax, edx
  000bc	2b c1		 sub	 eax, ecx
  000be	f7 d8		 neg	 eax
  000c0	1b c0		 sbb	 eax, eax
  000c2	40		 inc	 eax

; 121  : 	{ 
; 122  : 		return 0; 
; 123  : 	}
; 124  : 
; 125  :     return 1;

  000c3	eb 02		 jmp	 SHORT $L107858
$L107860:

; 65   : 	{
; 66   : 		return 0;

  000c5	33 c0		 xor	 eax, eax
$L107858:
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi

; 126  : }

  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
?IsValidSSN@@YAHPBD0@Z ENDP				; IsValidSSN
_TEXT	ENDS
PUBLIC	?IsValidID@@YAHPBD0@Z				; IsValidID
PUBLIC	??_C@_02DAHBKLOJ@?W?$PM?$AA@			; `string'
EXTRN	_strcpy:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	_strchr:NEAR
;	COMDAT ??_C@_02DAHBKLOJ@?W?$PM?$AA@
CONST	SEGMENT
??_C@_02DAHBKLOJ@?W?$PM?$AA@ DB 0d7H, 0fcH, 00H		; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?IsValidID@@YAHPBD0@Z
_TEXT	SEGMENT
_strblack$107906 = -24					; size = 3
_strtempID$ = -20					; size = 128
__$ArrayPad$ = 108					; size = 4
__$ReturnAddr$ = 116					; size = 4
_strID$ = 120						; size = 4
_strPermit$ = 124					; size = 4
?IsValidID@@YAHPBD0@Z PROC NEAR				; IsValidID, COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 157  : 	const int minLength = 4;
; 158  : 	const int maxLength = 10;
; 159  : 
; 160  : 	// 어떠한 경우이든 허용되는 문자들
; 161  : 	//const char* strPermit = "_-";
; 162  : 
; 163  : 	int len = 0;
; 164  : 
; 165  : 	char strtempID[128];
; 166  : 
; 167  : 	strcpy( strtempID, strID );

  00013	ff 75 78	 push	 DWORD PTR _strID$[ebp]
  00016	89 45 6c	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00019	8d 45 ec	 lea	 eax, DWORD PTR _strtempID$[ebp]
  0001c	50		 push	 eax
  0001d	33 f6		 xor	 esi, esi
  0001f	e8 00 00 00 00	 call	 _strcpy

; 168  : 
; 169  : 	char* str = strtempID;
; 170  : 	
; 171  : 	// 2005.12.8 nanomech
; 172  : 	//--------------------------------------------------------
; 173  : 	// 코드페이지 검사
; 174  : 	// 한글인 경우 949가 아니라면 사용할수 없는 ID이다.
; 175  : 	// 중구어인 경우는...
; 176  : 	//--------------------------------------------------------
; 177  : 	/*if( !IsValidLocale( 949, LCID_SUPPORTED) )
; 178  : 	{
; 179  : 		return 0;
; 180  : 	}
; 181  : 	*/
; 182  : 
; 183  : 	//--------------------------------------------------------
; 184  : 	// 공백이 들어가면 안된다.
; 185  : 	// 길이도 알아낸다. *_*;
; 186  : 	//--------------------------------------------------------
; 187  : 	while (*str != '\0')

  00024	8a 55 ec	 mov	 dl, BYTE PTR _strtempID$[ebp]
  00027	84 d2		 test	 dl, dl
  00029	59		 pop	 ecx
  0002a	59		 pop	 ecx
  0002b	8d 45 ec	 lea	 eax, DWORD PTR _strtempID$[ebp]
  0002e	74 5a		 je	 SHORT $L107896
  00030	8a ca		 mov	 cl, dl
$L107892:

; 188  : 	{
; 189  : 		if (*str == ' ')

  00032	80 f9 20	 cmp	 cl, 32			; 00000020H
  00035	74 53		 je	 SHORT $L107896

; 190  : 		{
; 191  : 			return 0;
; 192  : 		}
; 193  : 
; 194  : 		len++;

  00037	46		 inc	 esi

; 195  : 		str++;

  00038	40		 inc	 eax
  00039	8a 08		 mov	 cl, BYTE PTR [eax]
  0003b	84 c9		 test	 cl, cl
  0003d	75 f3		 jne	 SHORT $L107892

; 196  : 	}
; 197  : 
; 198  : 	//--------------------------------------------------------
; 199  : 	// 길이가 잘못된 경우
; 200  : 	//--------------------------------------------------------
; 201  : 	if (len<minLength || len>maxLength)

  0003f	83 fe 04	 cmp	 esi, 4
  00042	7c 46		 jl	 SHORT $L107896
  00044	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00047	7f 41		 jg	 SHORT $L107896

; 204  : 	}
; 205  : 
; 206  : 	//--------------------------------------------------------
; 207  : 	// 첫글자가 숫자이면 안된다.
; 208  : 	//--------------------------------------------------------
; 209  : 	if (strtempID[0]>='0' && strtempID[0]<='9')

  00049	80 fa 30	 cmp	 dl, 48			; 00000030H
  0004c	7c 05		 jl	 SHORT $L107897
  0004e	80 fa 39	 cmp	 dl, 57			; 00000039H

; 210  : 	{
; 211  : 		return 0;

  00051	7e 37		 jle	 SHORT $L107896
$L107897:

; 212  : 	}
; 213  : 
; 214  : 	//--------------------------------------------------------
; 215  : 	// 한글을 제외한 특수문자가 들어가면 안된다.
; 216  : 	//--------------------------------------------------------
; 217  : 	int bExistHangul = 0;
; 218  : 	int bExistEnglish = 0;
; 219  : 
; 220  : 	str = strtempID;

  00053	8d 5d ec	 lea	 ebx, DWORD PTR _strtempID$[ebp]
$L107901:

; 221  : 	while (*str != '\0')
; 222  : 	{
; 223  : 			
; 224  : 
; 225  : 		char ch = *str;

  00056	8a 03		 mov	 al, BYTE PTR [ebx]

; 226  : 		//--------------------------------------------------------
; 227  : 		// 첫 bit가 '1'이면 한글..일까?
; 228  : 		//--------------------------------------------------------
; 229  : 		if (ch & 0x80)

  00058	84 c0		 test	 al, al
  0005a	79 40		 jns	 SHORT $L107904

; 230  : 		{
; 231  : 			// 한글이므로 두 byte 다음 거 체크
; 232  : 			str++;

  0005c	43		 inc	 ebx

; 233  : 
; 234  : 			if (*str=='\0')

  0005d	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0005f	84 c9		 test	 cl, cl
  00061	74 27		 je	 SHORT $L107896

; 235  : 			{
; 236  : 				// 다음게 없으면 잘못된 ID이다.
; 237  : 				return 0;				
; 238  : 			}
; 239  : //by viva  check GB2312
; 240  : /*
; 241  : 			  런竟櫓匡：   
; 242  :   멕貫：129~160   ，됴貫：64~254（<>127）   
; 243  :   멕貫：170~254   ，됴貫：64~160（<>127）   
; 244  :   숌竟櫓匡：   
; 245  :   멕貫：176~247   ，됴貫：161~254（<>127）   
; 246  :   景喝俚륜（관윅櫓匡깃듐）：   
; 247  :   멕貫：161~167   ，됴貫：161~254   
; 248  :   멕貫：168~169   ，됴貫：64~254（<>127） 
; 249  :   */
; 250  : //			char strKor[3] = { ch, *str };
; 251  : 			//by viva
; 252  : //			char strspec[] = "꿥꿦";
; 253  : 			char strblack[] = "臨";

  00063	be 00 00 00 00	 mov	 esi, OFFSET FLAT:??_C@_02DAHBKLOJ@?W?$PM?$AA@
  00068	8d 7d e8	 lea	 edi, DWORD PTR _strblack$107906[ebp]
  0006b	66 a5		 movsw
  0006d	a4		 movsb

; 254  : 
; 255  : 			if(ch == strblack[0] && *str == strblack[1])

  0006e	3a 45 e8	 cmp	 al, BYTE PTR _strblack$107906[ebp]
  00071	75 05		 jne	 SHORT $L107908
  00073	3a 4d e9	 cmp	 cl, BYTE PTR _strblack$107906[ebp+1]
  00076	74 12		 je	 SHORT $L107896
$L107908:

; 256  : 				return 0;
; 257  : 			if( (unsigned char)ch>=176&&(unsigned char)ch<=247 && (unsigned char)*str>=161&&(unsigned char)*str<=254 ) //숌竟櫓匡

  00078	3c b0		 cmp	 al, 176			; 000000b0H
  0007a	72 0e		 jb	 SHORT $L107896
  0007c	3c f7		 cmp	 al, 247			; 000000f7H
  0007e	77 0a		 ja	 SHORT $L107896
  00080	80 f9 a1	 cmp	 cl, 161			; 000000a1H
  00083	72 05		 jb	 SHORT $L107896
  00085	80 f9 fe	 cmp	 cl, 254			; 000000feH
  00088	76 42		 jbe	 SHORT $L107921
$L107896:

; 202  : 	{
; 203  : 		return 0;

  0008a	33 c0		 xor	 eax, eax
$L107885:

; 393  : }

  0008c	8b 4d 6c	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00097	83 c5 70	 add	 ebp, 112		; 00000070H
  0009a	c9		 leave
  0009b	c3		 ret	 0
$L107904:

; 258  : 			{
; 259  : 			}
; 260  : 			else
; 261  : 			{
; 262  : //				if(ch == strspec[0] && *str == strspec[1] ||
; 263  : //					ch == strspec[2] && *str == strspec[3])
; 264  : //				{
; 265  : //				}
; 266  : //				else
; 267  : 					return 0;
; 268  : 			}
; 269  : 			
; 270  : 			//end
; 271  : 
; 272  : //			else if( (unsigned char)ch>=129&&(unsigned char)ch<=160 && (unsigned char)*str>=64&&(unsigned char)*str<=254 )
; 273  : //			{
; 274  : //			}
; 275  : //			else if( (unsigned char)ch>=170&&(unsigned char)ch<=254 && (unsigned char)*str>=64&&(unsigned char)*str<=160 )
; 276  : //			{
; 277  : //			}
; 278  : //			else if( (unsigned char)ch>=161&&(unsigned char)ch<=167 && (unsigned char)*str>=161&&(unsigned char)*str<=254 )
; 279  : //			{가臨’ 
; 280  : //			}
; 281  : //			else if( (unsigned char)ch>=168&&(unsigned char)ch<=169 && (unsigned char)*str>=64&&(unsigned char)*str<=254 )
; 282  : //			{
; 283  : //			}
; 284  : 
; 285  : 
; 286  : /*
; 287  : 			//--------------------------------------------------------
; 288  : 			// 자음, 모음만 있는 경우라면 잘못된 아이디다.
; 289  : 			//--------------------------------------------------------
; 290  : 			const char* badKor = "ㅂㅃㅈㅉㄷㄸㄱㄲㅅㅆㅛㅕㅑㅐㅒㅔㅖㅁㄴㅇㄹㅎㅗㅓㅏㅣㅋㅌㅊㅍㅠㅜㅡㅙㅝㅟㅢ";
; 291  : 			
; 292  : 			char strKor[3] = { ch, *str };
; 293  : 			
; 294  : 			char* findPtr = strstr(badKor, strKor);
; 295  : 
; 296  : 			if (findPtr!=NULL)
; 297  : 			{
; 298  : 				if (!((findPtr - badKor) & 0x01))	// 짝수라면..
; 299  : 				{					
; 300  : 					return 0;
; 301  : 				}
; 302  : 			}
; 303  : 			*/
; 304  : 
; 305  : 			// 2005.12.8 nanomech
; 306  : 			//--------------------------------------------------------
; 307  : 			// 코드페이지 검사
; 308  : 			// 한글인 경우 949가 아니라면 사용할수 없는 ID이다.
; 309  : 			// 중국어인 경우는...
; 310  : 			//--------------------------------------------------------
; 311  : 			/*
; 312  : 			LPBYTE strTemp = (LPBYTE)strKor;
; 313  : 			if( !( strTemp[0] >= 0xB0 && strTemp[0] < 0xC9	&&
; 314  : 				   strTemp[1] >= 0xA1 && strTemp[1] <= 0xEF ) ) {
; 315  : 				return 0;
; 316  : 			}
; 317  : 			*/
; 318  : 
; 319  : 			//////////////////////////////////////////////////////////////////////////
; 320  : 			// 2005.12.08 by chyaya
; 321  : 			// 유니코드로 치환해서 유니코드표에서 한글인지 검색한다.
; 322  : /*
; 323  : 			WCHAR strWC[2];
; 324  : 			
; 325  : 			MultiByteToWideChar(
; 326  : 				949,					// code page
; 327  : 				MB_PRECOMPOSED,			// character-type options
; 328  : 				strKor,					// string to map
; 329  : 				2,						// number of bytes in string
; 330  : 				strWC,					// wide-character buffer
; 331  : 				2						// size of buffer
; 332  : 				);
; 333  : //by viva
; 334  : //			if( !( strWC[0] >= 0xAC00 && strWC[0] < 0xD7A3 ) ) {
; 335  : //				return 0;
; 336  : //			}
; 337  : //			if( !( strWC[0] >= 0xA1A1 && strWC[0] < 0xFEFE ) ) {
; 338  : //				return 0;
; 339  : //			}
; 340  : 			//
; 341  : 			//////////////////////////////////////////////////////////////////////////
; 342  : 		*/	
; 343  : 			str++;
; 344  : 
; 345  : 			bExistHangul = 1;
; 346  : 		}
; 347  : 		//--------------------------------------------------------
; 348  : 		// 아니면..
; 349  : 		//--------------------------------------------------------
; 350  : 		else
; 351  : 		{
; 352  : 			//--------------------------------------------------------
; 353  : 			// 영어 대소문자..
; 354  : 			//--------------------------------------------------------
; 355  : 			if (ch>='a' && ch<='z' 
; 356  : 				|| ch>='A' && ch<='Z')

  0009c	3c 61		 cmp	 al, 97			; 00000061H
  0009e	7c 04		 jl	 SHORT $L107918
  000a0	3c 7a		 cmp	 al, 122			; 0000007aH
  000a2	7e 28		 jle	 SHORT $L107921
$L107918:
  000a4	3c 41		 cmp	 al, 65			; 00000041H
  000a6	7c 04		 jl	 SHORT $L107916
  000a8	3c 5a		 cmp	 al, 90			; 0000005aH

; 357  : 			{				
; 358  : 				bExistEnglish = 1;
; 359  : 			}
; 360  : 			//--------------------------------------------------------
; 361  : 			// 숫자거나 
; 362  : 			// 허용된 문자인 경우는 괜찮다..
; 363  : 			//--------------------------------------------------------
; 364  : 			else if (ch>='0' && ch<='9'

  000aa	7e 20		 jle	 SHORT $L107921
$L107916:

; 365  : 					|| strPermit!=NULL && strchr(strPermit, ch)!='\0')

  000ac	3c 30		 cmp	 al, 48			; 00000030H
  000ae	7c 04		 jl	 SHORT $L107922
  000b0	3c 39		 cmp	 al, 57			; 00000039H
  000b2	7e 18		 jle	 SHORT $L107921
$L107922:
  000b4	83 7d 7c 00	 cmp	 DWORD PTR _strPermit$[ebp], 0
  000b8	74 d0		 je	 SHORT $L107896
  000ba	0f be c0	 movsx	 eax, al
  000bd	50		 push	 eax
  000be	ff 75 7c	 push	 DWORD PTR _strPermit$[ebp]
  000c1	e8 00 00 00 00	 call	 _strchr
  000c6	85 c0		 test	 eax, eax
  000c8	59		 pop	 ecx
  000c9	59		 pop	 ecx
  000ca	74 be		 je	 SHORT $L107896
$L107921:

; 366  : 			{				
; 367  : 			}
; 368  : 			//--------------------------------------------------------
; 369  : 			// 이상한 문자 쓰면 안된다.				
; 370  : 			//--------------------------------------------------------
; 371  : 			else
; 372  : 			{
; 373  : 				return 0;
; 374  : 			}
; 375  : 
; 376  : 			str++;

  000cc	43		 inc	 ebx
  000cd	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  000d0	75 84		 jne	 SHORT $L107901

; 377  : 
; 378  : 		}
; 379  : 	}
; 380  : 
; 381  : 	//--------------------------------------------------------
; 382  : 	// 한글을 사용한 경우에는 영어를 사용할 수 없다.
; 383  : 	//--------------------------------------------------------
; 384  : 	if (bExistHangul && bExistEnglish)
; 385  : 	{
; 386  : //		return 0;//by viva
; 387  : 	}
; 388  : 
; 389  : 	//--------------------------------------------------------
; 390  : 	// 정상적인 ID
; 391  : 	//--------------------------------------------------------
; 392  : 	return 1;

  000d2	33 c0		 xor	 eax, eax
  000d4	40		 inc	 eax
  000d5	eb b5		 jmp	 SHORT $L107885
?IsValidID@@YAHPBD0@Z ENDP				; IsValidID
_TEXT	ENDS
PUBLIC	?IsValidPassword@@YAHPBD@Z			; IsValidPassword
; Function compile flags: /Ogsy
;	COMDAT ?IsValidPassword@@YAHPBD@Z
_TEXT	SEGMENT
_strPWD$ = 8						; size = 4
?IsValidPassword@@YAHPBD@Z PROC NEAR			; IsValidPassword, COMDAT

; 401  : 	//--------------------------------------------------
; 402  : 	// 허용안되는 특수문자를 사용하면 안된다.
; 403  : 	//--------------------------------------------------
; 404  : 	if (strchr(strPWD, '\\')!=NULL
; 405  : 		|| strchr(strPWD, '\'')!=NULL)

  00000	6a 5c		 push	 92			; 0000005cH
  00002	ff 74 24 08	 push	 DWORD PTR _strPWD$[esp]
  00006	e8 00 00 00 00	 call	 _strchr
  0000b	85 c0		 test	 eax, eax
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	75 13		 jne	 SHORT $L107929
  00011	6a 27		 push	 39			; 00000027H
  00013	ff 74 24 08	 push	 DWORD PTR _strPWD$[esp]
  00017	e8 00 00 00 00	 call	 _strchr
  0001c	85 c0		 test	 eax, eax
  0001e	59		 pop	 ecx
  0001f	59		 pop	 ecx
  00020	75 02		 jne	 SHORT $L107929

; 408  : 	}
; 409  : 
; 410  : 	//--------------------------------------------------
; 411  : 	// 숫자만 사용하면 안된다.
; 412  : 	//--------------------------------------------------
; 413  : 	// 흑흑.. 이미 숫자가 입력된 사람들 때메.. T_T;;
; 414  : 	/*
; 415  : 	char* str = strPWD;
; 416  : 	
; 417  : 	char ch;
; 418  : 
; 419  : 	bool AllNumber = TRUE;
; 420  : 
; 421  : 	while (ch=*str++, ch)
; 422  : 	{
; 423  : 		if (ch<'0' || ch>'9')
; 424  : 		{
; 425  : 			AllNumber = FALSE;
; 426  : 			break;
; 427  : 		}
; 428  : 	}
; 429  : 
; 430  : 	if (AllNumber)	// 전부 숫자인 경우..
; 431  : 	{
; 432  : 		return 0;
; 433  : 	}
; 434  : 	*/
; 435  : 
; 436  : 	return 1;

  00022	40		 inc	 eax

; 437  : }

  00023	c3		 ret	 0
$L107929:

; 406  : 	{
; 407  : 		return 0;

  00024	33 c0		 xor	 eax, eax

; 437  : }

  00026	c3		 ret	 0
?IsValidPassword@@YAHPBD@Z ENDP				; IsValidPassword
_TEXT	ENDS
EXTRN	_longjmp:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?ima_jpeg_error_exit@@YAXPAUjpeg_common_struct@@@Z
_TEXT	SEGMENT
_buffer$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_cinfo$ = 8						; size = 4
?ima_jpeg_error_exit@@YAXPAUjpeg_common_struct@@@Z PROC NEAR ; ima_jpeg_error_exit, COMDAT

; 698  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	56		 push	 esi

; 699  :   /* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
; 700  :   ima_error_ptr myerr = (ima_error_ptr) cinfo->err;
; 701  : 
; 702  :   char buffer[JMSG_LENGTH_MAX];
; 703  : 
; 704  :   /* Create the message */
; 705  :   myerr->pub.format_message (cinfo, buffer);

  0000f	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00015	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00018	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  0001b	8b 30		 mov	 esi, DWORD PTR [eax]
  0001d	51		 push	 ecx
  0001e	50		 push	 eax
  0001f	ff 56 0c	 call	 DWORD PTR [esi+12]
  00022	59		 pop	 ecx
  00023	59		 pop	 ecx

; 706  : 
; 707  :   /* Send it to stderr, adding a newline */
; 708  : //        AfxMessageBox(buffer);
; 709  : 
; 710  :   /* Return control to the setjmp point */
; 711  :   longjmp(myerr->setjmp_buffer, 1);

  00024	6a 01		 push	 1
  00026	81 c6 84 00 00
	00		 add	 esi, 132		; 00000084H
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 _longjmp
$L109559:
$L109558:
  00032	cc		 int	 3
?ima_jpeg_error_exit@@YAXPAUjpeg_common_struct@@@Z ENDP	; ima_jpeg_error_exit
_TEXT	ENDS
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	?LoadJPG@@YA_NPBDAAH11PAPAE@Z			; LoadJPG
EXTRN	_jpeg_stdio_src:NEAR
EXTRN	__setjmp3:NEAR
EXTRN	_jpeg_read_header:NEAR
EXTRN	_jpeg_start_decompress:NEAR
EXTRN	_jpeg_read_scanlines:NEAR
EXTRN	_jpeg_finish_decompress:NEAR
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_jpeg_std_error:NEAR
EXTRN	_jpeg_create_decompress:NEAR
EXTRN	_jpeg_destroy_decompress:NEAR
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?LoadJPG@@YA_NPBDAAH11PAPAE@Z
_TEXT	SEGMENT
_infile$ = -512						; size = 4
_bGray$ = -508						; size = 4
_row_stride$ = -504					; size = 4
_line$ = -500						; size = 4
tv371 = -496						; size = 4
_buffer$ = -492						; size = 4
_col$ = -488						; size = 4
_jerr$ = -484						; size = 196
_cinfo$ = -288						; size = 384
__$ArrayPad$ = 96					; size = 4
__$ReturnAddr$ = 104					; size = 4
_lpszFileName$ = 108					; size = 4
_width$ = 112						; size = 4
_height$ = 116						; size = 4
_bpp$ = 120						; size = 4
_p_data$ = 124						; size = 4
?LoadJPG@@YA_NPBDAAH11PAPAE@Z PROC NEAR			; LoadJPG, COMDAT

; 715  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 9c	 lea	 ebp, DWORD PTR [esp-100]
  00005	81 ec 64 02 00
	00		 sub	 esp, 612		; 00000264H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 716  : 
; 717  : 	BOOL bGray = FALSE;
; 718  :   /* This struct contains the JPEG decompression parameters and pointers to
; 719  : 	* working space (which is allocated as needed by the JPEG library).
; 720  : 	*/
; 721  :   struct jpeg_decompress_struct cinfo;
; 722  :   /* We use our private extension JPEG error handler. */
; 723  : 
; 724  :   struct ima_error_mgr jerr;
; 725  : //  struct jpeg_error_mgr jerr;
; 726  :   /* More stuff */
; 727  :   FILE * infile;		/* source file */
; 728  :   JSAMPARRAY buffer;		/* Output row buffer */
; 729  :   int row_stride;		/* physical row width in output buffer */
; 730  : 
; 731  :   /* In this example we want to open the input file before doing anything else,
; 732  : 	* so that the setjmp() error recovery below can assume the file is open.
; 733  : 	* VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
; 734  : 	* requires it in order to read binary files.
; 735  : 	*/
; 736  : 
; 737  :   if ((infile = fopen(lpszFileName, "rb")) == NULL) {

  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02JDPG@rb?$AA@
  00018	ff 75 6c	 push	 DWORD PTR _lpszFileName$[ebp]
  0001b	33 db		 xor	 ebx, ebx
  0001d	89 45 60	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00020	89 9d 04 fe ff
	ff		 mov	 DWORD PTR _bGray$[ebp], ebx
  00026	e8 00 00 00 00	 call	 _fopen
  0002b	3b c3		 cmp	 eax, ebx
  0002d	59		 pop	 ecx
  0002e	59		 pop	 ecx
  0002f	89 85 00 fe ff
	ff		 mov	 DWORD PTR _infile$[ebp], eax

; 738  : 	 //fprintf(stderr, "can't open %s\n", filename);
; 739  : 	 return 0;

  00035	0f 84 bf 02 00
	00		 je	 $L108816

; 740  :   }
; 741  : 
; 742  :   /* Step 1: allocate and initialize JPEG decompression object */
; 743  :   /* We set up the normal JPEG error routines, then override error_exit. */
; 744  :   cinfo.err = jpeg_std_error(&jerr.pub);

  0003b	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _jpeg_std_error
  00047	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax

; 745  :   jerr.pub.error_exit = ima_jpeg_error_exit;
; 746  : 
; 747  :   /* Establish the setjmp return context for my_error_exit to use. */
; 748  :   if (setjmp(jerr.setjmp_buffer)) {

  0004d	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp+132]
  00053	53		 push	 ebx
  00054	50		 push	 eax
  00055	c7 85 1c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _jerr$[ebp], OFFSET FLAT:?ima_jpeg_error_exit@@YAXPAUjpeg_common_struct@@@Z ; ima_jpeg_error_exit
  0005f	e8 00 00 00 00	 call	 __setjmp3
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	85 c0		 test	 eax, eax
  00069	74 07		 je	 SHORT $L108812
  0006b	32 db		 xor	 bl, bl
  0006d	e9 6b 02 00 00	 jmp	 $L109571
$L108812:

; 749  : 	 /* If we get here, the JPEG code has signaled an error.
; 750  : 	  * We need to clean up the JPEG object, close the input file, and return.
; 751  : 	  */
; 752  : 	 jpeg_destroy_decompress(&cinfo);
; 753  : 	 fclose(infile);
; 754  : 	 return 0;
; 755  :   }
; 756  :   /* Now we can initialize the JPEG decompression object. */
; 757  :   jpeg_create_decompress(&cinfo);

  00072	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _jpeg_create_decompress

; 758  : 
; 759  :   /* Step 2: specify data source (eg, a file) */
; 760  :   jpeg_stdio_src(&cinfo, infile);

  0007e	ff b5 00 fe ff
	ff		 push	 DWORD PTR _infile$[ebp]
  00084	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _jpeg_stdio_src

; 761  : 
; 762  :   /* Step 3: read file parameters with jpeg_read_header() */
; 763  :   (void) jpeg_read_header(&cinfo, TRUE);

  00090	33 f6		 xor	 esi, esi
  00092	46		 inc	 esi
  00093	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00099	56		 push	 esi
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _jpeg_read_header
  000a0	83 c4 14	 add	 esp, 20			; 00000014H

; 764  : 
; 765  :   /* Step 4: set parameters for decompression */
; 766  : //  printf("info %d %d %d CS %d ", cinfo.image_width, cinfo.image_height, cinfo.output_components, cinfo.jpeg_color_space);
; 767  :   if (cinfo.jpeg_color_space!=JCS_GRAYSCALE) {

  000a3	39 b5 04 ff ff
	ff		 cmp	 DWORD PTR _cinfo$[ebp+36], esi
  000a9	74 11		 je	 SHORT $L108814

; 768  : 	cinfo.quantize_colors = TRUE;

  000ab	c6 85 21 ff ff
	ff 01		 mov	 BYTE PTR _cinfo$[ebp+65], 1

; 769  : 	cinfo.desired_number_of_colors = 128;

  000b2	c7 85 28 ff ff
	ff 80 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+72], 128 ; 00000080H
$L108814:

; 770  :   }
; 771  :   /* Step 5: Start decompressor */
; 772  :   jpeg_start_decompress(&cinfo);

  000bc	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _jpeg_start_decompress

; 773  : 
; 774  :   /* We may need to do some setup of our own at this point before reading
; 775  : 	* the data.  After jpeg_start_decompress() we have the correct scaled
; 776  : 	* output image dimensions available, as well as the output colormap
; 777  : 	* if we asked for color quantization.
; 778  : 	*/
; 779  : 
; 780  : 	width = cinfo.image_width;

  000c8	8b 45 70	 mov	 eax, DWORD PTR _width$[ebp]

; 781  : 	height = cinfo.image_height;

  000cb	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _cinfo$[ebp+28]

; 782  : 	bpp = 0;

  000d1	8b 7d 78	 mov	 edi, DWORD PTR _bpp$[ebp]
  000d4	59		 pop	 ecx
  000d5	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _cinfo$[ebp+24]
  000db	89 08		 mov	 DWORD PTR [eax], ecx
  000dd	8b 4d 74	 mov	 ecx, DWORD PTR _height$[ebp]
  000e0	89 11		 mov	 DWORD PTR [ecx], edx
  000e2	89 1f		 mov	 DWORD PTR [edi], ebx

; 783  : 
; 784  : //  char *p_data = NULL;
; 785  : 
; 786  : 	if(width <= 0 || height <= 0)

  000e4	39 18		 cmp	 DWORD PTR [eax], ebx
  000e6	0f 8e 0e 02 00
	00		 jle	 $L108816
  000ec	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ee	0f 8e 06 02 00
	00		 jle	 $L108816

; 788  : 
; 789  :   if (cinfo.jpeg_color_space==JCS_GRAYSCALE)

  000f4	39 b5 04 ff ff
	ff		 cmp	 DWORD PTR _cinfo$[ebp+36], esi
  000fa	75 0f		 jne	 SHORT $L108817

; 790  :   {
; 791  : 	  bGray = TRUE;
; 792  : 	  bpp = 1;

  000fc	89 37		 mov	 DWORD PTR [edi], esi

; 793  : 	  *p_data = new unsigned char [width*height*bpp];

  000fe	8b 00		 mov	 eax, DWORD PTR [eax]
  00100	0f af 01	 imul	 eax, DWORD PTR [ecx]
  00103	89 b5 04 fe ff
	ff		 mov	 DWORD PTR _bGray$[ebp], esi

; 794  : //	  CreateImage(cinfo.image_width, cinfo.image_height, 8);
; 795  : //	  Create(cinfo.image_width, cinfo.image_height, 8);
; 796  :   }
; 797  :   else

  00109	eb 0e		 jmp	 SHORT $L109577
$L108817:

; 798  :   {
; 799  : 	  bpp = 3;

  0010b	c7 07 03 00 00
	00		 mov	 DWORD PTR [edi], 3

; 800  : 	  *p_data = new unsigned char [width*height*bpp];

  00111	8b 00		 mov	 eax, DWORD PTR [eax]
  00113	0f af 01	 imul	 eax, DWORD PTR [ecx]
  00116	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
$L109577:
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 801  :   }
; 802  : 	  //CreateImage(cinfo.image_width, cinfo.image_height, 24);
; 803  : //	  Create(cinfo.image_width, cinfo.image_height, 24);
; 804  : 
; 805  :   /* JSAMPLEs per row in output buffer */
; 806  :   row_stride = cinfo.output_width * cinfo.output_components;

  0011f	8b 9d 40 ff ff
	ff		 mov	 ebx, DWORD PTR _cinfo$[ebp+96]
  00125	0f af 9d 34 ff
	ff ff		 imul	 ebx, DWORD PTR _cinfo$[ebp+84]
  0012c	8b 75 7c	 mov	 esi, DWORD PTR _p_data$[ebp]
  0012f	59		 pop	 ecx

; 807  : //  byte* buf2 = new byte[row_stride];
; 808  : //  printf("NCMPS cmp [%d %d %d]", cinfo.output_components, cinfo.actual_number_of_colors,row_stride);
; 809  : 
; 810  :   /* Make a one-row-high sample array that will go away when done with image */
; 811  :   buffer = (*cinfo.mem->alloc_sarray)
; 812  : 		((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

  00130	6a 01		 push	 1
  00132	89 06		 mov	 DWORD PTR [esi], eax
  00134	53		 push	 ebx
  00135	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0013b	6a 01		 push	 1
  0013d	50		 push	 eax
  0013e	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+4]
  00144	89 9d 08 fe ff
	ff		 mov	 DWORD PTR _row_stride$[ebp], ebx
  0014a	ff 50 08	 call	 DWORD PTR [eax+8]
  0014d	83 c4 10	 add	 esp, 16			; 00000010H

; 813  : 
; 814  :   /* Step 6: while (scan lines remain to be read) */
; 815  :   /*           jpeg_read_scanlines(...); */
; 816  : 
; 817  :   /* Here we use the library's state variable cinfo.output_scanline as the
; 818  :   * loop counter, so that we don't have to keep track ourselves.
; 819  :   */
; 820  :   int line, col;
; 821  : 
; 822  :    if(bGray)

  00150	83 bd 04 fe ff
	ff 00		 cmp	 DWORD PTR _bGray$[ebp], 0
  00157	89 85 14 fe ff
	ff		 mov	 DWORD PTR _buffer$[ebp], eax

; 825  : 	  while (cinfo.output_scanline < cinfo.output_height) 

  0015d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+112]
  00163	74 4d		 je	 SHORT $L108826
  00165	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR _cinfo$[ebp+88]
  0016b	0f 83 5d 01 00
	00		 jae	 $L108834

; 823  :   {
; 824  : 	  line = 0;

  00171	33 ff		 xor	 edi, edi
$L108828:

; 826  : 	  {
; 827  : 		 (void) jpeg_read_scanlines(&cinfo, buffer, 1);

  00173	6a 01		 push	 1
  00175	ff b5 14 fe ff
	ff		 push	 DWORD PTR _buffer$[ebp]
  0017b	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 _jpeg_read_scanlines

; 828  : 		 /* Assume put_scanline_someplace wants a pointer and sample count. */
; 829  : //		 memcpy(ptr[line++], buffer[0], row_stride);
; 830  : 		 memcpy(*p_data+line*row_stride, buffer[0], row_stride);

  00187	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _buffer$[ebp]
  0018d	53		 push	 ebx
  0018e	ff 30		 push	 DWORD PTR [eax]
  00190	8b 06		 mov	 eax, DWORD PTR [esi]
  00192	03 c7		 add	 eax, edi
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _memcpy
  0019a	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+112]
  001a0	83 c4 18	 add	 esp, 24			; 00000018H

; 831  : 		 line++;

  001a3	03 fb		 add	 edi, ebx
  001a5	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR _cinfo$[ebp+88]
  001ab	72 c6		 jb	 SHORT $L108828

; 832  : 	  }
; 833  :   }
; 834  :   else 

  001ad	e9 1c 01 00 00	 jmp	 $L108834
$L108826:

; 835  :   {
; 836  : 	  line = 0;

  001b2	83 a5 0c fe ff
	ff 00		 and	 DWORD PTR _line$[ebp], 0
  001b9	e9 04 01 00 00	 jmp	 $L109578
$L108833:

; 839  : 	  {
; 840  : 		  (void) jpeg_read_scanlines(&cinfo, buffer, 1);

  001be	6a 01		 push	 1
  001c0	ff b5 14 fe ff
	ff		 push	 DWORD PTR _buffer$[ebp]
  001c6	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 _jpeg_read_scanlines

; 841  : 		  /* Assume put_scanline_someplace wants a pointer and sample count. */
; 842  : 		  for(col=0 ; col<row_stride ; col++) 

  001d2	83 a5 18 fe ff
	ff 00		 and	 DWORD PTR _col$[ebp], 0
  001d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001dc	85 db		 test	 ebx, ebx
  001de	0f 8e d2 00 00
	00		 jle	 $L108838

; 839  : 	  {
; 840  : 		  (void) jpeg_read_scanlines(&cinfo, buffer, 1);

  001e4	83 a5 10 fe ff
	ff 00		 and	 DWORD PTR tv371[ebp], 0
$L108836:

; 843  : 		  {
; 844  : 			  (*p_data)[line*row_stride*bpp+col*3+2] = cinfo.colormap[0][buffer[0][col]];

  001eb	8b 17		 mov	 edx, DWORD PTR [edi]
  001ed	0f af 95 0c fe
	ff ff		 imul	 edx, DWORD PTR _line$[ebp]
  001f4	0f af 95 08 fe
	ff ff		 imul	 edx, DWORD PTR _row_stride$[ebp]
  001fb	03 95 10 fe ff
	ff		 add	 edx, DWORD PTR tv371[ebp]
  00201	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _buffer$[ebp]
  00207	8b 00		 mov	 eax, DWORD PTR [eax]
  00209	8b 8d 18 fe ff
	ff		 mov	 ecx, DWORD PTR _col$[ebp]
  0020f	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  00213	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _cinfo$[ebp+108]
  00219	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0021b	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  0021e	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00220	88 44 1a 02	 mov	 BYTE PTR [edx+ebx+2], al

; 845  : 			  (*p_data)[line*row_stride*bpp+col*3+1] = cinfo.colormap[1][buffer[0][col]];

  00224	8b 17		 mov	 edx, DWORD PTR [edi]
  00226	0f af 95 0c fe
	ff ff		 imul	 edx, DWORD PTR _line$[ebp]
  0022d	0f af 95 08 fe
	ff ff		 imul	 edx, DWORD PTR _row_stride$[ebp]
  00234	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _buffer$[ebp]
  0023a	8b 00		 mov	 eax, DWORD PTR [eax]
  0023c	8b 8d 18 fe ff
	ff		 mov	 ecx, DWORD PTR _col$[ebp]
  00242	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  00246	03 95 10 fe ff
	ff		 add	 edx, DWORD PTR tv371[ebp]
  0024c	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _cinfo$[ebp+108]
  00252	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00255	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00258	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 846  : 			  (*p_data)[line*row_stride*bpp+col*3+0] = cinfo.colormap[2][buffer[0][col]];

  0025a	8b 8d 18 fe ff
	ff		 mov	 ecx, DWORD PTR _col$[ebp]
  00260	88 44 1a 01	 mov	 BYTE PTR [edx+ebx+1], al
  00264	8b 17		 mov	 edx, DWORD PTR [edi]
  00266	0f af 95 0c fe
	ff ff		 imul	 edx, DWORD PTR _line$[ebp]
  0026d	0f af 95 08 fe
	ff ff		 imul	 edx, DWORD PTR _row_stride$[ebp]
  00274	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _buffer$[ebp]
  0027a	8b 00		 mov	 eax, DWORD PTR [eax]
  0027c	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  00280	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _cinfo$[ebp+108]
  00286	03 95 10 fe ff
	ff		 add	 edx, DWORD PTR tv371[ebp]
  0028c	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0028f	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00291	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00294	ff 85 18 fe ff
	ff		 inc	 DWORD PTR _col$[ebp]
  0029a	83 85 10 fe ff
	ff 03		 add	 DWORD PTR tv371[ebp], 3
  002a1	88 04 1a	 mov	 BYTE PTR [edx+ebx], al
  002a4	8b 9d 08 fe ff
	ff		 mov	 ebx, DWORD PTR _row_stride$[ebp]
  002aa	39 9d 18 fe ff
	ff		 cmp	 DWORD PTR _col$[ebp], ebx
  002b0	0f 8c 35 ff ff
	ff		 jl	 $L108836
$L108838:

; 847  : 		  }
; 848  : 		  line++;

  002b6	ff 85 0c fe ff
	ff		 inc	 DWORD PTR _line$[ebp]
  002bc	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+112]
$L109578:

; 837  : 
; 838  : 	  while (cinfo.output_scanline < cinfo.output_height) 

  002c2	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR _cinfo$[ebp+88]
  002c8	0f 82 f0 fe ff
	ff		 jb	 $L108833
$L108834:

; 849  : 	  }
; 850  :   }
; 851  : 
; 852  : 
; 853  :   /* Step 7: Finish decompression */
; 854  :   (void) jpeg_finish_decompress(&cinfo);

  002ce	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  002d4	50		 push	 eax
  002d5	e8 00 00 00 00	 call	 _jpeg_finish_decompress
  002da	59		 pop	 ecx
  002db	b3 01		 mov	 bl, 1
$L109571:

; 855  :   /* We can ignore the return value since suspension is not possible
; 856  : 	* with the stdio data source.
; 857  : 	*/
; 858  : 
; 859  :   /* Step 8: Release JPEG decompression object */
; 860  : 
; 861  :   /* This is an important step since it will release a good deal of memory. */
; 862  :   jpeg_destroy_decompress(&cinfo);

  002dd	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  002e3	50		 push	 eax
  002e4	e8 00 00 00 00	 call	 _jpeg_destroy_decompress

; 863  : 
; 864  :   /* After finish_decompress, we can close the input file.
; 865  : 	* Here we postpone it until after no more JPEG errors are possible,
; 866  : 	* so as to simplify the setjmp error logic above.  (Actually, I don't
; 867  : 	* think that jpeg_destroy can do an error exit, but why assume anything...)
; 868  : 	*/
; 869  :   fclose(infile);

  002e9	ff b5 00 fe ff
	ff		 push	 DWORD PTR _infile$[ebp]
  002ef	e8 00 00 00 00	 call	 _fclose
  002f4	59		 pop	 ecx
  002f5	59		 pop	 ecx

; 870  :   /* At this point you may want to check to see whether any corrupt-data
; 871  : 	* warnings occurred (test whether jerr.pub.num_warnings is nonzero).
; 872  : 	*/
; 873  : 
; 874  : 
; 875  : //  delete p_data;
; 876  :   /* And we're done! */
; 877  :   return 1;

  002f6	8a c3		 mov	 al, bl
  002f8	eb 02		 jmp	 SHORT $L108803
$L108816:

; 787  : 		return 0;

  002fa	32 c0		 xor	 al, al
$L108803:

; 878  : }

  002fc	8b 4d 60	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00304	5f		 pop	 edi
  00305	5e		 pop	 esi
  00306	5b		 pop	 ebx
  00307	83 c5 64	 add	 ebp, 100		; 00000064H
  0030a	c9		 leave
  0030b	c3		 ret	 0
?LoadJPG@@YA_NPBDAAH11PAPAE@Z ENDP			; LoadJPG
_TEXT	ENDS
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	?SaveJPG@@YA_NPBDAAH11PAE@Z			; SaveJPG
EXTRN	_jpeg_set_defaults:NEAR
EXTRN	_jpeg_start_compress:NEAR
EXTRN	_jpeg_write_scanlines:NEAR
EXTRN	_jpeg_finish_compress:NEAR
EXTRN	_jpeg_create_compress:NEAR
EXTRN	_jpeg_destroy_compress:NEAR
EXTRN	_jpeg_stdio_dest:NEAR
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?SaveJPG@@YA_NPBDAAH11PAE@Z
_TEXT	SEGMENT
_outfile$ = -372					; size = 4
_bGray$ = -368						; size = 4
_jerr$ = -364						; size = 132
_cinfo$ = -232						; size = 328
__$ArrayPad$ = 96					; size = 4
__$ReturnAddr$ = 104					; size = 4
_lpszFileName$ = 108					; size = 4
_width$ = 112						; size = 4
_height$ = 116						; size = 4
_bpp$ = 120						; size = 4
_p_data$ = 124						; size = 4
?SaveJPG@@YA_NPBDAAH11PAE@Z PROC NEAR			; SaveJPG, COMDAT

; 881  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 9c	 lea	 ebp, DWORD PTR [esp-100]
  00005	81 ec d8 01 00
	00		 sub	 esp, 472		; 000001d8H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 882  : 	BOOL bGray = FALSE;

  00010	83 a5 90 fe ff
	ff 00		 and	 DWORD PTR _bGray$[ebp], 0
  00017	89 45 60	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 883  : 	int i;
; 884  : 
; 885  :   struct jpeg_compress_struct cinfo;
; 886  :   /* This struct represents a JPEG error handler.  It is declared separately
; 887  : 	* because applications often want to supply a specialized error handler
; 888  : 	* (see the second half of this file for an example).  But here we just
; 889  : 	* take the easy way out and use the standard error handler, which will
; 890  : 	* print a message on stderr and call exit() if compression fails.
; 891  : 	* Note that this struct must live as long as the main JPEG parameter
; 892  : 	* struct, to avoid dangling-pointer problems.
; 893  : 	*/
; 894  :   struct jpeg_error_mgr jerr;
; 895  :   /* More stuff */
; 896  :   FILE * outfile;		/* target file */
; 897  :   int row_stride;		/* physical row width in image buffer */
; 898  :   JSAMPARRAY buffer;		/* Output row buffer */
; 899  : 
; 900  :   /* Step 1: allocate and initialize JPEG compression object */
; 901  : 
; 902  :   /* We have to set up the error handler first, in case the initialization
; 903  : 	* step fails.  (Unlikely, but it could happen if you are out of memory.)
; 904  : 	* This routine fills in the contents of struct jerr, and returns jerr's
; 905  : 	* address which we place into the link field in cinfo.
; 906  : 	*/
; 907  :   cinfo.err = jpeg_std_error(&jerr);

  0001a	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _jpeg_std_error
  00026	89 85 18 ff ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax

; 908  :   /* Now we can initialize the JPEG compression object. */
; 909  :   jpeg_create_compress(&cinfo);

  0002c	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _jpeg_create_compress

; 910  : 
; 911  :   /* Step 2: specify data destination (eg, a file) */
; 912  :   /* Note: steps 2 and 3 can be done in either order. */
; 913  : 
; 914  :   /* Here we use the library-supplied code to send compressed data to a
; 915  : 	* stdio stream.  You can also write your own code to do something else.
; 916  : 	* VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
; 917  : 	* requires it in order to write binary files.
; 918  : 	*/
; 919  :   if ((outfile = fopen(lpszFileName, "wb")) == NULL) {

  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02GMLFBBN@wb?$AA@
  0003d	ff 75 6c	 push	 DWORD PTR _lpszFileName$[ebp]
  00040	e8 00 00 00 00	 call	 _fopen
  00045	83 c4 10	 add	 esp, 16			; 00000010H
  00048	85 c0		 test	 eax, eax
  0004a	89 85 8c fe ff
	ff		 mov	 DWORD PTR _outfile$[ebp], eax
  00050	75 07		 jne	 SHORT $L108854

; 920  : //	 fprintf(stderr, "can't open %s\n", filename);
; 921  : 	 return FALSE;

  00052	32 c0		 xor	 al, al
  00054	e9 24 01 00 00	 jmp	 $L108846
$L108854:
  00059	53		 push	 ebx
  0005a	56		 push	 esi
  0005b	57		 push	 edi

; 922  :   }
; 923  :   jpeg_stdio_dest(&cinfo, outfile);

  0005c	50		 push	 eax
  0005d	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _jpeg_stdio_dest

; 924  : 
; 925  :   /* Step 3: set parameters for compression */
; 926  : 
; 927  :   /* First we supply a description of the input image.
; 928  : 	* Four fields of the cinfo struct must be filled in:
; 929  : 	*/
; 930  :   cinfo.image_width = width; 	// image width and height, in pixels

  00069	8b 75 70	 mov	 esi, DWORD PTR _width$[ebp]
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	89 85 30 ff ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 931  :   cinfo.image_height = height;

  00074	8b 45 74	 mov	 eax, DWORD PTR _height$[ebp]
  00077	8b 00		 mov	 eax, DWORD PTR [eax]

; 932  :   if(bpp == 8)
; 933  :   {
; 934  : 	  cinfo.input_components = 1; 	// # of color components per pixel

  00079	33 db		 xor	 ebx, ebx
  0007b	89 85 34 ff ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+28], eax
  00081	8b 45 78	 mov	 eax, DWORD PTR _bpp$[ebp]
  00084	59		 pop	 ecx
  00085	43		 inc	 ebx
  00086	83 38 08	 cmp	 DWORD PTR [eax], 8
  00089	59		 pop	 ecx
  0008a	75 14		 jne	 SHORT $L108856
  0008c	89 9d 38 ff ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+32], ebx

; 935  : 	  cinfo.in_color_space = JCS_GRAYSCALE; 	/* colorspace of input image */

  00092	89 9d 3c ff ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+36], ebx

; 936  : 	  bGray = TRUE;

  00098	89 9d 90 fe ff
	ff		 mov	 DWORD PTR _bGray$[ebp], ebx

; 937  :   }
; 938  :   else

  0009e	eb 14		 jmp	 SHORT $L108857
$L108856:

; 939  :   {
; 940  : 	  cinfo.input_components = 3; 	// # of color components per pixel

  000a0	c7 85 38 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+32], 3

; 941  : 	  cinfo.in_color_space = JCS_RGB; 	/* colorspace of input image */

  000aa	c7 85 3c ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+36], 2
$L108857:

; 942  :   }
; 943  : 
; 944  : //  printf("info %d %d %d %d ", cinfo.image_width, cinfo.image_height, cinfo.input_components, cinfo.in_color_space);
; 945  :   /* Now use the library's routine to set default compression parameters.
; 946  : 	* (You must set at least cinfo.in_color_space before calling this,
; 947  : 	* since the defaults depend on the source color space.)
; 948  : 	*/
; 949  :   jpeg_set_defaults(&cinfo);

  000b4	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _jpeg_set_defaults

; 950  :   /* Now you can set any non-default parameters you wish to.
; 951  : 	* Here we just illustrate the use of quality (quantization table) scaling:
; 952  : 	*/
; 953  :   //jpeg_set_quality(&cinfo, 30, TRUE /* limit to baseline-JPEG values */);
; 954  : 
; 955  :   /* Step 4: Start compressor */
; 956  : 
; 957  :   /* TRUE ensures that we will write a complete interchange-JPEG file.
; 958  : 	* Pass TRUE unless you are very sure of what you're doing.
; 959  : 	*/
; 960  : //  puts("begining");
; 961  :   jpeg_start_compress(&cinfo, TRUE);

  000c0	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000c6	53		 push	 ebx
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _jpeg_start_compress

; 962  : 
; 963  :   /* Step 5: while (scan lines remain to be written) */
; 964  :   /*           jpeg_write_scanlines(...); */
; 965  : 
; 966  :   /* Here we use the library's state variable cinfo.next_scanline as the
; 967  : 	* loop counter, so that we don't have to keep track ourselves.
; 968  : 	* To keep things simple, we pass one scanline per call; you can pass
; 969  : 	* more if you wish, though.
; 970  : 	*/
; 971  :   row_stride = width*cinfo.input_components;	/* JSAMPLEs per row in image_buffer */

  000cd	8b 36		 mov	 esi, DWORD PTR [esi]
  000cf	0f af b5 38 ff
	ff ff		 imul	 esi, DWORD PTR _cinfo$[ebp+32]

; 972  : 
; 973  :   buffer = (*cinfo.mem->alloc_sarray)
; 974  : 		((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

  000d6	53		 push	 ebx
  000d7	56		 push	 esi
  000d8	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000de	53		 push	 ebx
  000df	50		 push	 eax
  000e0	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+4]
  000e6	ff 50 08	 call	 DWORD PTR [eax+8]
  000e9	83 c4 1c	 add	 esp, 28			; 0000001cH

; 975  : 
; 976  : 	int line = 0;
; 977  : 	if (bGray) 

  000ec	83 bd 90 fe ff
	ff 00		 cmp	 DWORD PTR _bGray$[ebp], 0
  000f3	8b f8		 mov	 edi, eax

; 978  : 	{
; 979  : 		while (cinfo.next_scanline < cinfo.image_height) 

  000f5	8b 45 d8	 mov	 eax, DWORD PTR _cinfo$[ebp+192]
  000f8	0f 85 ab 00 00
	00		 jne	 $L109590

; 986  : 	{
; 987  : 		while (cinfo.next_scanline < cinfo.image_height) 

  000fe	3b 85 34 ff ff
	ff		 cmp	 eax, DWORD PTR _cinfo$[ebp+28]
  00104	73 4c		 jae	 SHORT $L108868
  00106	8b 5d 7c	 mov	 ebx, DWORD PTR _p_data$[ebp]
  00109	43		 inc	 ebx
$L108867:

; 988  : 		{
; 989  : 			for(i=0 ; i<row_stride ; i+=3)

  0010a	33 c0		 xor	 eax, eax
  0010c	85 f6		 test	 esi, esi
  0010e	7e 23		 jle	 SHORT $L108871
$L108869:

; 990  : 			{
; 991  : 				buffer[0][i] = p_data[line*row_stride+i+2];

  00110	8a 54 03 01	 mov	 dl, BYTE PTR [ebx+eax+1]
  00114	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00116	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 992  : 				buffer[0][i+1] = p_data[line*row_stride+i+1];

  00119	8a 14 03	 mov	 dl, BYTE PTR [ebx+eax]
  0011c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0011e	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 993  : 				buffer[0][i+2] = p_data[line*row_stride+i+0];

  00122	8a 54 03 ff	 mov	 dl, BYTE PTR [ebx+eax-1]
  00126	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00128	88 54 01 02	 mov	 BYTE PTR [ecx+eax+2], dl
  0012c	83 c0 03	 add	 eax, 3
  0012f	3b c6		 cmp	 eax, esi
  00131	7c dd		 jl	 SHORT $L108869
$L108871:

; 994  : 			}
; 995  : 			line++;
; 996  : 			(void) jpeg_write_scanlines(&cinfo, buffer, 1);

  00133	6a 01		 push	 1
  00135	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0013b	57		 push	 edi
  0013c	50		 push	 eax
  0013d	03 de		 add	 ebx, esi
  0013f	e8 00 00 00 00	 call	 _jpeg_write_scanlines
  00144	8b 45 d8	 mov	 eax, DWORD PTR _cinfo$[ebp+192]
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014a	3b 85 34 ff ff
	ff		 cmp	 eax, DWORD PTR _cinfo$[ebp+28]
  00150	72 b8		 jb	 SHORT $L108867
$L108868:

; 997  : 		}
; 998  : 	 
; 999  :   }
; 1000 : 
; 1001 :   /* Step 6: Finish compression */
; 1002 : 
; 1003 :   jpeg_finish_compress(&cinfo);

  00152	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 _jpeg_finish_compress

; 1004 :   /* After finish_compress, we can close the output file. */
; 1005 :   fclose(outfile);

  0015e	ff b5 8c fe ff
	ff		 push	 DWORD PTR _outfile$[ebp]
  00164	e8 00 00 00 00	 call	 _fclose

; 1006 : 
; 1007 :   /* Step 7: release JPEG compression object */
; 1008 :   /* This is an important step since it will release a good deal of memory. */
; 1009 :   jpeg_destroy_compress(&cinfo);

  00169	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 _jpeg_destroy_compress
  00175	83 c4 0c	 add	 esp, 12			; 0000000cH
  00178	5f		 pop	 edi
  00179	5e		 pop	 esi

; 1010 : 
; 1011 : 	/* And we're done! */
; 1012 :   return TRUE;

  0017a	b0 01		 mov	 al, 1
  0017c	5b		 pop	 ebx
$L108846:

; 1013 : }

  0017d	8b 4d 60	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00180	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00185	83 c5 64	 add	 ebp, 100		; 00000064H
  00188	c9		 leave
  00189	c3		 ret	 0
$L108862:

; 980  : 		{
; 981  : 			memcpy(buffer[0], p_data+line*row_stride, row_stride);

  0018a	56		 push	 esi
  0018b	ff 75 7c	 push	 DWORD PTR _p_data$[ebp]
  0018e	ff 37		 push	 DWORD PTR [edi]
  00190	e8 00 00 00 00	 call	 _memcpy

; 982  : 			(void) jpeg_write_scanlines(&cinfo, buffer, 1);

  00195	53		 push	 ebx
  00196	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0019c	57		 push	 edi
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 _jpeg_write_scanlines
  001a3	8b 45 d8	 mov	 eax, DWORD PTR _cinfo$[ebp+192]
  001a6	83 c4 18	 add	 esp, 24			; 00000018H
$L109590:

; 978  : 	{
; 979  : 		while (cinfo.next_scanline < cinfo.image_height) 

  001a9	3b 85 34 ff ff
	ff		 cmp	 eax, DWORD PTR _cinfo$[ebp+28]
  001af	72 d9		 jb	 SHORT $L108862

; 983  : 		}
; 984  : 	}
; 985  : 	else

  001b1	eb 9f		 jmp	 SHORT $L108868
?SaveJPG@@YA_NPBDAAH11PAE@Z ENDP			; SaveJPG
_TEXT	ENDS
PUBLIC	?GetDiskFreeSpaceA@@YAKPBD@Z			; GetDiskFreeSpaceA
EXTRN	__imp__GetDiskFreeSpaceA@20:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?GetDiskFreeSpaceA@@YAKPBD@Z
_TEXT	SEGMENT
_dwTotalNumberOfClusters$ = -16				; size = 4
_dwNumberOfFreeClusters$ = -12				; size = 4
_dwBytesPerSector$ = -8					; size = 4
_dwSectorsPerCluster$ = -4				; size = 4
_pDrive$ = 8						; size = 4
?GetDiskFreeSpaceA@@YAKPBD@Z PROC NEAR			; GetDiskFreeSpaceA, COMDAT

; 1023 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1024 : 	DWORD dwSectorsPerCluster;
; 1025 : 	DWORD dwBytesPerSector;
; 1026 : 	DWORD dwNumberOfFreeClusters;
; 1027 : 	DWORD dwTotalNumberOfClusters;
; 1028 : 
; 1029 : 	GetDiskFreeSpace(pDrive,
; 1030 : 						&dwSectorsPerCluster, 
; 1031 : 						&dwBytesPerSector, 
; 1032 : 						&dwNumberOfFreeClusters, 
; 1033 : 						&dwTotalNumberOfClusters);

  00006	8d 45 f0	 lea	 eax, DWORD PTR _dwTotalNumberOfClusters$[ebp]
  00009	50		 push	 eax
  0000a	8d 45 f4	 lea	 eax, DWORD PTR _dwNumberOfFreeClusters$[ebp]
  0000d	50		 push	 eax
  0000e	8d 45 f8	 lea	 eax, DWORD PTR _dwBytesPerSector$[ebp]
  00011	50		 push	 eax
  00012	8d 45 fc	 lea	 eax, DWORD PTR _dwSectorsPerCluster$[ebp]
  00015	50		 push	 eax
  00016	ff 75 08	 push	 DWORD PTR _pDrive$[ebp]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDiskFreeSpaceA@20

; 1034 : 
; 1035 : 	DWORD bytesPerCluster = dwSectorsPerCluster * dwBytesPerSector;
; 1036 : 	DWORD freeBytes = dwNumberOfFreeClusters * bytesPerCluster;
; 1037 : 	//DWORD totalBytes = dwTotalNumberOfClusters * bytesPerCluster;
; 1038 : 
; 1039 : 	return freeBytes;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _dwSectorsPerCluster$[ebp]
  00022	0f af 45 f8	 imul	 eax, DWORD PTR _dwBytesPerSector$[ebp]
  00026	0f af 45 f4	 imul	 eax, DWORD PTR _dwNumberOfFreeClusters$[ebp]

; 1040 : }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?GetDiskFreeSpaceA@@YAKPBD@Z ENDP			; GetDiskFreeSpaceA
_TEXT	ENDS
PUBLIC	?LoadImageToSurface@@YA_NPBDAAVCDirectDrawSurface@@@Z ; LoadImageToSurface
PUBLIC	??_C@_04LJDDIHIK@?4bmp?$AA@			; `string'
PUBLIC	??_C@_04GNPKBLNA@?4jpg?$AA@			; `string'
PUBLIC	??_C@_04OFMADDDJ@jpeg?$AA@			; `string'
EXTRN	__strlwr:NEAR
EXTRN	_strncmp:NEAR
EXTRN	?InitOffsurface@CDirectDrawSurface@@QAE_NHHK@Z:NEAR ; CDirectDrawSurface::InitOffsurface
EXTRN	?InitFromBMP@CDirectDrawSurface@@QAE_NPBDK@Z:NEAR ; CDirectDrawSurface::InitFromBMP
EXTRN	?Lock@CDirectDrawSurface@@QAE_NXZ:NEAR		; CDirectDrawSurface::Lock
EXTRN	?Unlock@CDirectDrawSurface@@QAE_NXZ:NEAR	; CDirectDrawSurface::Unlock
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
;	COMDAT ??_C@_04LJDDIHIK@?4bmp?$AA@
; File c:\darkeden\designed_common\project\client\cdirectdrawsurface.h
CONST	SEGMENT
??_C@_04LJDDIHIK@?4bmp?$AA@ DB '.bmp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GNPKBLNA@?4jpg?$AA@
CONST	SEGMENT
??_C@_04GNPKBLNA@?4jpg?$AA@ DB '.jpg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFMADDDJ@jpeg?$AA@
CONST	SEGMENT
??_C@_04OFMADDDJ@jpeg?$AA@ DB 'jpeg', 00H		; `string'
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\utilityfunction.cpp
CONST	ENDS
;	COMDAT ?LoadImageToSurface@@YA_NPBDAAVCDirectDrawSurface@@@Z
_TEXT	SEGMENT
_surfacePitch$107972 = -56				; size = 4
_pitch$107962 = -52					; size = 4
_pSurface$107967 = -48					; size = 4
_p_data$107960 = -44					; size = 4
_pData$107969 = -40					; size = 4
_bpp$107959 = -36					; size = 4
_y$107991 = -32						; size = 4
_y$107975 = -32						; size = 4
_height$107958 = -28					; size = 4
_width$107957 = -24					; size = 4
_g$108000 = -18						; size = 1
_r$107984 = -18						; size = 1
_r$107999 = -17						; size = 1
_g$107985 = -17						; size = 1
_bJpg$ = -17						; size = 1
_checkStr$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pFilename$ = 8						; size = 4
_b$108001 = 11						; size = 1
_b$107986 = 11						; size = 1
_bOK$ = 11						; size = 1
_surface$ = 12						; size = 4
?LoadImageToSurface@@YA_NPBDAAVCDirectDrawSurface@@@Z PROC NEAR ; LoadImageToSurface, COMDAT

; 446  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	57		 push	 edi

; 447  : 	if (pFilename==NULL)

  0000c	8b 7d 08	 mov	 edi, DWORD PTR _pFilename$[ebp]
  0000f	85 ff		 test	 edi, edi
  00011	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 448  : 	{
; 449  : 		return false;

  00014	74 0c		 je	 SHORT $L109622

; 450  : 	}
; 451  : 
; 452  : 	int fileLen = strlen(pFilename);

  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 _strlen

; 453  : 
; 454  : 	// file이름이 넘 짧은 경우... strlen("이름.bmp")==8
; 455  : 	if (fileLen < 8)

  0001c	83 f8 08	 cmp	 eax, 8
  0001f	59		 pop	 ecx
  00020	7d 07		 jge	 SHORT $L107936
$L109622:

; 456  : 	{
; 457  : 		return false;

  00022	32 c0		 xor	 al, al
  00024	e9 66 02 00 00	 jmp	 $L107933
$L107936:
  00029	53		 push	 ebx

; 458  : 	}
; 459  : 
; 460  : 	// file이름이 이상한 경우
; 461  : 	char checkStr[10];
; 462  : 	strcpy(checkStr, (pFilename+fileLen-4));

  0002a	8d 44 38 fc	 lea	 eax, DWORD PTR [eax+edi-4]
  0002e	56		 push	 esi
  0002f	50		 push	 eax
  00030	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _strcpy

; 463  : 	strcpy(checkStr, _strlwr(checkStr));

  00039	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 __strlwr
  00042	50		 push	 eax
  00043	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _strcpy

; 464  : 
; 465  : 	bool bBmp = false;
; 466  : 	bool bJpg = false;
; 467  : 
; 468  : 	// 확장자 체크를 위해 lowercase
; 469  : 	for(int kkk = 0; kkk < strlen(checkStr); kkk++)

  0004c	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  0004f	32 db		 xor	 bl, bl
  00051	50		 push	 eax
  00052	88 5d ef	 mov	 BYTE PTR _bJpg$[ebp], bl
  00055	33 f6		 xor	 esi, esi
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	83 c4 18	 add	 esp, 24			; 00000018H
  0005f	85 c0		 test	 eax, eax
  00061	76 21		 jbe	 SHORT $L107943
$L107941:

; 470  : 		if(checkStr[kkk] >= 'A' && checkStr[kkk] <= 'Z')

  00063	8d 4c 35 f0	 lea	 ecx, DWORD PTR _checkStr$[ebp+esi]
  00067	8a 01		 mov	 al, BYTE PTR [ecx]
  00069	3c 41		 cmp	 al, 65			; 00000041H
  0006b	7c 08		 jl	 SHORT $L107942
  0006d	3c 5a		 cmp	 al, 90			; 0000005aH
  0006f	7f 04		 jg	 SHORT $L107942

; 471  : 			checkStr[kkk] += 'a' - 'A';

  00071	04 20		 add	 al, 32			; 00000020H
  00073	88 01		 mov	 BYTE PTR [ecx], al
$L107942:
  00075	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  00078	50		 push	 eax
  00079	46		 inc	 esi
  0007a	e8 00 00 00 00	 call	 _strlen
  0007f	3b f0		 cmp	 esi, eax
  00081	59		 pop	 ecx
  00082	72 df		 jb	 SHORT $L107941
$L107943:

; 472  : 
; 473  : 	// 확장자 체크..
; 474  : 	if(!strncmp(".bmp", checkStr, 4))

  00084	6a 04		 push	 4
  00086	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  00089	50		 push	 eax
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04LJDDIHIK@?4bmp?$AA@
  0008f	e8 00 00 00 00	 call	 _strncmp
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
  00097	85 c0		 test	 eax, eax
  00099	75 04		 jne	 SHORT $L107945

; 475  : 	{
; 476  : 		bBmp = true;

  0009b	b3 01		 mov	 bl, 1

; 477  : 	}
; 478  : 	else if(!strncmp(".jpg", checkStr, 4)

  0009d	eb 32		 jmp	 SHORT $L107952
$L107945:

; 479  : 			|| !strncmp("jpeg", checkStr, 4))

  0009f	6a 04		 push	 4
  000a1	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  000a4	50		 push	 eax
  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04GNPKBLNA@?4jpg?$AA@
  000aa	e8 00 00 00 00	 call	 _strncmp
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b2	85 c0		 test	 eax, eax
  000b4	74 17		 je	 SHORT $L107949
  000b6	6a 04		 push	 4
  000b8	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  000bb	50		 push	 eax
  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OFMADDDJ@jpeg?$AA@
  000c1	e8 00 00 00 00	 call	 _strncmp
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	85 c0		 test	 eax, eax

; 482  : 	}
; 483  : 	else 
; 484  : 	{
; 485  : 		return false;

  000cb	75 57		 jne	 SHORT $L109621
$L107949:

; 480  : 	{
; 481  : 		bJpg = true;

  000cd	c6 45 ef 01	 mov	 BYTE PTR _bJpg$[ebp], 1
$L107952:

; 486  : 	}
; 487  : 
; 488  : 	bool bOK = false;
; 489  : 
; 490  : 	if (bBmp)

  000d1	84 db		 test	 bl, bl
  000d3	c6 45 0b 00	 mov	 BYTE PTR _bOK$[ebp], 0
  000d7	74 16		 je	 SHORT $L107954

; 491  : 	{
; 492  : 		bOK = surface.InitFromBMP(pFilename, DDSCAPS_SYSTEMMEMORY);

  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR _surface$[ebp]
  000dc	68 00 08 00 00	 push	 2048			; 00000800H
  000e1	57		 push	 edi
  000e2	e8 00 00 00 00	 call	 ?InitFromBMP@CDirectDrawSurface@@QAE_NPBDK@Z ; CDirectDrawSurface::InitFromBMP
  000e7	88 45 0b	 mov	 BYTE PTR _bOK$[ebp], al

; 493  : 	}
; 494  : 	else if (bJpg)

  000ea	e9 9b 01 00 00	 jmp	 $L109617
$L107954:
  000ef	80 7d ef 00	 cmp	 BYTE PTR _bJpg$[ebp], 0
  000f3	0f 84 91 01 00
	00		 je	 $L109617

; 495  : 	{
; 496  : 		int width = 0, height = 0, bpp = 0;
; 497  : 		unsigned char* p_data = NULL;
; 498  : 		
; 499  : 		if (!LoadJPG(pFilename, width, height, bpp, &p_data))

  000f9	8d 45 d4	 lea	 eax, DWORD PTR _p_data$107960[ebp]
  000fc	50		 push	 eax
  000fd	8d 45 dc	 lea	 eax, DWORD PTR _bpp$107959[ebp]
  00100	50		 push	 eax
  00101	8d 45 e4	 lea	 eax, DWORD PTR _height$107958[ebp]
  00104	50		 push	 eax
  00105	8d 45 e8	 lea	 eax, DWORD PTR _width$107957[ebp]
  00108	33 db		 xor	 ebx, ebx
  0010a	50		 push	 eax
  0010b	57		 push	 edi
  0010c	89 5d e8	 mov	 DWORD PTR _width$107957[ebp], ebx
  0010f	89 5d e4	 mov	 DWORD PTR _height$107958[ebp], ebx
  00112	89 5d dc	 mov	 DWORD PTR _bpp$107959[ebp], ebx
  00115	89 5d d4	 mov	 DWORD PTR _p_data$107960[ebp], ebx
  00118	e8 00 00 00 00	 call	 ?LoadJPG@@YA_NPBDAAH11PAPAE@Z ; LoadJPG
  0011d	83 c4 14	 add	 esp, 20			; 00000014H
  00120	84 c0		 test	 al, al
  00122	75 07		 jne	 SHORT $L107961
$L109621:

; 500  : 		{
; 501  : 			return false;

  00124	32 c0		 xor	 al, al
  00126	e9 62 01 00 00	 jmp	 $L109619
$L107961:

; 502  : 		}
; 503  : 
; 504  : 		int pitch = width*bpp;

  0012b	8b 45 dc	 mov	 eax, DWORD PTR _bpp$107959[ebp]
  0012e	0f af 45 e8	 imul	 eax, DWORD PTR _width$107957[ebp]

; 505  : 
; 506  : 		int green_shift = 0;
; 507  : 
; 508  : 		if (width > 0 && height > 0 && bpp > 0)

  00132	39 5d e8	 cmp	 DWORD PTR _width$107957[ebp], ebx
  00135	89 45 cc	 mov	 DWORD PTR _pitch$107962[ebp], eax
  00138	0f 8e 3e 01 00
	00		 jle	 $L107966
  0013e	39 5d e4	 cmp	 DWORD PTR _height$107958[ebp], ebx
  00141	0f 8e 35 01 00
	00		 jle	 $L107966
  00147	39 5d dc	 cmp	 DWORD PTR _bpp$107959[ebp], ebx
  0014a	0f 8e 2c 01 00
	00		 jle	 $L107966

; 509  : 		{
; 510  : 			if (surface.InitOffsurface(width, height, DDSCAPS_SYSTEMMEMORY))

  00150	8b 4d 0c	 mov	 ecx, DWORD PTR _surface$[ebp]
  00153	68 00 08 00 00	 push	 2048			; 00000800H
  00158	ff 75 e4	 push	 DWORD PTR _height$107958[ebp]
  0015b	ff 75 e8	 push	 DWORD PTR _width$107957[ebp]
  0015e	e8 00 00 00 00	 call	 ?InitOffsurface@CDirectDrawSurface@@QAE_NHHK@Z ; CDirectDrawSurface::InitOffsurface
  00163	84 c0		 test	 al, al
  00165	0f 84 11 01 00
	00		 je	 $L107966

; 511  : 			{
; 512  : 				if (surface.Lock())

  0016b	8b 4d 0c	 mov	 ecx, DWORD PTR _surface$[ebp]
  0016e	e8 00 00 00 00	 call	 ?Lock@CDirectDrawSurface@@QAE_NXZ ; CDirectDrawSurface::Lock
  00173	84 c0		 test	 al, al
  00175	0f 84 01 01 00
	00		 je	 $L107966

; 513  : 				{
; 514  : 					WORD *pSurface = (WORD *)surface.GetSurfacePointer();

  0017b	8b 3d 24 00 00
	00		 mov	 edi, DWORD PTR ?m_ddsd@CDirectDraw@@1U_DDSURFACEDESC2@@A+36

; 515  : 					unsigned char *pData = p_data, *pDataTemp;
; 516  : 					WORD *pSurfaceTemp;
; 517  : 
; 518  : 					int surfacePitch = surface.GetSurfacePitch();
; 519  : 
; 520  : 					if (pSurface)

  00181	3b fb		 cmp	 edi, ebx
  00183	8b 75 d4	 mov	 esi, DWORD PTR _p_data$107960[ebp]
  00186	a1 10 00 00 00	 mov	 eax, DWORD PTR ?m_ddsd@CDirectDraw@@1U_DDSURFACEDESC2@@A+16
  0018b	89 7d d0	 mov	 DWORD PTR _pSurface$107967[ebp], edi
  0018e	89 75 d8	 mov	 DWORD PTR _pData$107969[ebp], esi
  00191	89 45 c8	 mov	 DWORD PTR _surfacePitch$107972[ebp], eax
  00194	0f 84 da 00 00
	00		 je	 $L107973

; 521  : 					{
; 522  : 						if (bpp == 1)

  0019a	83 7d dc 01	 cmp	 DWORD PTR _bpp$107959[ebp], 1
  0019e	75 61		 jne	 SHORT $L107974

; 523  : 						{
; 524  : 							for (register int y = 0; y < height; y++)

  001a0	39 5d e4	 cmp	 DWORD PTR _height$107958[ebp], ebx
  001a3	89 5d e0	 mov	 DWORD PTR _y$107975[ebp], ebx
  001a6	0f 8e c4 00 00
	00		 jle	 $L107994
$L107976:

; 525  : 							{
; 526  : 								pDataTemp = pData;
; 527  : 								pSurfaceTemp = pSurface;								
; 528  : 
; 529  : 								for (register int x = 0; x < width; x++)

  001ac	83 7d e8 00	 cmp	 DWORD PTR _width$107957[ebp], 0
  001b0	7e 2e		 jle	 SHORT $L107982
$L107980:

; 530  : 								{
; 531  : 									BYTE temp_data = *pDataTemp++;	//p_data[y*(pitch)+x];

  001b2	8a 06		 mov	 al, BYTE PTR [esi]

; 532  : 									BYTE r = temp_data>>3;

  001b4	c0 e8 03	 shr	 al, 3
  001b7	88 45 ee	 mov	 BYTE PTR _r$107984[ebp], al

; 533  : 									BYTE g = r;

  001ba	88 45 ef	 mov	 BYTE PTR _g$107985[ebp], al

; 534  : 									BYTE b = r;

  001bd	88 45 0b	 mov	 BYTE PTR _b$107986[ebp], al

; 535  : 
; 536  : 									*pSurfaceTemp++ = CDirectDraw::Color(r, g, b);

  001c0	8d 45 0b	 lea	 eax, DWORD PTR _b$107986[ebp]
  001c3	50		 push	 eax
  001c4	8d 45 ef	 lea	 eax, DWORD PTR _g$107985[ebp]
  001c7	50		 push	 eax
  001c8	8d 45 ee	 lea	 eax, DWORD PTR _r$107984[ebp]
  001cb	50		 push	 eax
  001cc	46		 inc	 esi
  001cd	e8 00 00 00 00	 call	 ?Color@CDirectDraw@@SAGABE00@Z ; CDirectDraw::Color
  001d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d5	66 89 07	 mov	 WORD PTR [edi], ax
  001d8	47		 inc	 edi
  001d9	47		 inc	 edi
  001da	43		 inc	 ebx
  001db	3b 5d e8	 cmp	 ebx, DWORD PTR _width$107957[ebp]
  001de	7c d2		 jl	 SHORT $L107980
$L107982:

; 537  : 								}
; 538  : 
; 539  : 								pData = pData + pitch;

  001e0	8b 75 d8	 mov	 esi, DWORD PTR _pData$107969[ebp]

; 540  : 								pSurface = (WORD*)((BYTE*)pSurface + surfacePitch);

  001e3	8b 7d d0	 mov	 edi, DWORD PTR _pSurface$107967[ebp]
  001e6	03 75 cc	 add	 esi, DWORD PTR _pitch$107962[ebp]
  001e9	03 7d c8	 add	 edi, DWORD PTR _surfacePitch$107972[ebp]
  001ec	ff 45 e0	 inc	 DWORD PTR _y$107975[ebp]
  001ef	8b 45 e0	 mov	 eax, DWORD PTR _y$107975[ebp]

; 541  : 							}
; 542  : 						}
; 543  : 						else if (bpp == 3)

  001f2	33 db		 xor	 ebx, ebx
  001f4	3b 45 e4	 cmp	 eax, DWORD PTR _height$107958[ebp]
  001f7	89 75 d8	 mov	 DWORD PTR _pData$107969[ebp], esi
  001fa	89 7d d0	 mov	 DWORD PTR _pSurface$107967[ebp], edi
  001fd	7c ad		 jl	 SHORT $L107976
  001ff	eb 6f		 jmp	 SHORT $L107994
$L107974:
  00201	83 7d dc 03	 cmp	 DWORD PTR _bpp$107959[ebp], 3
  00205	75 69		 jne	 SHORT $L107994

; 544  : 						{
; 545  : 							for (register int y = 0; y < height; y++)

  00207	39 5d e4	 cmp	 DWORD PTR _height$107958[ebp], ebx
  0020a	89 5d e0	 mov	 DWORD PTR _y$107991[ebp], ebx
  0020d	7e 61		 jle	 SHORT $L107994
$L107992:

; 546  : 							{
; 547  : 								pDataTemp = pData;
; 548  : 								pSurfaceTemp = pSurface;	
; 549  : 
; 550  : 								for (register int x = 0; x < width; x++)

  0020f	83 7d e8 00	 cmp	 DWORD PTR _width$107957[ebp], 0
  00213	7e 3c		 jle	 SHORT $L107998
$L109614:

; 551  : 								{
; 552  : 									//char *temp_data = &p_data[y*pitch+x*bpp];
; 553  : 									BYTE r = *(pDataTemp+2) >> 3;		//temp_data[2]>>3;

  00215	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  00218	c0 e8 03	 shr	 al, 3
  0021b	88 45 ef	 mov	 BYTE PTR _r$107999[ebp], al

; 554  : 									BYTE g = *(pDataTemp+1) >> 3;	//temp_data[1]>>3;

  0021e	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  00221	c0 e8 03	 shr	 al, 3
  00224	88 45 ee	 mov	 BYTE PTR _g$108000[ebp], al

; 555  : 									BYTE b = *pDataTemp >> 3;	//temp_data[0]>>3;

  00227	8a 06		 mov	 al, BYTE PTR [esi]

; 556  : 
; 557  : 									pDataTemp += bpp;

  00229	03 75 dc	 add	 esi, DWORD PTR _bpp$107959[ebp]
  0022c	c0 e8 03	 shr	 al, 3
  0022f	88 45 0b	 mov	 BYTE PTR _b$108001[ebp], al

; 558  : 
; 559  : 									*pSurfaceTemp++ = CDirectDraw::Color(r, g, b);

  00232	8d 45 0b	 lea	 eax, DWORD PTR _b$108001[ebp]
  00235	50		 push	 eax
  00236	8d 45 ee	 lea	 eax, DWORD PTR _g$108000[ebp]
  00239	50		 push	 eax
  0023a	8d 45 ef	 lea	 eax, DWORD PTR _r$107999[ebp]
  0023d	50		 push	 eax
  0023e	e8 00 00 00 00	 call	 ?Color@CDirectDraw@@SAGABE00@Z ; CDirectDraw::Color
  00243	83 c4 0c	 add	 esp, 12			; 0000000cH
  00246	66 89 07	 mov	 WORD PTR [edi], ax
  00249	47		 inc	 edi
  0024a	47		 inc	 edi
  0024b	43		 inc	 ebx
  0024c	3b 5d e8	 cmp	 ebx, DWORD PTR _width$107957[ebp]
  0024f	7c c4		 jl	 SHORT $L109614
$L107998:

; 560  : 								}
; 561  : 
; 562  : 								pData = pData + pitch;

  00251	8b 75 d8	 mov	 esi, DWORD PTR _pData$107969[ebp]

; 563  : 								pSurface = (WORD*)((BYTE*)pSurface + surfacePitch);

  00254	8b 7d d0	 mov	 edi, DWORD PTR _pSurface$107967[ebp]
  00257	03 75 cc	 add	 esi, DWORD PTR _pitch$107962[ebp]
  0025a	03 7d c8	 add	 edi, DWORD PTR _surfacePitch$107972[ebp]
  0025d	ff 45 e0	 inc	 DWORD PTR _y$107991[ebp]
  00260	8b 45 e0	 mov	 eax, DWORD PTR _y$107991[ebp]
  00263	33 db		 xor	 ebx, ebx
  00265	3b 45 e4	 cmp	 eax, DWORD PTR _height$107958[ebp]
  00268	89 75 d8	 mov	 DWORD PTR _pData$107969[ebp], esi
  0026b	89 7d d0	 mov	 DWORD PTR _pSurface$107967[ebp], edi
  0026e	7c 9f		 jl	 SHORT $L107992
$L107994:

; 564  : 							}
; 565  : 						}
; 566  : 
; 567  : 						bOK = true;

  00270	c6 45 0b 01	 mov	 BYTE PTR _bOK$[ebp], 1
$L107973:

; 568  : 					}
; 569  : 
; 570  : 					surface.Unlock();

  00274	8b 4d 0c	 mov	 ecx, DWORD PTR _surface$[ebp]
  00277	e8 00 00 00 00	 call	 ?Unlock@CDirectDrawSurface@@QAE_NXZ ; CDirectDrawSurface::Unlock
$L107966:

; 571  : 				}
; 572  : 			}			
; 573  : 		}
; 574  : 		
; 575  : 		if (p_data!=NULL)

  0027c	39 5d d4	 cmp	 DWORD PTR _p_data$107960[ebp], ebx
  0027f	74 09		 je	 SHORT $L109617

; 576  : 		{
; 577  : 			delete [] p_data;

  00281	ff 75 d4	 push	 DWORD PTR _p_data$107960[ebp]
  00284	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00289	59		 pop	 ecx
$L109617:

; 578  : 		}
; 579  : 	}
; 580  : 
; 581  : 	return bOK;

  0028a	8a 45 0b	 mov	 al, BYTE PTR _bOK$[ebp]
$L109619:
  0028d	5e		 pop	 esi
  0028e	5b		 pop	 ebx
$L107933:

; 582  : }

  0028f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00292	5f		 pop	 edi
  00293	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00298	c9		 leave
  00299	c3		 ret	 0
?LoadImageToSurface@@YA_NPBDAAVCDirectDrawSurface@@@Z ENDP ; LoadImageToSurface
_TEXT	ENDS
PUBLIC	?SaveSurfaceToImage@@YA_NPBDAAVCDirectDrawSurface@@@Z ; SaveSurfaceToImage
EXTRN	?Get_BPP@CDirectDraw@@SAKXZ:NEAR		; CDirectDraw::Get_BPP
EXTRN	?SaveToBMP@CDirectDrawSurface@@QAE_NPBD@Z:NEAR	; CDirectDrawSurface::SaveToBMP
; Function compile flags: /Ogsy
;	COMDAT ?SaveSurfaceToImage@@YA_NPBDAAVCDirectDrawSurface@@@Z
_TEXT	SEGMENT
_out_bpp$108033 = -44					; size = 4
_height$108031 = -40					; size = 4
_width$108030 = -36					; size = 4
tv148 = -32						; size = 4
_p_data$108038 = -28					; size = 4
_pSurfacePoint$108036 = -24				; size = 4
_bJpg$ = -18						; size = 1
_bOK$ = -17						; size = 1
_checkStr$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pFilename$ = 8						; size = 4
_surface$ = 12						; size = 4
?SaveSurfaceToImage@@YA_NPBDAAVCDirectDrawSurface@@@Z PROC NEAR ; SaveSurfaceToImage, COMDAT

; 591  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	57		 push	 edi

; 592  : 	if (pFilename==NULL)

  0000c	8b 7d 08	 mov	 edi, DWORD PTR _pFilename$[ebp]
  0000f	85 ff		 test	 edi, edi
  00011	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 593  : 	{
; 594  : 		return false;

  00014	74 0c		 je	 SHORT $L109665

; 595  : 	}
; 596  : 
; 597  : 	int fileLen = strlen(pFilename);

  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 _strlen

; 598  : 
; 599  : 	// file이름이 넘 짧은 경우... strlen("이름.bmp")==8
; 600  : 	if (fileLen < 8)

  0001c	83 f8 08	 cmp	 eax, 8
  0001f	59		 pop	 ecx
  00020	7d 07		 jge	 SHORT $L108012
$L109665:

; 601  : 	{
; 602  : 		return false;

  00022	32 c0		 xor	 al, al
  00024	e9 bd 01 00 00	 jmp	 $L108009
$L108012:
  00029	53		 push	 ebx

; 603  : 	}
; 604  : 
; 605  : 	// file이름이 이상한 경우
; 606  : 	char checkStr[10];
; 607  : 	strcpy(checkStr, (pFilename+fileLen-4));

  0002a	8d 44 38 fc	 lea	 eax, DWORD PTR [eax+edi-4]
  0002e	56		 push	 esi
  0002f	50		 push	 eax
  00030	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _strcpy

; 608  : 	strcpy(checkStr, _strlwr(checkStr));

  00039	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 __strlwr
  00042	50		 push	 eax
  00043	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _strcpy

; 609  : 
; 610  : 	bool bBmp = false;
; 611  : 	bool bJpg = false;
; 612  : 
; 613  : 	// 확장자 체크를 위해 lowercase
; 614  : 	for(int kkk = 0; kkk < strlen(checkStr); kkk++)

  0004c	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  0004f	32 db		 xor	 bl, bl
  00051	50		 push	 eax
  00052	88 5d ee	 mov	 BYTE PTR _bJpg$[ebp], bl
  00055	33 f6		 xor	 esi, esi
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	83 c4 18	 add	 esp, 24			; 00000018H
  0005f	85 c0		 test	 eax, eax
  00061	76 21		 jbe	 SHORT $L108019
$L108017:

; 615  : 		if(checkStr[kkk] >= 'A' && checkStr[kkk] <= 'Z')

  00063	8d 4c 35 f0	 lea	 ecx, DWORD PTR _checkStr$[ebp+esi]
  00067	8a 01		 mov	 al, BYTE PTR [ecx]
  00069	3c 41		 cmp	 al, 65			; 00000041H
  0006b	7c 08		 jl	 SHORT $L108018
  0006d	3c 5a		 cmp	 al, 90			; 0000005aH
  0006f	7f 04		 jg	 SHORT $L108018

; 616  : 			checkStr[kkk] += 'a' - 'A';

  00071	04 20		 add	 al, 32			; 00000020H
  00073	88 01		 mov	 BYTE PTR [ecx], al
$L108018:
  00075	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  00078	50		 push	 eax
  00079	46		 inc	 esi
  0007a	e8 00 00 00 00	 call	 _strlen
  0007f	3b f0		 cmp	 esi, eax
  00081	59		 pop	 ecx
  00082	72 df		 jb	 SHORT $L108017
$L108019:

; 617  : 
; 618  : 	// 확장자 체크..
; 619  : 	if(!strncmp(".bmp", checkStr, 4))

  00084	6a 04		 push	 4
  00086	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  00089	50		 push	 eax
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04LJDDIHIK@?4bmp?$AA@
  0008f	e8 00 00 00 00	 call	 _strncmp
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
  00097	85 c0		 test	 eax, eax
  00099	75 04		 jne	 SHORT $L108021

; 620  : 	{
; 621  : 		bBmp = true;

  0009b	b3 01		 mov	 bl, 1

; 622  : 	}
; 623  : 	else if(!strncmp(".jpg", checkStr, 4)

  0009d	eb 36		 jmp	 SHORT $L108025
$L108021:

; 624  : 			|| !strncmp("jpeg", checkStr, 4))

  0009f	6a 04		 push	 4
  000a1	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  000a4	50		 push	 eax
  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04GNPKBLNA@?4jpg?$AA@
  000aa	e8 00 00 00 00	 call	 _strncmp
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b2	85 c0		 test	 eax, eax
  000b4	74 1b		 je	 SHORT $L108024
  000b6	6a 04		 push	 4
  000b8	8d 45 f0	 lea	 eax, DWORD PTR _checkStr$[ebp]
  000bb	50		 push	 eax
  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OFMADDDJ@jpeg?$AA@
  000c1	e8 00 00 00 00	 call	 _strncmp
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	85 c0		 test	 eax, eax

; 627  : 	}
; 628  : 	else 
; 629  : 	{
; 630  : 		return false;

  000cb	0f 85 02 01 00
	00		 jne	 $L109664
$L108024:

; 625  : 	{
; 626  : 		bJpg = true;

  000d1	c6 45 ee 01	 mov	 BYTE PTR _bJpg$[ebp], 1
$L108025:

; 631  : 	}
; 632  : 
; 633  : 	bool bOK = false;
; 634  : 
; 635  : 	if (bBmp)

  000d5	84 db		 test	 bl, bl
  000d7	c6 45 ef 00	 mov	 BYTE PTR _bOK$[ebp], 0
  000db	74 11		 je	 SHORT $L108027

; 636  : 	{
; 637  : 		bOK = surface.SaveToBMP(pFilename);

  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR _surface$[ebp]
  000e0	57		 push	 edi
  000e1	e8 00 00 00 00	 call	 ?SaveToBMP@CDirectDrawSurface@@QAE_NPBD@Z ; CDirectDrawSurface::SaveToBMP
  000e6	88 45 ef	 mov	 BYTE PTR _bOK$[ebp], al

; 638  : 	}
; 639  : 	else if (bJpg)

  000e9	e9 f3 00 00 00	 jmp	 $L109659
$L108027:
  000ee	80 7d ee 00	 cmp	 BYTE PTR _bJpg$[ebp], 0
  000f2	0f 84 e9 00 00
	00		 je	 $L109659

; 640  : 	{
; 641  : 		int width = surface.GetWidth(), height = surface.GetHeight(), bpp = surface.Get_BPP();

  000f8	8b 75 0c	 mov	 esi, DWORD PTR _surface$[ebp]
  000fb	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  000fe	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00101	89 5d dc	 mov	 DWORD PTR _width$108030[ebp], ebx
  00104	89 7d d8	 mov	 DWORD PTR _height$108031[ebp], edi
  00107	e8 00 00 00 00	 call	 ?Get_BPP@CDirectDraw@@SAKXZ ; CDirectDraw::Get_BPP

; 642  : 		int out_bpp = 24;
; 643  : 		if(surface.Lock())

  0010c	8b ce		 mov	 ecx, esi
  0010e	c7 45 d4 18 00
	00 00		 mov	 DWORD PTR _out_bpp$108033[ebp], 24 ; 00000018H
  00115	e8 00 00 00 00	 call	 ?Lock@CDirectDrawSurface@@QAE_NXZ ; CDirectDrawSurface::Lock
  0011a	84 c0		 test	 al, al
  0011c	0f 84 bf 00 00
	00		 je	 $L109659

; 644  : 		{
; 645  : 			int surfacePitch = surface.GetSurfacePitch();
; 646  : 
; 647  : 			WORD *pSurfacePoint = (WORD *)surface.GetSurfacePointer();

  00122	a1 24 00 00 00	 mov	 eax, DWORD PTR ?m_ddsd@CDirectDraw@@1U_DDSURFACEDESC2@@A+36
  00127	89 45 e8	 mov	 DWORD PTR _pSurfacePoint$108036[ebp], eax

; 648  : 			BYTE* p_data = new BYTE[width*height*out_bpp/8];

  0012a	8b c7		 mov	 eax, edi
  0012c	0f af c3	 imul	 eax, ebx
  0012f	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00132	c1 e0 03	 shl	 eax, 3
  00135	6a 08		 push	 8
  00137	99		 cdq
  00138	59		 pop	 ecx
  00139	f7 f9		 idiv	 ecx
  0013b	8b 35 10 00 00
	00		 mov	 esi, DWORD PTR ?m_ddsd@CDirectDraw@@1U_DDSURFACEDESC2@@A+16
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 649  : 			BYTE* p_dataTemp = p_data;
; 650  : 
; 651  : 			for (register int y = 0; y < height; y++)

  00147	85 ff		 test	 edi, edi
  00149	8b d8		 mov	 ebx, eax
  0014b	59		 pop	 ecx
  0014c	89 5d e4	 mov	 DWORD PTR _p_data$108038[ebp], ebx
  0014f	7e 53		 jle	 SHORT $L108045
  00151	8b c6		 mov	 eax, esi
  00153	99		 cdq
  00154	2b c2		 sub	 eax, edx
  00156	8b f0		 mov	 esi, eax
  00158	d1 fe		 sar	 esi, 1
  0015a	d1 e6		 shl	 esi, 1
  0015c	89 7d e0	 mov	 DWORD PTR tv148[ebp], edi
$L109660:

; 652  : 			{
; 653  : 				WORD *pSurfacePointTemp = pSurfacePoint;
; 654  : 
; 655  : 				for (register int x = 0; x < width; x++)

  0015f	8b 7d dc	 mov	 edi, DWORD PTR _width$108030[ebp]
  00162	85 ff		 test	 edi, edi
  00164	8b 55 e8	 mov	 edx, DWORD PTR _pSurfacePoint$108036[ebp]
  00167	7e 33		 jle	 SHORT $L108050
$L108048:

; 656  : 				{
; 657  : 					WORD color = *pSurfacePointTemp;
; 658  : 					p_dataTemp[0] = CDirectDraw::Blue(*pSurfacePointTemp)<<3;

  00169	8a 02		 mov	 al, BYTE PTR [edx]
  0016b	c0 e0 03	 shl	 al, 3
  0016e	88 03		 mov	 BYTE PTR [ebx], al

; 659  : 					p_dataTemp[1] = CDirectDraw::Green(*pSurfacePointTemp)<<3;

  00170	66 8b 02	 mov	 ax, WORD PTR [edx]
  00173	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?s_bSHIFT_G@CDirectDraw@@2EA ; CDirectDraw::s_bSHIFT_G
  00179	66 d3 e8	 shr	 ax, cl

; 660  : 					p_dataTemp[2] = CDirectDraw::Red(*pSurfacePointTemp)<<3;
; 661  : 				
; 662  : 					pSurfacePointTemp++;
; 663  : 					p_dataTemp += 3;

  0017c	83 c3 03	 add	 ebx, 3

; 677  : 
; 678  : 		}
; 679  : 
; 680  : 	}
; 681  : 
; 682  : 	return bOK;

  0017f	c0 e0 03	 shl	 al, 3
  00182	88 43 fe	 mov	 BYTE PTR [ebx-2], al
  00185	66 8b 02	 mov	 ax, WORD PTR [edx]
  00188	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?s_bSHIFT_R@CDirectDraw@@2EA ; CDirectDraw::s_bSHIFT_R
  0018e	66 d3 e8	 shr	 ax, cl
  00191	c0 e0 03	 shl	 al, 3
  00194	42		 inc	 edx
  00195	88 43 ff	 mov	 BYTE PTR [ebx-1], al
  00198	42		 inc	 edx
  00199	4f		 dec	 edi
  0019a	75 cd		 jne	 SHORT $L108048
$L108050:

; 664  : 				}
; 665  : 				
; 666  : 				pSurfacePoint += surfacePitch/2;

  0019c	01 75 e8	 add	 DWORD PTR _pSurfacePoint$108036[ebp], esi
  0019f	ff 4d e0	 dec	 DWORD PTR tv148[ebp]
  001a2	75 bb		 jne	 SHORT $L109660
$L108045:

; 667  : 			}
; 668  : 			surface.Unlock();

  001a4	8b 4d 0c	 mov	 ecx, DWORD PTR _surface$[ebp]
  001a7	e8 00 00 00 00	 call	 ?Unlock@CDirectDrawSurface@@QAE_NXZ ; CDirectDrawSurface::Unlock

; 669  : 
; 670  : 			if (!SaveJPG(pFilename, width, height, out_bpp, p_data))

  001ac	ff 75 e4	 push	 DWORD PTR _p_data$108038[ebp]
  001af	8d 45 d4	 lea	 eax, DWORD PTR _out_bpp$108033[ebp]
  001b2	50		 push	 eax
  001b3	8d 45 d8	 lea	 eax, DWORD PTR _height$108031[ebp]
  001b6	50		 push	 eax
  001b7	8d 45 dc	 lea	 eax, DWORD PTR _width$108030[ebp]
  001ba	50		 push	 eax
  001bb	ff 75 08	 push	 DWORD PTR _pFilename$[ebp]
  001be	e8 00 00 00 00	 call	 ?SaveJPG@@YA_NPBDAAH11PAE@Z ; SaveJPG
  001c3	83 c4 14	 add	 esp, 20			; 00000014H
  001c6	84 c0		 test	 al, al

; 671  : 			{
; 672  : 				delete []p_data;

  001c8	ff 75 e4	 push	 DWORD PTR _p_data$108038[ebp]
  001cb	75 0a		 jne	 SHORT $L108052
  001cd	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  001d2	59		 pop	 ecx
$L109664:

; 673  : 				return false;

  001d3	32 c0		 xor	 al, al
  001d5	eb 0d		 jmp	 SHORT $L109662
$L108052:

; 674  : 			}
; 675  : 			bOK = true;

  001d7	c6 45 ef 01	 mov	 BYTE PTR _bOK$[ebp], 1

; 676  : 			delete []p_data;

  001db	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  001e0	59		 pop	 ecx
$L109659:

; 677  : 
; 678  : 		}
; 679  : 
; 680  : 	}
; 681  : 
; 682  : 	return bOK;

  001e1	8a 45 ef	 mov	 al, BYTE PTR _bOK$[ebp]
$L109662:
  001e4	5e		 pop	 esi
  001e5	5b		 pop	 ebx
$L108009:

; 683  : }

  001e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e9	5f		 pop	 edi
  001ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ef	c9		 leave
  001f0	c3		 ret	 0
?SaveSurfaceToImage@@YA_NPBDAAVCDirectDrawSurface@@@Z ENDP ; SaveSurfaceToImage
_TEXT	ENDS
END
