; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\MMusic.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0M@LLKBNNKD@Midi?5Error?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@NBMCKBOF@Midi?5Play?5Error?$CB?52001?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@GJFNACAI@open?5?$CFs?5type?5sequencer?5alias?5Mid@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NKFOBFIP@close?5all?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@PKOPPCCG@Midi?5Play?5Error?$CB?52002?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@ODPEMDGH@Midi?5Play?5Error?$CB?52003?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@FFHCIKA@play?5Midi?5from?50?5notify?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@KMLFFFKA@Midi?5Play?5Error?$CB?52004?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@IDCGAMCB@Midi?5Stop?5Error?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09FDOHMLKC@stop?5Midi?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@HLFJMNAM@Midi?5Pause?5Error?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EOFKOJBJ@play?5Midi?5notify?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@IFOJLOLK@Midi?5Resume?5Error?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@GPDFBMBH@Midi?5RePlay?5Error?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT _$E79
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E80
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?ErrorMsg@MMusic@@IAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MMusic@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MMusic@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@MMusic@@QAE_NPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVolume@MMusic@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnInit@MMusic@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Play@MMusic@@QAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@MMusic@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Pause@MMusic@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Resume@MMusic@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RePlay@MMusic@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ErrorMsg@MMusic@@IAE_NXZ			; MMusic::ErrorMsg
PUBLIC	??_C@_0M@LLKBNNKD@Midi?5Error?$CB?$AA@		; `string'
EXTRN	_strcpy:NEAR
;	COMDAT ??_C@_0M@LLKBNNKD@Midi?5Error?$CB?$AA@
; File c:\darkeden\designed_common\project\client\mmusic.cpp
CONST	SEGMENT
??_C@_0M@LLKBNNKD@Midi?5Error?$CB?$AA@ DB 'Midi Error!', 00H ; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?ErrorMsg@MMusic@@IAE_NXZ
_TEXT	SEGMENT
?ErrorMsg@MMusic@@IAE_NXZ PROC NEAR			; MMusic::ErrorMsg, COMDAT
; _this$ = ecx

; 18   : 	if(MIDI_ERROR_MSG[0] == NULL) ::strcpy((LPSTR)MIDI_ERROR_MSG, "Midi Error!");

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	75 0d		 jne	 SHORT $L99431
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@LLKBNNKD@Midi?5Error?$CB?$AA@
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _strcpy
  00013	59		 pop	 ecx
  00014	59		 pop	 ecx
$L99431:

; 19   : 
; 20   :     //::MessageBox( NULL, (LPSTR)MIDI_ERROR_MSG, "Class Midi Message", MB_ICONINFORMATION|MB_OK );
; 21   : 
; 22   : 	return false;

  00015	32 c0		 xor	 al, al

; 23   : }

  00017	c3		 ret	 0
?ErrorMsg@MMusic@@IAE_NXZ ENDP				; MMusic::ErrorMsg
_TEXT	ENDS
PUBLIC	??0MMusic@@QAE@XZ				; MMusic::MMusic
; Function compile flags: /Ogsy
;	COMDAT ??0MMusic@@QAE@XZ
_TEXT	SEGMENT
??0MMusic@@QAE@XZ PROC NEAR				; MMusic::MMusic, COMDAT
; _this$ = ecx

; 28   : {

  00000	8b c1		 mov	 eax, ecx

; 29   : 	m_hwnd	= NULL;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 30   : 
; 31   : 	m_bLoad	= false;

  00006	88 88 45 01 00
	00		 mov	 BYTE PTR [eax+325], cl

; 32   : 	m_bPlay	= false;

  0000c	88 88 46 01 00
	00		 mov	 BYTE PTR [eax+326], cl

; 33   : 
; 34   : 	m_bInit		= false;

  00012	88 88 44 01 00
	00		 mov	 BYTE PTR [eax+324], cl

; 35   : 
; 36   : 	m_bPause = false;

  00018	88 88 47 01 00
	00		 mov	 BYTE PTR [eax+327], cl

; 37   : }

  0001e	c3		 ret	 0
??0MMusic@@QAE@XZ ENDP					; MMusic::MMusic
_TEXT	ENDS
PUBLIC	??1MMusic@@QAE@XZ				; MMusic::~MMusic
; Function compile flags: /Ogsy
;	COMDAT ??1MMusic@@QAE@XZ
_TEXT	SEGMENT
??1MMusic@@QAE@XZ PROC NEAR				; MMusic::~MMusic, COMDAT
; _this$ = ecx

; 42   : }

  00000	c3		 ret	 0
??1MMusic@@QAE@XZ ENDP					; MMusic::~MMusic
_TEXT	ENDS
PUBLIC	?Init@MMusic@@QAE_NPAUHWND__@@@Z		; MMusic::Init
EXTRN	__imp__midiOutGetVolume@8:NEAR
EXTRN	__imp__midiOutOpen@20:NEAR
EXTRN	__imp__midiOutClose@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?Init@MMusic@@QAE_NPAUHWND__@@@Z
_TEXT	SEGMENT
_volume$ = -8						; size = 4
_hmidi$ = -4						; size = 4
_hwnd$ = 8						; size = 4
?Init@MMusic@@QAE_NPAUHWND__@@@Z PROC NEAR		; MMusic::Init, COMDAT
; _this$ = ecx

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi

; 50   : 	DWORD volume;
; 51   : 
; 52   : 	HMIDIOUT hmidi;
; 53   : 	midiOutOpen(&hmidi, MIDI_MAPPER, NULL, NULL, CALLBACK_NULL);	

  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	6a ff		 push	 -1
  0000e	8d 45 fc	 lea	 eax, DWORD PTR _hmidi$[ebp]
  00011	50		 push	 eax
  00012	8b f1		 mov	 esi, ecx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutOpen@20

; 54   : 	midiOutGetVolume(hmidi, &volume);

  0001a	8d 45 f8	 lea	 eax, DWORD PTR _volume$[ebp]
  0001d	50		 push	 eax
  0001e	ff 75 fc	 push	 DWORD PTR _hmidi$[ebp]
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutGetVolume@8

; 55   : 	midiOutClose(hmidi);

  00027	ff 75 fc	 push	 DWORD PTR _hmidi$[ebp]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutClose@4

; 56   : 
; 57   : 	m_Volume = (WORD)(volume & 0xFFFF);

  00030	66 8b 45 f8	 mov	 ax, WORD PTR _volume$[ebp]
  00034	66 89 86 48 01
	00 00		 mov	 WORD PTR [esi+328], ax

; 58   : 
; 59   : 	m_hwnd	= hwnd;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]

; 60   : 
; 61   : 	if(!m_hwnd)

  0003e	85 c0		 test	 eax, eax
  00040	89 06		 mov	 DWORD PTR [esi], eax
  00042	75 04		 jne	 SHORT $L99448

; 62   : 	{
; 63   : 		return false;

  00044	32 c0		 xor	 al, al
  00046	eb 10		 jmp	 SHORT $L99443
$L99448:

; 64   : 	}
; 65   : 
; 66   : 	m_bInit = true;

  00048	c6 86 44 01 00
	00 01		 mov	 BYTE PTR [esi+324], 1

; 67   : 	m_bPause = false;

  0004f	c6 86 47 01 00
	00 00		 mov	 BYTE PTR [esi+327], 0

; 68   : 
; 69   : 	return true;

  00056	b0 01		 mov	 al, 1
$L99443:
  00058	5e		 pop	 esi

; 70   : }

  00059	c9		 leave
  0005a	c2 04 00	 ret	 4
?Init@MMusic@@QAE_NPAUHWND__@@@Z ENDP			; MMusic::Init
_TEXT	ENDS
PUBLIC	?SetVolume@MMusic@@QAEXG@Z			; MMusic::SetVolume
EXTRN	__imp__midiOutSetVolume@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?SetVolume@MMusic@@QAEXG@Z
_TEXT	SEGMENT
_hmidi$ = 8						; size = 4
_volume$ = 8						; size = 2
?SetVolume@MMusic@@QAEXG@Z PROC NEAR			; MMusic::SetVolume, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 75   : 	DWORD lrVolume = volume;

  00004	66 8b 5d 08	 mov	 bx, WORD PTR _volume$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 76   : 
; 77   : 	lrVolume |= (lrVolume << 16);
; 78   : 
; 79   : 	HMIDIOUT hmidi;
; 80   : 	midiOutOpen(&hmidi, MIDI_MAPPER, NULL, NULL, CALLBACK_NULL);	

  0000a	33 c0		 xor	 eax, eax
  0000c	50		 push	 eax
  0000d	50		 push	 eax
  0000e	50		 push	 eax
  0000f	6a ff		 push	 -1
  00011	8d 45 08	 lea	 eax, DWORD PTR _hmidi$[ebp]
  00014	50		 push	 eax
  00015	8b f9		 mov	 edi, ecx
  00017	0f b7 f3	 movzx	 esi, bx
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutOpen@20
  00020	8b c6		 mov	 eax, esi
  00022	c1 e0 10	 shl	 eax, 16			; 00000010H
  00025	0b c6		 or	 eax, esi

; 81   : 	midiOutSetVolume(hmidi, lrVolume);

  00027	50		 push	 eax
  00028	ff 75 08	 push	 DWORD PTR _hmidi$[ebp]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutSetVolume@8

; 82   : 	midiOutClose(hmidi);

  00031	ff 75 08	 push	 DWORD PTR _hmidi$[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutClose@4

; 83   : 	
; 84   : 	m_Volume = volume;

  0003a	66 89 9f 48 01
	00 00		 mov	 WORD PTR [edi+328], bx
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx

; 85   : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?SetVolume@MMusic@@QAEXG@Z ENDP				; MMusic::SetVolume
_TEXT	ENDS
PUBLIC	?Stop@MMusic@@QAE_NXZ				; MMusic::Stop
PUBLIC	??_C@_09NKFOBFIP@close?5all?$AA@		; `string'
PUBLIC	??_C@_0BB@IDCGAMCB@Midi?5Stop?5Error?$CB?$AA@	; `string'
EXTRN	__imp__mciSendStringA@16:NEAR
;	COMDAT ??_C@_09NKFOBFIP@close?5all?$AA@
CONST	SEGMENT
??_C@_09NKFOBFIP@close?5all?$AA@ DB 'close all', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IDCGAMCB@Midi?5Stop?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BB@IDCGAMCB@Midi?5Stop?5Error?$CB?$AA@ DB 'Midi Stop Error!', 00H ; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?Stop@MMusic@@QAE_NXZ
_TEXT	SEGMENT
?Stop@MMusic@@QAE_NXZ PROC NEAR				; MMusic::Stop, COMDAT
; _this$ = ecx

; 183  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 184  : 	if (m_bInit)

  00004	33 db		 xor	 ebx, ebx
  00006	38 9e 44 01 00
	00		 cmp	 BYTE PTR [esi+324], bl
  0000c	74 49		 je	 SHORT $L99485

; 185  : 	{
; 186  : 		if(!m_bPlay) return true;

  0000e	38 9e 46 01 00
	00		 cmp	 BYTE PTR [esi+326], bl
  00014	74 3d		 je	 SHORT $L100158

; 187  : 
; 188  : 		if(::mciSendString("close all", NULL, 0, NULL) != 0)

  00016	53		 push	 ebx
  00017	53		 push	 ebx
  00018	53		 push	 ebx
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09NKFOBFIP@close?5all?$AA@
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  00024	85 c0		 test	 eax, eax
  00026	74 19		 je	 SHORT $L99487

; 189  : 		{
; 190  : 			::strcpy((LPSTR)MIDI_ERROR_MSG, "Midi Stop Error!");

  00028	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@IDCGAMCB@Midi?5Stop?5Error?$CB?$AA@
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _strcpy
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx

; 191  : 			return ErrorMsg();

  00038	8b ce		 mov	 ecx, esi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	e9 00 00 00 00	 jmp	 ?ErrorMsg@MMusic@@IAE_NXZ ; MMusic::ErrorMsg
$L99487:

; 192  : 		}   
; 193  : 
; 194  : 		m_bLoad	= false;

  00041	88 9e 45 01 00
	00		 mov	 BYTE PTR [esi+325], bl

; 195  : 		m_bPlay	= false;

  00047	88 9e 46 01 00
	00		 mov	 BYTE PTR [esi+326], bl

; 196  : 		m_bPause = false;

  0004d	88 9e 47 01 00
	00		 mov	 BYTE PTR [esi+327], bl
$L100158:

; 197  : 
; 198  : 		return true;

  00053	b0 01		 mov	 al, 1
  00055	eb 02		 jmp	 SHORT $L99484
$L99485:

; 199  : 	}
; 200  : 
; 201  : 	return false;

  00057	32 c0		 xor	 al, al
$L99484:
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx

; 202  : }

  0005b	c3		 ret	 0
?Stop@MMusic@@QAE_NXZ ENDP				; MMusic::Stop
_TEXT	ENDS
PUBLIC	?Pause@MMusic@@QAE_NXZ				; MMusic::Pause
PUBLIC	??_C@_09FDOHMLKC@stop?5Midi?$AA@		; `string'
PUBLIC	??_C@_0BC@HLFJMNAM@Midi?5Pause?5Error?$CB?$AA@	; `string'
;	COMDAT ??_C@_09FDOHMLKC@stop?5Midi?$AA@
CONST	SEGMENT
??_C@_09FDOHMLKC@stop?5Midi?$AA@ DB 'stop Midi', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HLFJMNAM@Midi?5Pause?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BC@HLFJMNAM@Midi?5Pause?5Error?$CB?$AA@ DB 'Midi Pause Error!', 00H ; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?Pause@MMusic@@QAE_NXZ
_TEXT	SEGMENT
?Pause@MMusic@@QAE_NXZ PROC NEAR			; MMusic::Pause, COMDAT
; _this$ = ecx

; 207  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 208  : 	if (m_bInit)

  00004	33 db		 xor	 ebx, ebx
  00006	38 9e 44 01 00
	00		 cmp	 BYTE PTR [esi+324], bl
  0000c	74 4c		 je	 SHORT $L99493

; 209  : 	{
; 210  : 		if(!m_bLoad || !m_bPlay) return true;

  0000e	38 9e 45 01 00
	00		 cmp	 BYTE PTR [esi+325], bl
  00014	74 40		 je	 SHORT $L99495
  00016	38 9e 46 01 00
	00		 cmp	 BYTE PTR [esi+326], bl
  0001c	74 38		 je	 SHORT $L99495

; 211  : 
; 212  : 		// Pause if we're not already paused
; 213  : 		if(::mciSendString("stop Midi", NULL, 0, NULL) != 0)

  0001e	53		 push	 ebx
  0001f	53		 push	 ebx
  00020	53		 push	 ebx
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09FDOHMLKC@stop?5Midi?$AA@
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  0002c	85 c0		 test	 eax, eax
  0002e	74 19		 je	 SHORT $L99496

; 214  : 		{
; 215  : 			::strcpy((LPSTR)MIDI_ERROR_MSG, "Midi Pause Error!");

  00030	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@HLFJMNAM@Midi?5Pause?5Error?$CB?$AA@
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _strcpy
  0003e	59		 pop	 ecx
  0003f	59		 pop	 ecx

; 216  : 			return ErrorMsg();

  00040	8b ce		 mov	 ecx, esi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	e9 00 00 00 00	 jmp	 ?ErrorMsg@MMusic@@IAE_NXZ ; MMusic::ErrorMsg
$L99496:

; 217  : 		}
; 218  : 
; 219  : 		m_bPlay	= false;

  00049	88 9e 46 01 00
	00		 mov	 BYTE PTR [esi+326], bl

; 220  : 		m_bPause = true;

  0004f	c6 86 47 01 00
	00 01		 mov	 BYTE PTR [esi+327], 1
$L99495:

; 221  : 
; 222  : 		return true;

  00056	b0 01		 mov	 al, 1
  00058	eb 02		 jmp	 SHORT $L99492
$L99493:

; 223  : 	}
; 224  : 
; 225  : 	return false;

  0005a	32 c0		 xor	 al, al
$L99492:
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx

; 226  : }

  0005e	c3		 ret	 0
?Pause@MMusic@@QAE_NXZ ENDP				; MMusic::Pause
_TEXT	ENDS
PUBLIC	?Resume@MMusic@@QAE_NXZ				; MMusic::Resume
PUBLIC	??_C@_0BB@EOFKOJBJ@play?5Midi?5notify?$AA@	; `string'
PUBLIC	??_C@_0BD@IFOJLOLK@Midi?5Resume?5Error?$CB?$AA@	; `string'
;	COMDAT ??_C@_0BB@EOFKOJBJ@play?5Midi?5notify?$AA@
CONST	SEGMENT
??_C@_0BB@EOFKOJBJ@play?5Midi?5notify?$AA@ DB 'play Midi notify', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IFOJLOLK@Midi?5Resume?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BD@IFOJLOLK@Midi?5Resume?5Error?$CB?$AA@ DB 'Midi Resume Error!', 00H ; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?Resume@MMusic@@QAE_NXZ
_TEXT	SEGMENT
?Resume@MMusic@@QAE_NXZ PROC NEAR			; MMusic::Resume, COMDAT
; _this$ = ecx

; 231  : {	

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 232  : 	if (m_bInit)

  00004	33 db		 xor	 ebx, ebx
  00006	38 9e 44 01 00
	00		 cmp	 BYTE PTR [esi+324], bl
  0000c	74 4d		 je	 SHORT $L99503

; 233  : 	{
; 234  : 		if(!m_bLoad || m_bPlay) return false;

  0000e	38 9e 45 01 00
	00		 cmp	 BYTE PTR [esi+325], bl
  00014	74 45		 je	 SHORT $L99503
  00016	38 9e 46 01 00
	00		 cmp	 BYTE PTR [esi+326], bl
  0001c	75 3d		 jne	 SHORT $L99503

; 235  : 
; 236  : 		// Resume midi
; 237  : 		if(::mciSendString("play Midi notify", NULL, 0, m_hwnd) != 0)

  0001e	ff 36		 push	 DWORD PTR [esi]
  00020	53		 push	 ebx
  00021	53		 push	 ebx
  00022	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@EOFKOJBJ@play?5Midi?5notify?$AA@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  0002d	85 c0		 test	 eax, eax
  0002f	74 19		 je	 SHORT $L99506

; 238  : 		{
; 239  : 			::strcpy((LPSTR)MIDI_ERROR_MSG, "Midi Resume Error!");

  00031	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@IFOJLOLK@Midi?5Resume?5Error?$CB?$AA@
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _strcpy
  0003f	59		 pop	 ecx
  00040	59		 pop	 ecx

; 240  : 			return ErrorMsg();

  00041	8b ce		 mov	 ecx, esi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	e9 00 00 00 00	 jmp	 ?ErrorMsg@MMusic@@IAE_NXZ ; MMusic::ErrorMsg
$L99506:

; 241  : 		}
; 242  : 
; 243  : 		m_bPlay	= true;

  0004a	c6 86 46 01 00
	00 01		 mov	 BYTE PTR [esi+326], 1

; 244  : 		m_bPause = false;

  00051	88 9e 47 01 00
	00		 mov	 BYTE PTR [esi+327], bl

; 245  : 
; 246  : 		return true;

  00057	b0 01		 mov	 al, 1
  00059	eb 02		 jmp	 SHORT $L99502
$L99503:

; 247  : 	}
; 248  : 
; 249  : 	return false;

  0005b	32 c0		 xor	 al, al
$L99502:
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx

; 250  : }

  0005f	c3		 ret	 0
?Resume@MMusic@@QAE_NXZ ENDP				; MMusic::Resume
_TEXT	ENDS
PUBLIC	?RePlay@MMusic@@QAE_NXZ				; MMusic::RePlay
PUBLIC	??_C@_0BI@FFHCIKA@play?5Midi?5from?50?5notify?$AA@ ; `string'
PUBLIC	??_C@_0BD@GPDFBMBH@Midi?5RePlay?5Error?$CB?$AA@	; `string'
;	COMDAT ??_C@_0BI@FFHCIKA@play?5Midi?5from?50?5notify?$AA@
CONST	SEGMENT
??_C@_0BI@FFHCIKA@play?5Midi?5from?50?5notify?$AA@ DB 'play Midi from 0 n'
	DB	'otify', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GPDFBMBH@Midi?5RePlay?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BD@GPDFBMBH@Midi?5RePlay?5Error?$CB?$AA@ DB 'Midi RePlay Error!', 00H ; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?RePlay@MMusic@@QAE_NXZ
_TEXT	SEGMENT
?RePlay@MMusic@@QAE_NXZ PROC NEAR			; MMusic::RePlay, COMDAT
; _this$ = ecx

; 256  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 257  : 	if (m_bInit)

  00004	33 db		 xor	 ebx, ebx
  00006	38 9e 44 01 00
	00		 cmp	 BYTE PTR [esi+324], bl
  0000c	74 45		 je	 SHORT $L99513

; 258  : 	{
; 259  : 		if(!m_bLoad) return false;

  0000e	38 9e 45 01 00
	00		 cmp	 BYTE PTR [esi+325], bl
  00014	74 3d		 je	 SHORT $L99513

; 260  : 
; 261  : 		// Replay midi
; 262  : 		if(::mciSendString("play Midi from 0 notify", NULL, 0, m_hwnd) != 0)

  00016	ff 36		 push	 DWORD PTR [esi]
  00018	53		 push	 ebx
  00019	53		 push	 ebx
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@FFHCIKA@play?5Midi?5from?50?5notify?$AA@
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendStringA@16
  00025	85 c0		 test	 eax, eax
  00027	74 19		 je	 SHORT $L99515

; 263  : 		{
; 264  : 			::strcpy((LPSTR)MIDI_ERROR_MSG, "Midi RePlay Error!");

  00029	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@GPDFBMBH@Midi?5RePlay?5Error?$CB?$AA@
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _strcpy
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 265  : 			return ErrorMsg();

  00039	8b ce		 mov	 ecx, esi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	e9 00 00 00 00	 jmp	 ?ErrorMsg@MMusic@@IAE_NXZ ; MMusic::ErrorMsg
$L99515:

; 266  : 		}
; 267  : 
; 268  : 		m_bPlay	= true;

  00042	c6 86 46 01 00
	00 01		 mov	 BYTE PTR [esi+326], 1

; 269  : 		m_bPause = false;

  00049	88 9e 47 01 00
	00		 mov	 BYTE PTR [esi+327], bl

; 270  : 
; 271  : 		return true;

  0004f	b0 01		 mov	 al, 1
  00051	eb 02		 jmp	 SHORT $L99512
$L99513:

; 272  : 	}
; 273  : 
; 274  : 	return false;

  00053	32 c0		 xor	 al, al
$L99512:
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx

; 275  : }

  00057	c3		 ret	 0
?RePlay@MMusic@@QAE_NXZ ENDP				; MMusic::RePlay
_TEXT	ENDS
PUBLIC	?UnInit@MMusic@@QAEXXZ				; MMusic::UnInit
; Function compile flags: /Ogsy
;	COMDAT ?UnInit@MMusic@@QAEXXZ
_TEXT	SEGMENT
?UnInit@MMusic@@QAEXXZ PROC NEAR			; MMusic::UnInit, COMDAT
; _this$ = ecx

; 91   : 	if(m_bInit && m_bLoad)

  00000	80 b9 44 01 00
	00 00		 cmp	 BYTE PTR [ecx+324], 0
  00007	74 0e		 je	 SHORT $L99459
  00009	80 b9 45 01 00
	00 00		 cmp	 BYTE PTR [ecx+325], 0
  00010	74 05		 je	 SHORT $L99459

; 92   : 	{
; 93   : 		Stop();

  00012	e9 00 00 00 00	 jmp	 ?Stop@MMusic@@QAE_NXZ	; MMusic::Stop
$L99459:

; 94   : 	}
; 95   : }

  00017	c3		 ret	 0
?UnInit@MMusic@@QAEXXZ ENDP				; MMusic::UnInit
_TEXT	ENDS
PUBLIC	?Play@MMusic@@QAE_NPBD@Z			; MMusic::Play
PUBLIC	??_C@_0BG@NBMCKBOF@Midi?5Play?5Error?$CB?52001?$AA@ ; `string'
PUBLIC	??_C@_0CC@GJFNACAI@open?5?$CFs?5type?5sequencer?5alias?5Mid@ ; `string'
PUBLIC	??_C@_0BG@PKOPPCCG@Midi?5Play?5Error?$CB?52002?$AA@ ; `string'
PUBLIC	??_C@_0BG@ODPEMDGH@Midi?5Play?5Error?$CB?52003?$AA@ ; `string'
PUBLIC	??_C@_0BG@KMLFFFKA@Midi?5Play?5Error?$CB?52004?$AA@ ; `string'
EXTRN	_sprintf:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
;	COMDAT ??_C@_0BG@NBMCKBOF@Midi?5Play?5Error?$CB?52001?$AA@
CONST	SEGMENT
??_C@_0BG@NBMCKBOF@Midi?5Play?5Error?$CB?52001?$AA@ DB 'Midi Play Error! '
	DB	'2001', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GJFNACAI@open?5?$CFs?5type?5sequencer?5alias?5Mid@
CONST	SEGMENT
??_C@_0CC@GJFNACAI@open?5?$CFs?5type?5sequencer?5alias?5Mid@ DB 'open %s '
	DB	'type sequencer alias Midi', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PKOPPCCG@Midi?5Play?5Error?$CB?52002?$AA@
CONST	SEGMENT
??_C@_0BG@PKOPPCCG@Midi?5Play?5Error?$CB?52002?$AA@ DB 'Midi Play Error! '
	DB	'2002', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ODPEMDGH@Midi?5Play?5Error?$CB?52003?$AA@
CONST	SEGMENT
??_C@_0BG@ODPEMDGH@Midi?5Play?5Error?$CB?52003?$AA@ DB 'Midi Play Error! '
	DB	'2003', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KMLFFFKA@Midi?5Play?5Error?$CB?52004?$AA@
CONST	SEGMENT
??_C@_0BG@KMLFFFKA@Midi?5Play?5Error?$CB?52004?$AA@ DB 'Midi Play Error! '
	DB	'2004', 00H					; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?Play@MMusic@@QAE_NPBD@Z
_TEXT	SEGMENT
_buffer$99465 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_filename$ = 8						; size = 4
?Play@MMusic@@QAE_NPBD@Z PROC NEAR			; MMusic::Play, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx

; 102  : 	/*
; 103  : 	HMIDIOUT hmidi;
; 104  : 
; 105  : 	UINT num = midiOutGetNumDevs();
; 106  : 	UINT result = midiOutOpen(&hmidi, MIDI_MAPPER, NULL, NULL, CALLBACK_NULL);
; 107  : 
; 108  : 	int k=0;
; 109  : 	switch (result)
; 110  : 	{
; 111  : 		case MMSYSERR_NOERROR : 	k=1;		break;
; 112  : 		case MIDIERR_NODEVICE :		k=2;		break;
; 113  : 		case MMSYSERR_ALLOCATED :	k=3;		break;
; 114  : 		case MMSYSERR_BADDEVICEID :	k=4;		break;
; 115  : 		case MMSYSERR_INVALPARAM :	k=5;		break;
; 116  : 		case MMSYSERR_NOMEM :		k=6;		break;
; 117  : 	}
; 118  : 
; 119  : 	result = midiOutSetVolume(hmidi, 0xFFFFFFFF);
; 120  : 
; 121  : 	switch (result)
; 122  : 	{
; 123  : 		case MMSYSERR_NOERROR : 	k=1;		break;
; 124  : 		case MMSYSERR_INVALHANDLE :	k=2;		break;
; 125  : 		case MMSYSERR_NOMEM :		k=3;		break;
; 126  : 		case MMSYSERR_NOTSUPPORTED : k=4;		break;		
; 127  : 	}
; 128  : 
; 129  : 	midiOutClose(hmidi);
; 130  : 	*/
; 131  : 	
; 132  : 	if (m_bInit)

  00012	33 db		 xor	 ebx, ebx
  00014	38 9e 44 01 00
	00		 cmp	 BYTE PTR [esi+324], bl
  0001a	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001d	57		 push	 edi
  0001e	0f 84 a2 00 00
	00		 je	 $L99464

; 133  : 	{
; 134  : 		char buffer[256];
; 135  : 
; 136  : 		// 음악이 로드되어 있다면 정지시킨다.
; 137  : 		if(m_bLoad)

  00024	38 9e 45 01 00
	00		 cmp	 BYTE PTR [esi+325], bl
  0002a	74 05		 je	 SHORT $L99466

; 138  : 		{
; 139  : 			Stop();

  0002c	e8 00 00 00 00	 call	 ?Stop@MMusic@@QAE_NXZ	; MMusic::Stop
$L99466:

; 140  : 		}
; 141  : 
; 142  : 		if(filename == NULL)

  00031	39 5d 08	 cmp	 DWORD PTR _filename$[ebp], ebx
  00034	75 07		 jne	 SHORT $L99467

; 143  : 		{
; 144  : 			::strcpy((LPSTR)MIDI_ERROR_MSG, "Midi Play Error! 2001");

  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@NBMCKBOF@Midi?5Play?5Error?$CB?52001?$AA@

; 145  : 			return ErrorMsg();

  0003b	eb 5d		 jmp	 SHORT $L100181
$L99467:

; 146  : 		}
; 147  : 
; 148  : 		sprintf(buffer, "open %s type sequencer alias Midi", filename);

  0003d	ff 75 08	 push	 DWORD PTR _filename$[ebp]
  00040	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buffer$99465[ebp]
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@GJFNACAI@open?5?$CFs?5type?5sequencer?5alias?5Mid@
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _sprintf

; 149  : 
; 150  : 		if(::mciSendString("close all", NULL, 0, NULL) != 0)

  00051	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__mciSendStringA@16
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	53		 push	 ebx
  0005b	53		 push	 ebx
  0005c	53		 push	 ebx
  0005d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09NKFOBFIP@close?5all?$AA@
  00062	ff d7		 call	 edi
  00064	85 c0		 test	 eax, eax
  00066	74 07		 je	 SHORT $L99471

; 151  : 		{
; 152  : 			::strcpy((LPSTR)MIDI_ERROR_MSG, "Midi Play Error! 2002");

  00068	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@PKOPPCCG@Midi?5Play?5Error?$CB?52002?$AA@

; 153  : 			return ErrorMsg();

  0006d	eb 2b		 jmp	 SHORT $L100181
$L99471:

; 154  : 		}
; 155  : 
; 156  : 		if(::mciSendString(buffer, NULL, 0, NULL) != 0)

  0006f	53		 push	 ebx
  00070	53		 push	 ebx
  00071	53		 push	 ebx
  00072	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buffer$99465[ebp]
  00078	50		 push	 eax
  00079	ff d7		 call	 edi
  0007b	85 c0		 test	 eax, eax
  0007d	74 07		 je	 SHORT $L99475

; 157  : 		{	
; 158  : 			::strcpy((LPSTR)MIDI_ERROR_MSG, "Midi Play Error! 2003");

  0007f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@ODPEMDGH@Midi?5Play?5Error?$CB?52003?$AA@

; 159  : 			return ErrorMsg();

  00084	eb 14		 jmp	 SHORT $L100181
$L99475:

; 160  : 		}
; 161  : 
; 162  : 		if(::mciSendString("play Midi from 0 notify", NULL, 0, m_hwnd) != 0)

  00086	ff 36		 push	 DWORD PTR [esi]
  00088	53		 push	 ebx
  00089	53		 push	 ebx
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@FFHCIKA@play?5Midi?5from?50?5notify?$AA@
  0008f	ff d7		 call	 edi
  00091	85 c0		 test	 eax, eax
  00093	74 19		 je	 SHORT $L99478

; 163  : 		{
; 164  : 			::strcpy((LPSTR)MIDI_ERROR_MSG, "Midi Play Error! 2004");

  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@KMLFFFKA@Midi?5Play?5Error?$CB?52004?$AA@
$L100181:
  0009a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _strcpy
  000a3	59		 pop	 ecx
  000a4	59		 pop	 ecx

; 165  : 			return ErrorMsg();

  000a5	8b ce		 mov	 ecx, esi
  000a7	e8 00 00 00 00	 call	 ?ErrorMsg@MMusic@@IAE_NXZ ; MMusic::ErrorMsg
  000ac	eb 1a		 jmp	 SHORT $L99463
$L99478:

; 166  : 		}	
; 167  : 
; 168  : 		m_bLoad	= true;

  000ae	c6 86 45 01 00
	00 01		 mov	 BYTE PTR [esi+325], 1

; 169  : 		m_bPlay	= true;

  000b5	c6 86 46 01 00
	00 01		 mov	 BYTE PTR [esi+326], 1

; 170  : 		m_bPause = false;

  000bc	88 9e 47 01 00
	00		 mov	 BYTE PTR [esi+327], bl

; 171  : 
; 172  : 		return true;

  000c2	b0 01		 mov	 al, 1
  000c4	eb 02		 jmp	 SHORT $L99463
$L99464:

; 173  : 	}
; 174  : 
; 175  : 	return false;

  000c6	32 c0		 xor	 al, al
$L99463:

; 176  : }

  000c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d3	c9		 leave
  000d4	c2 04 00	 ret	 4
?Play@MMusic@@QAE_NPBD@Z ENDP				; MMusic::Play
_TEXT	ENDS
EXTRN	_atexit:NEAR
CRT$XCU	SEGMENT
_$S81	DD	FLAT:_$E79
; Function compile flags: /Ogsy
CRT$XCU	ENDS
;	COMDAT _$E79
text$yc	SEGMENT
_$E79	PROC NEAR					; COMDAT

; 11   : MMusic		g_Music;

  00000	68 00 00 00 00	 push	 OFFSET FLAT:_$E80
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
_$E79	ENDP
; Function compile flags: /Ogsy
text$yc	ENDS
;	COMDAT _$E80
text$yd	SEGMENT
_$E80	PROC NEAR					; COMDAT
  00000	c3		 ret	 0
_$E80	ENDP
text$yd	ENDS
PUBLIC	?g_Music@@3VMMusic@@A				; g_Music
_BSS	SEGMENT
?g_Music@@3VMMusic@@A DB 014cH DUP (?)			; g_Music
_BSS	ENDS
END
