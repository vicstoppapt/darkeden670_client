; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\MActionInfoTable.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BN@ODLNCKCA@Data?2?2Info?2?2ClientConfig?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@DFPLPGPC@Data?2?2Info?2?2GuildMapper?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@LHODHNBK@Data?2?2Info?2?2GuildVersion?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@DDPLNCOL@Data?2?2Info?2?2Player?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@ILLNAPHB@Data?2?2Info?2?2Resolution?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@HEIGFDLG@Data?2?2Info?2?2SelectedChannel?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?start@CNFS@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@CNFS@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@VirtualFileHeader@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1IFileIO@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIFileIO@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iovfs_base@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Giovfs_base@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1iovfs_base@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@iovfs_base@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Givfstream@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ivfstream@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?open@ivfstream@@UAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?read@ivfstream@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Govfstream@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ovfstream@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?open@ovfstream@@UAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BMString@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ACTION_INFO_NODE@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ACTION_INFO_NODE@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCastingStartFrameAll@MActionInfo@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetComboAttackSkill@MActionInfo@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStartFrameAll@MActionInfo@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsUseActionStep@MActionInfo@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetChildMode@ACTION_INFO_NODE@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveToFile@ACTION_INFO_NODE@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFile@ACTION_INFO_NODE@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MActionInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MActionInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetChildMode@MActionInfo@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveToFile@MActionInfo@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFile@MActionInfo@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActionStep@MActionInfo@@QAEXEG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetComboSkillActionStep@MActionInfo@@QAEXGGGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetComboSkillActionStep@MActionInfo@@QAEGE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetActionStep@MActionInfo@@QAEGE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetParentActionInfo@MActionInfo@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParentActionInfo@MActionInfo@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetComboSkillStartFrame@MActionInfo@@QAEXHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MActionInfoTable@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MActionInfoTable@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetChildMode@MActionInfoTable@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveToFile@MActionInfoTable@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFile@MActionInfoTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTypeTable@VACTION_INFO_NODE@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTypeTable@VACTION_INFO_NODE@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveToFile@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFile@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CBitAttribute@EI@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CBitAttribute@EI@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CBitAttribute@EI@@QAEEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTypeTable@VMActionInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTypeTable@VMActionInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveToFile@?$CTypeTable@VMActionInfo@@@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFile@?$CTypeTable@VMActionInfo@@@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QBEPAV?$basic_streambuf@DV?$char_traits@D@_STL@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_handle_exception@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNULL@?$CBitAttribute@EI@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CTypeTable@VMActionInfo@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CTypeTable@VMActionInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_init@DV?$char_traits@D@_STL@@@_STL@@YA_NAAV?$basic_ostream@DV?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EACTION_INFO_NODE@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EMActionInfo@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QBEPAV?$basic_ostream@DV?$char_traits@D@_STL@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@A@3A@ios_base@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@_STL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@A@3BA@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVovfstream@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVivfstream@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AViovfs_base@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVIFileIO@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4ovfstream@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ivfstream@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4iovfs_base@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4IFileIO@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?good@ios_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_get_exception_mask@ios_base@_STL@@IBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setstate_nothrow@ios_base@_STL@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_check_exception_mask@ios_base@_STL@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_clear_nothrow@ios_base@_STL@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flags@ios_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdstate@ios_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputn@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@QAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ios_base@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@MAEPAV?$basic_streambuf@DV?$char_traits@D@_STL@@@2@PADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_in_binary_mode@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$codecvt@DDH@_STL@@QBEHABHPBD1I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?in@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eback@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_begin@_STL@@YAPADPBU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_next@_STL@@YAPADPBU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_get_offset@_Filebuf_base@_STL@@QAEJPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$count@PADD@_STL@@YAHPAD0ABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_end@_STL@@YAPADPBU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_bump@_STL@@YAXPAU_iobuf@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@_STL@@SAHABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@_STL@@SADABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_next@_STL@@YAPADPBU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?out@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_doit@?$_Noconv_output@V?$char_traits@D@_STL@@@_STL@@SA_NPAV?$basic_filebuf@DV?$char_traits@D@_STL@@@2@PAD1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@_STL@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ovfstream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ivfstream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7iovfs_base@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IFileIO@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pActionInfoTable@@3PAVMActionInfoTable@@A	; g_pActionInfoTable
_BSS	SEGMENT
?g_pActionInfoTable@@3PAVMActionInfoTable@@A DD 01H DUP (?) ; g_pActionInfoTable
_BSS	ENDS
PUBLIC	?read@ivfstream@@QAEXPADI@Z			; ivfstream::read
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\virtualfilesystem\vfstream.inl
;	COMDAT ?read@ivfstream@@QAEXPADI@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
?read@ivfstream@@QAEXPADI@Z PROC NEAR			; ivfstream::read, COMDAT
; _this$ = ecx

; 81   : 	if(m_pFileIO) m_pFileIO->read(buf, len);

  00000	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00004	74 08		 je	 SHORT $L101886
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 60 10	 jmp	 DWORD PTR [eax+16]
$L101886:

; 82   : }

  0000e	c2 08 00	 ret	 8
?read@ivfstream@@QAEXPADI@Z ENDP			; ivfstream::read
_TEXT	ENDS
PUBLIC	??0ACTION_INFO_NODE@@QAE@XZ			; ACTION_INFO_NODE::ACTION_INFO_NODE
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mactioninfotable.h
;	COMDAT ??0ACTION_INFO_NODE@@QAE@XZ
_TEXT	SEGMENT
??0ACTION_INFO_NODE@@QAE@XZ PROC NEAR			; ACTION_INFO_NODE::ACTION_INFO_NODE, COMDAT
; _this$ = ecx

; 222  : 		ACTION_INFO_NODE()

  00000	8b c1		 mov	 eax, ecx

; 223  : 		{
; 224  : 			SoundID		= SOUNDID_NULL;

  00002	66 81 48 0a ff
	ff		 or	 WORD PTR [eax+10], 65535 ; 0000ffffH

; 225  : 			//Light		= 1;
; 226  : 			LinkCount	= 0xFFFF;

  00008	66 81 48 08 ff
	ff		 or	 WORD PTR [eax+8], 65535	; 0000ffffH

; 227  : 
; 228  : 			bDelayNode	= false;

  0000e	32 c9		 xor	 cl, cl
  00010	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 229  : 			bResultTime = false;	

  00013	88 48 0d	 mov	 BYTE PTR [eax+13], cl

; 230  : 			bUseCoord = false;

  00016	88 48 0e	 mov	 BYTE PTR [eax+14], cl

; 231  : 		}

  00019	c3		 ret	 0
??0ACTION_INFO_NODE@@QAE@XZ ENDP			; ACTION_INFO_NODE::ACTION_INFO_NODE
_TEXT	ENDS
PUBLIC	??1ACTION_INFO_NODE@@QAE@XZ			; ACTION_INFO_NODE::~ACTION_INFO_NODE
; Function compile flags: /Ogsy
;	COMDAT ??1ACTION_INFO_NODE@@QAE@XZ
_TEXT	SEGMENT
??1ACTION_INFO_NODE@@QAE@XZ PROC NEAR			; ACTION_INFO_NODE::~ACTION_INFO_NODE, COMDAT
; _this$ = ecx

; 233  : 		~ACTION_INFO_NODE() {}

  00000	c3		 ret	 0
??1ACTION_INFO_NODE@@QAE@XZ ENDP			; ACTION_INFO_NODE::~ACTION_INFO_NODE
_TEXT	ENDS
PUBLIC	?SetCastingStartFrameAll@MActionInfo@@QAEXH@Z	; MActionInfo::SetCastingStartFrameAll
; Function compile flags: /Ogsy
;	COMDAT ?SetCastingStartFrameAll@MActionInfo@@QAEXH@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
?SetCastingStartFrameAll@MActionInfo@@QAEXH@Z PROC NEAR	; MActionInfo::SetCastingStartFrameAll, COMDAT
; _this$ = ecx

; 323  : 		void		SetCastingStartFrameAll(int f)			{ m_CastingStartFrame[0] = m_CastingStartFrame[1] = m_CastingStartFrame[2] = f; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _f$[esp-4]
  00004	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  00007	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  0000a	89 41 34	 mov	 DWORD PTR [ecx+52], eax
  0000d	c2 04 00	 ret	 4
?SetCastingStartFrameAll@MActionInfo@@QAEXH@Z ENDP	; MActionInfo::SetCastingStartFrameAll
_TEXT	ENDS
PUBLIC	?GetComboAttackSkill@MActionInfo@@QAEHXZ	; MActionInfo::GetComboAttackSkill
; Function compile flags: /Ogsy
;	COMDAT ?GetComboAttackSkill@MActionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetComboAttackSkill@MActionInfo@@QAEHXZ PROC NEAR	; MActionInfo::GetComboAttackSkill, COMDAT
; _this$ = ecx

; 372  : 		BOOL		GetComboAttackSkill()	{	return m_bComboAttackSkill ; }

  00000	8b 41 78	 mov	 eax, DWORD PTR [ecx+120]
  00003	c3		 ret	 0
?GetComboAttackSkill@MActionInfo@@QAEHXZ ENDP		; MActionInfo::GetComboAttackSkill
_TEXT	ENDS
PUBLIC	?SetStartFrameAll@MActionInfo@@QAEXH@Z		; MActionInfo::SetStartFrameAll
; Function compile flags: /Ogsy
;	COMDAT ?SetStartFrameAll@MActionInfo@@QAEXH@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
?SetStartFrameAll@MActionInfo@@QAEXH@Z PROC NEAR	; MActionInfo::SetStartFrameAll, COMDAT
; _this$ = ecx

; 430  : 		void		SetStartFrameAll(int f)	{ m_StartFrame[0] = m_StartFrame[1] = m_StartFrame[2] = m_StartFrame[2] = m_StartFrame[3] = m_StartFrame[4] = m_StartFrame[5] = m_StartFrame[6] = m_StartFrame[7] = m_StartFrame[8]= f; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _f$[esp-4]
  00004	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax
  0000a	89 81 98 00 00
	00		 mov	 DWORD PTR [ecx+152], eax
  00010	89 81 94 00 00
	00		 mov	 DWORD PTR [ecx+148], eax
  00016	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax
  0001c	89 81 8c 00 00
	00		 mov	 DWORD PTR [ecx+140], eax
  00022	89 81 88 00 00
	00		 mov	 DWORD PTR [ecx+136], eax
  00028	89 81 84 00 00
	00		 mov	 DWORD PTR [ecx+132], eax
  0002e	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax
  00034	89 41 7c	 mov	 DWORD PTR [ecx+124], eax
  00037	c2 04 00	 ret	 4
?SetStartFrameAll@MActionInfo@@QAEXH@Z ENDP		; MActionInfo::SetStartFrameAll
_TEXT	ENDS
PUBLIC	?flags@ios_base@_STL@@QBEHXZ			; _STL::ios_base::flags
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_ios_base.h
;	COMDAT ?flags@ios_base@_STL@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@_STL@@QBEHXZ PROC NEAR			; _STL::ios_base::flags, COMDAT
; _this$ = ecx

; 115  :   fmtflags flags() const { return _M_fmtflags; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?flags@ios_base@_STL@@QBEHXZ ENDP			; _STL::ios_base::flags
_TEXT	ENDS
PUBLIC	?rdstate@ios_base@_STL@@QBEHXZ			; _STL::ios_base::rdstate
; Function compile flags: /Ogsy
;	COMDAT ?rdstate@ios_base@_STL@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@_STL@@QBEHXZ PROC NEAR		; _STL::ios_base::rdstate, COMDAT
; _this$ = ecx

; 178  :   iostate rdstate() const { return _M_iostate; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?rdstate@ios_base@_STL@@QBEHXZ ENDP			; _STL::ios_base::rdstate
_TEXT	ENDS
PUBLIC	?good@ios_base@_STL@@QBE_NXZ			; _STL::ios_base::good
; Function compile flags: /Ogsy
;	COMDAT ?good@ios_base@_STL@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@_STL@@QBE_NXZ PROC NEAR			; _STL::ios_base::good, COMDAT
; _this$ = ecx

; 180  :   bool good() const { return _M_iostate == 0; }

  00000	33 c0		 xor	 eax, eax
  00002	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  00005	0f 94 c0	 sete	 al
  00008	c3		 ret	 0
?good@ios_base@_STL@@QBE_NXZ ENDP			; _STL::ios_base::good
_TEXT	ENDS
PUBLIC	?_M_setstate_nothrow@ios_base@_STL@@IAEXH@Z	; _STL::ios_base::_M_setstate_nothrow
; Function compile flags: /Ogsy
;	COMDAT ?_M_setstate_nothrow@ios_base@_STL@@IAEXH@Z
_TEXT	SEGMENT
___state$ = 8						; size = 4
?_M_setstate_nothrow@ios_base@_STL@@IAEXH@Z PROC NEAR	; _STL::ios_base::_M_setstate_nothrow, COMDAT
; _this$ = ecx

; 193  :   void _M_setstate_nothrow(iostate __state) { _M_iostate |= __state; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___state$[esp-4]
  00004	09 41 08	 or	 DWORD PTR [ecx+8], eax
  00007	c2 04 00	 ret	 4
?_M_setstate_nothrow@ios_base@_STL@@IAEXH@Z ENDP	; _STL::ios_base::_M_setstate_nothrow
_TEXT	ENDS
PUBLIC	?_M_clear_nothrow@ios_base@_STL@@IAEXH@Z	; _STL::ios_base::_M_clear_nothrow
; Function compile flags: /Ogsy
;	COMDAT ?_M_clear_nothrow@ios_base@_STL@@IAEXH@Z
_TEXT	SEGMENT
___state$ = 8						; size = 4
?_M_clear_nothrow@ios_base@_STL@@IAEXH@Z PROC NEAR	; _STL::ios_base::_M_clear_nothrow, COMDAT
; _this$ = ecx

; 194  :   void _M_clear_nothrow(iostate __state) { _M_iostate = __state; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___state$[esp-4]
  00004	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00007	c2 04 00	 ret	 4
?_M_clear_nothrow@ios_base@_STL@@IAEXH@Z ENDP		; _STL::ios_base::_M_clear_nothrow
_TEXT	ENDS
PUBLIC	?_M_get_exception_mask@ios_base@_STL@@IBEHXZ	; _STL::ios_base::_M_get_exception_mask
; Function compile flags: /Ogsy
;	COMDAT ?_M_get_exception_mask@ios_base@_STL@@IBEHXZ
_TEXT	SEGMENT
?_M_get_exception_mask@ios_base@_STL@@IBEHXZ PROC NEAR	; _STL::ios_base::_M_get_exception_mask, COMDAT
; _this$ = ecx

; 195  :   iostate _M_get_exception_mask() const { return _M_exception_mask; }

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	c3		 ret	 0
?_M_get_exception_mask@ios_base@_STL@@IBEHXZ ENDP	; _STL::ios_base::_M_get_exception_mask
_TEXT	ENDS
PUBLIC	?_M_check_exception_mask@ios_base@_STL@@IAEXXZ	; _STL::ios_base::_M_check_exception_mask
EXTRN	?_M_throw_failure@ios_base@_STL@@IAEXXZ:NEAR	; _STL::ios_base::_M_throw_failure
; Function compile flags: /Ogsy
;	COMDAT ?_M_check_exception_mask@ios_base@_STL@@IAEXXZ
_TEXT	SEGMENT
?_M_check_exception_mask@ios_base@_STL@@IAEXXZ PROC NEAR ; _STL::ios_base::_M_check_exception_mask, COMDAT
; _this$ = ecx

; 198  :     if (_M_iostate & _M_exception_mask)

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	85 41 08	 test	 eax, DWORD PTR [ecx+8]
  00006	74 05		 je	 SHORT $L79498

; 199  :       _M_throw_failure(); 

  00008	e9 00 00 00 00	 jmp	 ?_M_throw_failure@ios_base@_STL@@IAEXXZ ; _STL::ios_base::_M_throw_failure
$L79498:

; 200  :   }

  0000d	c3		 ret	 0
?_M_check_exception_mask@ios_base@_STL@@IAEXXZ ENDP	; _STL::ios_base::_M_check_exception_mask
_TEXT	ENDS
PUBLIC	?IsUseActionStep@MActionInfo@@QAE_NXZ		; MActionInfo::IsUseActionStep
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mactioninfotable.h
;	COMDAT ?IsUseActionStep@MActionInfo@@QAE_NXZ
_TEXT	SEGMENT
?IsUseActionStep@MActionInfo@@QAE_NXZ PROC NEAR		; MActionInfo::IsUseActionStep, COMDAT
; _this$ = ecx

; 558  : 		bool		IsUseActionStep() { return m_bUseActionStep; }

  00000	8a 41 15	 mov	 al, BYTE PTR [ecx+21]
  00003	c3		 ret	 0
?IsUseActionStep@MActionInfo@@QAE_NXZ ENDP		; MActionInfo::IsUseActionStep
_TEXT	ENDS
PUBLIC	?SetChildMode@ACTION_INFO_NODE@@QAEXXZ		; ACTION_INFO_NODE::SetChildMode
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mactioninfotable.cpp
;	COMDAT ?SetChildMode@ACTION_INFO_NODE@@QAEXXZ
_TEXT	SEGMENT
?SetChildMode@ACTION_INFO_NODE@@QAEXXZ PROC NEAR	; ACTION_INFO_NODE::SetChildMode, COMDAT
; _this$ = ecx

; 30   : 	{
; 31   : 		EffectSpriteType += EFFECTSPRITETYPE_GREEN_BLOOD_DRAIN_1 - EFFECTSPRITETYPE_BLOOD_DRAIN_1;

  00000	33 c0		 xor	 eax, eax
  00002	66 8b 41 02	 mov	 ax, WORD PTR [ecx+2]
  00006	66 3d 18 00	 cmp	 ax, 24			; 00000018H
  0000a	72 0d		 jb	 SHORT $L109041

; 27   : 	// 하...하드코딩-_-;
; 28   : 	if(EffectSpriteType >= EFFECTSPRITETYPE_BLOOD_DRAIN_1 &&
; 29   : 		EffectSpriteType <= EFFECTSPRITETYPE_BLOOD_DRAIN_3)

  0000c	66 3d 1a 00	 cmp	 ax, 26			; 0000001aH
  00010	77 07		 ja	 SHORT $L109041

; 30   : 	{
; 31   : 		EffectSpriteType += EFFECTSPRITETYPE_GREEN_BLOOD_DRAIN_1 - EFFECTSPRITETYPE_BLOOD_DRAIN_1;

  00012	05 8c 01 00 00	 add	 eax, 396		; 0000018cH

; 32   : 	}
; 33   : 	else if(EffectSpriteType >= EFFECTSPRITETYPE_BLOOD_GROUND_1_1 &&

  00017	eb 78		 jmp	 SHORT $L110527
$L109041:

; 34   : 		EffectSpriteType <= EFFECTSPRITETYPE_BLOOD_GROUND_2_4)

  00019	66 3d 1b 0e	 cmp	 ax, 3611		; 00000e1bH
  0001d	72 0b		 jb	 SHORT $L109043
  0001f	66 3d 23 0e	 cmp	 ax, 3619		; 00000e23H
  00023	77 05		 ja	 SHORT $L109043

; 35   : 	{
; 36   : 		EffectSpriteType += EFFECTSPRITETYPE_GREEN_BLOOD_GROUND_1_1 - EFFECTSPRITETYPE_BLOOD_GROUND_1_1;

  00025	83 c0 13	 add	 eax, 19			; 00000013H

; 37   : 	}
; 38   : 	else if(EffectSpriteType >= EFFECTSPRITETYPE_BLOOD_SLAYER_1 &&

  00028	eb 67		 jmp	 SHORT $L110527
$L109043:

; 39   : 		EffectSpriteType <= EFFECTSPRITETYPE_BLOOD_SLAYER_3)

  0002a	66 3d 24 0e	 cmp	 ax, 3620		; 00000e24H
  0002e	72 21		 jb	 SHORT $L109045
  00030	66 3d 26 0e	 cmp	 ax, 3622		; 00000e26H
  00034	77 1b		 ja	 SHORT $L109045

; 40   : 	{
; 41   : 		EffectSpriteType = EFFECTSPRITETYPE_GREEN_BLOOD_SLAYER_1+((EffectSpriteType-EFFECTSPRITETYPE_BLOOD_SLAYER_1)+2)%3;

  00036	0f b7 c0	 movzx	 eax, ax
  00039	56		 push	 esi
  0003a	2d 22 0e 00 00	 sub	 eax, 3618		; 00000e22H
  0003f	6a 03		 push	 3
  00041	99		 cdq
  00042	5e		 pop	 esi
  00043	f7 fe		 idiv	 esi
  00045	5e		 pop	 esi
  00046	81 c2 37 0e 00
	00		 add	 edx, 3639		; 00000e37H
  0004c	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 60   : 	}
; 61   : 
; 62   : //	if (EffectSpriteType >=	EFFECTSPRITETYPE_BLOOD_GUN_1_1
; 63   : //		&&	EffectSpriteType <= EFFECTSPRITETYPE_BLOOD_DRAIN_3)
; 64   : //	{
; 65   : //		EffectSpriteType = EFFECTSPRITETYPE_NULL;
; 66   : //	}
; 67   : }

  00050	c3		 ret	 0
$L109045:

; 42   : 	}
; 43   : 	else if(EffectSpriteType >= EFFECTSPRITETYPE_BLOOD_GUN_1_1 &&
; 44   : 		EffectSpriteType <= EFFECTSPRITETYPE_BLOOD_HORIZONTAL_3)

  00051	66 3d 17 00	 cmp	 ax, 23			; 00000017H
  00055	77 07		 ja	 SHORT $L109047

; 45   : 	{
; 46   : 		EffectSpriteType += EFFECTSPRITETYPE_GREEN_BLOOD_GUN_1_1 - EFFECTSPRITETYPE_BLOOD_GUN_1_1;

  00057	05 88 01 00 00	 add	 eax, 392		; 00000188H

; 47   : 	}
; 48   : 	else if(EffectSpriteType >= EFFECTSPRITETYPE_BLOOD_VERTICAL_1 &&

  0005c	eb 33		 jmp	 SHORT $L110527
$L109047:

; 49   : 		EffectSpriteType <= EFFECTSPRITETYPE_BLOOD_VERTICAL_4)

  0005e	66 3d 1b 00	 cmp	 ax, 27			; 0000001bH
  00062	72 0d		 jb	 SHORT $L109049
  00064	66 3d 1e 00	 cmp	 ax, 30			; 0000001eH
  00068	77 07		 ja	 SHORT $L109049

; 50   : 	{
; 51   : 		EffectSpriteType += EFFECTSPRITETYPE_GREEN_BLOOD_VERTICAL_1 - EFFECTSPRITETYPE_BLOOD_VERTICAL_1;

  0006a	05 85 01 00 00	 add	 eax, 389		; 00000185H

; 52   : 	}
; 53   : 	else if(EffectSpriteType >= EFFECTSPRITETYPE_TRANSFUSION_1 && EffectSpriteType <= EFFECTSPRITETYPE_TRANSFUSION_3)

  0006f	eb 20		 jmp	 SHORT $L110527
$L109049:
  00071	66 3d 2b 0e	 cmp	 ax, 3627		; 00000e2bH
  00075	72 0b		 jb	 SHORT $L109051
  00077	66 3d 2d 0e	 cmp	 ax, 3629		; 00000e2dH
  0007b	77 05		 ja	 SHORT $L109051

; 54   : 	{
; 55   : 		EffectSpriteType += EFFECTSPRITETYPE_GREEN_TRANSFUSION_1 - EFFECTSPRITETYPE_TRANSFUSION_1;

  0007d	83 c0 0f	 add	 eax, 15			; 0000000fH

; 56   : 	}
; 57   : 	else if(EffectSpriteType >= EFFECTSPRITETYPE_VIOLENT_PHANTOM_BLOOD_1 && EffectSpriteType <= EFFECTSPRITETYPE_VIOLENT_PHANTOM_BLOOD_4)

  00080	eb 0f		 jmp	 SHORT $L110527
$L109051:
  00082	66 3d 03 04	 cmp	 ax, 1027		; 00000403H
  00086	72 0d		 jb	 SHORT $L109053
  00088	66 3d 06 04	 cmp	 ax, 1030		; 00000406H
  0008c	77 07		 ja	 SHORT $L109053

; 58   : 	{
; 59   : 		EffectSpriteType -= EFFECTSPRITETYPE_VIOLENT_PHANTOM_BLOOD_1 - EFFECTSPRITETYPE_VIOLENT_PHANTOM_BLOOD_TEEN_1;

  0008e	83 c0 fc	 add	 eax, -4			; fffffffcH
$L110527:
  00091	66 89 41 02	 mov	 WORD PTR [ecx+2], ax
$L109053:

; 60   : 	}
; 61   : 
; 62   : //	if (EffectSpriteType >=	EFFECTSPRITETYPE_BLOOD_GUN_1_1
; 63   : //		&&	EffectSpriteType <= EFFECTSPRITETYPE_BLOOD_DRAIN_3)
; 64   : //	{
; 65   : //		EffectSpriteType = EFFECTSPRITETYPE_NULL;
; 66   : //	}
; 67   : }

  00095	c3		 ret	 0
?SetChildMode@ACTION_INFO_NODE@@QAEXXZ ENDP		; ACTION_INFO_NODE::SetChildMode
_TEXT	ENDS
PUBLIC	?LoadFromFile@ACTION_INFO_NODE@@QAEXAAVivfstream@@@Z ; ACTION_INFO_NODE::LoadFromFile
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFile@ACTION_INFO_NODE@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
?LoadFromFile@ACTION_INFO_NODE@@QAEXAAVivfstream@@@Z PROC NEAR ; ACTION_INFO_NODE::LoadFromFile, COMDAT
; _this$ = ecx

; 91   : {			

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 92   : 	file.read((char*)&EffectGeneratorID, SIZE_EFFECTGENERATORID);

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _file$[esp+8]
  00007	57		 push	 edi
  00008	33 ed		 xor	 ebp, ebp
  0000a	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  0000d	6a 02		 push	 2
  0000f	8b f9		 mov	 edi, ecx
  00011	5b		 pop	 ebx
  00012	74 0a		 je	 SHORT $L110533
  00014	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00017	8b 01		 mov	 eax, DWORD PTR [ecx]
  00019	53		 push	 ebx
  0001a	57		 push	 edi
  0001b	ff 50 10	 call	 DWORD PTR [eax+16]
$L110533:

; 93   : 	if(EffectGeneratorID == 50)

  0001e	66 83 3f 32	 cmp	 WORD PTR [edi], 50	; 00000032H
  00022	75 03		 jne	 SHORT $L109110

; 94   : 		EffectGeneratorID =0;

  00024	66 89 2f	 mov	 WORD PTR [edi], bp
$L109110:

; 95   : 	if(EffectGeneratorID == 47)

  00027	66 83 3f 2f	 cmp	 WORD PTR [edi], 47	; 0000002fH
  0002b	75 05		 jne	 SHORT $L109111

; 96   : 		EffectGeneratorID =11;

  0002d	66 c7 07 0b 00	 mov	 WORD PTR [edi], 11	; 0000000bH
$L109111:

; 97   : 	file.read((char*)&EffectSpriteType, SIZE_EFFECTSPRITETYPE);

  00032	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  00035	74 7b		 je	 SHORT $L110568
  00037	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003c	53		 push	 ebx
  0003d	8d 57 02	 lea	 edx, DWORD PTR [edi+2]
  00040	52		 push	 edx
  00041	ff 50 10	 call	 DWORD PTR [eax+16]

; 98   : 	file.read((char*)&Step, 2);

  00044	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  00047	74 69		 je	 SHORT $L110568
  00049	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004e	53		 push	 ebx
  0004f	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00052	52		 push	 edx
  00053	ff 50 10	 call	 DWORD PTR [eax+16]

; 99   : 	file.read((char*)&Count, 2);

  00056	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  00059	74 57		 je	 SHORT $L110568
  0005b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00060	53		 push	 ebx
  00061	8d 57 06	 lea	 edx, DWORD PTR [edi+6]
  00064	52		 push	 edx
  00065	ff 50 10	 call	 DWORD PTR [eax+16]

; 100  : 	file.read((char*)&LinkCount, 2);

  00068	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  0006b	74 45		 je	 SHORT $L110568
  0006d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00070	8b 01		 mov	 eax, DWORD PTR [ecx]
  00072	53		 push	 ebx
  00073	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  00076	52		 push	 edx
  00077	ff 50 10	 call	 DWORD PTR [eax+16]

; 101  : 	file.read((char*)&SoundID, SIZE_SOUNDID);

  0007a	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  0007d	74 33		 je	 SHORT $L110568
  0007f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00082	8b 01		 mov	 eax, DWORD PTR [ecx]
  00084	53		 push	 ebx
  00085	8d 57 0a	 lea	 edx, DWORD PTR [edi+10]
  00088	52		 push	 edx
  00089	ff 50 10	 call	 DWORD PTR [eax+16]

; 102  : 	//file.read((char*)&Light, 1);
; 103  : 	file.read((char*)&bDelayNode, 1);

  0008c	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  0008f	74 21		 je	 SHORT $L110568
  00091	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00094	8b 01		 mov	 eax, DWORD PTR [ecx]
  00096	6a 01		 push	 1
  00098	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  0009b	52		 push	 edx
  0009c	ff 50 10	 call	 DWORD PTR [eax+16]

; 104  : 	file.read((char*)&bResultTime, 1);

  0009f	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  000a2	74 0e		 je	 SHORT $L110568
  000a4	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000a7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a9	6a 01		 push	 1
  000ab	83 c7 0d	 add	 edi, 13			; 0000000dH
  000ae	57		 push	 edi
  000af	ff 50 10	 call	 DWORD PTR [eax+16]
$L110568:
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5d		 pop	 ebp
  000b5	5b		 pop	 ebx

; 105  : }

  000b6	c2 04 00	 ret	 4
?LoadFromFile@ACTION_INFO_NODE@@QAEXAAVivfstream@@@Z ENDP ; ACTION_INFO_NODE::LoadFromFile
_TEXT	ENDS
PUBLIC	?SetChildMode@MActionInfo@@QAEXXZ		; MActionInfo::SetChildMode
; Function compile flags: /Ogsy
;	COMDAT ?SetChildMode@MActionInfo@@QAEXXZ
_TEXT	SEGMENT
?SetChildMode@MActionInfo@@QAEXXZ PROC NEAR		; MActionInfo::SetChildMode, COMDAT
; _this$ = ecx

; 225  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 226  : 	// 하...하드코딩-_-;
; 227  : 
; 228  : 	// male
; 229  : 	if(m_ActionEffectSpriteType >= EFFECTSPRITETYPE_BLOOD_GUN_1_1 &&
; 230  : 		m_ActionEffectSpriteType <= EFFECTSPRITETYPE_BLOOD_HORIZONTAL_3)
; 231  : 	{
; 232  : 		m_ActionEffectSpriteType += EFFECTSPRITETYPE_GREEN_BLOOD_GUN_1_1 - EFFECTSPRITETYPE_BLOOD_GUN_1_1;

  00004	33 c0		 xor	 eax, eax
  00006	66 8b 46 2e	 mov	 ax, WORD PTR [esi+46]
  0000a	66 3d 17 00	 cmp	 ax, 23			; 00000017H
  0000e	57		 push	 edi
  0000f	77 07		 ja	 SHORT $L109150
  00011	05 88 01 00 00	 add	 eax, 392		; 00000188H

; 233  : 	}
; 234  : 	else if(m_ActionEffectSpriteType >= EFFECTSPRITETYPE_BLOOD_VERTICAL_1 &&

  00016	eb 11		 jmp	 SHORT $L110582
$L109150:

; 235  : 		m_ActionEffectSpriteType <= EFFECTSPRITETYPE_BLOOD_VERTICAL_4)

  00018	66 3d 1b 00	 cmp	 ax, 27			; 0000001bH
  0001c	72 0f		 jb	 SHORT $L109152
  0001e	66 3d 1e 00	 cmp	 ax, 30			; 0000001eH
  00022	77 09		 ja	 SHORT $L109152

; 236  : 	{
; 237  : 		m_ActionEffectSpriteType += EFFECTSPRITETYPE_GREEN_BLOOD_VERTICAL_1 - EFFECTSPRITETYPE_BLOOD_VERTICAL_1;

  00024	05 85 01 00 00	 add	 eax, 389		; 00000185H
$L110582:
  00029	66 89 46 2e	 mov	 WORD PTR [esi+46], ax
$L109152:

; 238  : 	}
; 239  : //	else if(m_ActionEffectSpriteType >= EFFECTSPRITETYPE_BLOOD_DRAIN_1 &&
; 240  : //		m_ActionEffectSpriteType <= EFFECTSPRITETYPE_BLOOD_DRAIN_3)
; 241  : //	{
; 242  : //		m_ActionEffectSpriteType += EFFECTSPRITETYPE_GREEN_BLOOD_DRAIN_1 - EFFECTSPRITETYPE_BLOOD_DRAIN_1;
; 243  : //	}
; 244  : 	
; 245  : 	// female
; 246  : 	if(m_ActionEffectSpriteTypeFemale >= EFFECTSPRITETYPE_BLOOD_GUN_1_1 &&
; 247  : 		m_ActionEffectSpriteTypeFemale <= EFFECTSPRITETYPE_BLOOD_HORIZONTAL_3)
; 248  : 	{
; 249  : 		m_ActionEffectSpriteTypeFemale += EFFECTSPRITETYPE_GREEN_BLOOD_GUN_1_1 - EFFECTSPRITETYPE_BLOOD_GUN_1_1;

  0002d	33 c0		 xor	 eax, eax
  0002f	66 8b 46 30	 mov	 ax, WORD PTR [esi+48]
  00033	66 3d 17 00	 cmp	 ax, 23			; 00000017H
  00037	77 07		 ja	 SHORT $L109153
  00039	05 88 01 00 00	 add	 eax, 392		; 00000188H

; 250  : 	}
; 251  : 	else if(m_ActionEffectSpriteTypeFemale >= EFFECTSPRITETYPE_BLOOD_VERTICAL_1 &&

  0003e	eb 11		 jmp	 SHORT $L110583
$L109153:

; 252  : 		m_ActionEffectSpriteTypeFemale <= EFFECTSPRITETYPE_BLOOD_VERTICAL_4)

  00040	66 3d 1b 00	 cmp	 ax, 27			; 0000001bH
  00044	72 0f		 jb	 SHORT $L109155
  00046	66 3d 1e 00	 cmp	 ax, 30			; 0000001eH
  0004a	77 09		 ja	 SHORT $L109155

; 253  : 	{
; 254  : 		m_ActionEffectSpriteTypeFemale += EFFECTSPRITETYPE_GREEN_BLOOD_VERTICAL_1 - EFFECTSPRITETYPE_BLOOD_VERTICAL_1;

  0004c	05 85 01 00 00	 add	 eax, 389		; 00000185H
$L110583:
  00051	66 89 46 30	 mov	 WORD PTR [esi+48], ax
$L109155:

; 255  : 	}
; 256  : //	else if(m_ActionEffectSpriteTypeFemale >= EFFECTSPRITETYPE_BLOOD_DRAIN_1 &&
; 257  : //		m_ActionEffectSpriteTypeFemale <= EFFECTSPRITETYPE_BLOOD_DRAIN_3)
; 258  : //	{
; 259  : //		m_ActionEffectSpriteTypeFemale += EFFECTSPRITETYPE_GREEN_BLOOD_DRAIN_1 - EFFECTSPRITETYPE_BLOOD_DRAIN_1;
; 260  : //	}
; 261  : 
; 262  : //	if (m_ActionEffectSpriteType >=	EFFECTSPRITETYPE_BLOOD_GUN_1_1
; 263  : //		&&	m_ActionEffectSpriteType <= EFFECTSPRITETYPE_BLOOD_DRAIN_3)
; 264  : //	{
; 265  : //		m_ActionEffectSpriteType = EFFECTSPRITETYPE_NULL;
; 266  : //	}
; 267  : //
; 268  : //	if (m_ActionEffectSpriteTypeFemale >=	EFFECTSPRITETYPE_BLOOD_GUN_1_1
; 269  : //		&&	m_ActionEffectSpriteTypeFemale <= EFFECTSPRITETYPE_BLOOD_DRAIN_3)
; 270  : //	{
; 271  : //		m_ActionEffectSpriteTypeFemale = EFFECTSPRITETYPE_NULL;
; 272  : //	}
; 273  : 
; 274  : 	for (int i=0; i<m_Size; i++)

  00055	33 db		 xor	 ebx, ebx
  00057	33 ff		 xor	 edi, edi
  00059	39 1e		 cmp	 DWORD PTR [esi], ebx
  0005b	7e 12		 jle	 SHORT $L109159
$L109157:
  0005d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00060	03 cb		 add	 ecx, ebx

; 275  : 	{
; 276  : 		m_pTypeInfo[i].SetChildMode();

  00062	e8 00 00 00 00	 call	 ?SetChildMode@ACTION_INFO_NODE@@QAEXXZ ; ACTION_INFO_NODE::SetChildMode
  00067	47		 inc	 edi
  00068	83 c3 10	 add	 ebx, 16			; 00000010H
  0006b	3b 3e		 cmp	 edi, DWORD PTR [esi]
  0006d	7c ee		 jl	 SHORT $L109157
$L109159:
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 277  : 	}	
; 278  : }

  00072	c3		 ret	 0
?SetChildMode@MActionInfo@@QAEXXZ ENDP			; MActionInfo::SetChildMode
_TEXT	ENDS
PUBLIC	?pubsync@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@QAEHXZ ; _STL::basic_streambuf<char,_STL::char_traits<char> >::pubsync
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_streambuf.h
;	COMDAT ?pubsync@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@QAEHXZ PROC NEAR ; _STL::basic_streambuf<char,_STL::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 411  :   int pubsync() { return this->sync(); }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 10	 jmp	 DWORD PTR [eax+16]
?pubsync@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@QAEHXZ ENDP ; _STL::basic_streambuf<char,_STL::char_traits<char> >::pubsync
_TEXT	ENDS
PUBLIC	?sputn@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@QAEHPBDH@Z ; _STL::basic_streambuf<char,_STL::char_traits<char> >::sputn
; Function compile flags: /Ogsy
;	COMDAT ?sputn@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@QAEHPBDH@Z
_TEXT	SEGMENT
___s$ = 8						; size = 4
___n$ = 12						; size = 4
?sputn@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@QAEHPBDH@Z PROC NEAR ; _STL::basic_streambuf<char,_STL::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 441  :     { return this->xsputn(__s, __n); }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 28	 jmp	 DWORD PTR [eax+40]
?sputn@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@QAEHPBDH@Z ENDP ; _STL::basic_streambuf<char,_STL::char_traits<char> >::sputn
_TEXT	ENDS
PUBLIC	?SetActionStep@MActionInfo@@QAEXEG@Z		; MActionInfo::SetActionStep
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mactioninfotable.cpp
;	COMDAT ?SetActionStep@MActionInfo@@QAEXEG@Z
_TEXT	SEGMENT
_step$ = 8						; size = 1
_action$ = 12						; size = 2
?SetActionStep@MActionInfo@@QAEXEG@Z PROC NEAR		; MActionInfo::SetActionStep, COMDAT
; _this$ = ecx

; 551  : 	if(!IsUseActionStep() )

  00000	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00004	74 16		 je	 SHORT $L109333

; 552  : 		return;
; 553  : 
; 554  : 	if(step < 0 || step >= MAX_ACTION_STEP )

  00006	80 7c 24 04 05	 cmp	 BYTE PTR _step$[esp-4], 5
  0000b	73 0f		 jae	 SHORT $L109333

; 555  : 		return;
; 556  : 
; 557  : 	m_ActionStep[step] = action;

  0000d	0f b6 44 24 04	 movzx	 eax, BYTE PTR _step$[esp-4]
  00012	66 8b 54 24 08	 mov	 dx, WORD PTR _action$[esp-4]
  00017	66 89 54 41 16	 mov	 WORD PTR [ecx+eax*2+22], dx
$L109333:

; 558  : }

  0001c	c2 08 00	 ret	 8
?SetActionStep@MActionInfo@@QAEXEG@Z ENDP		; MActionInfo::SetActionStep
_TEXT	ENDS
PUBLIC	?SetComboSkillActionStep@MActionInfo@@QAEXGGGG@Z ; MActionInfo::SetComboSkillActionStep
; Function compile flags: /Ogsy
;	COMDAT ?SetComboSkillActionStep@MActionInfo@@QAEXGGGG@Z
_TEXT	SEGMENT
_ComboStep1$ = 8					; size = 2
_ComboStep2$ = 12					; size = 2
_ComboStep3$ = 16					; size = 2
_ComboStep4$ = 20					; size = 2
?SetComboSkillActionStep@MActionInfo@@QAEXGGGG@Z PROC NEAR ; MActionInfo::SetComboSkillActionStep, COMDAT
; _this$ = ecx

; 570  : 	if(!GetComboAttackSkill())

  00000	83 79 78 00	 cmp	 DWORD PTR [ecx+120], 0
  00004	74 24		 je	 SHORT $L109340

; 571  : 		return ;
; 572  : 
; 573  : 	m_ComboSkillActionStep[0] = ComboStep1 ; 

  00006	66 8b 44 24 04	 mov	 ax, WORD PTR _ComboStep1$[esp-4]
  0000b	66 89 41 22	 mov	 WORD PTR [ecx+34], ax

; 574  : 	m_ComboSkillActionStep[2] = ComboStep2 ; 

  0000f	66 8b 44 24 08	 mov	 ax, WORD PTR _ComboStep2$[esp-4]
  00014	66 89 41 26	 mov	 WORD PTR [ecx+38], ax

; 575  : 	m_ComboSkillActionStep[3] = ComboStep3 ; 

  00018	66 8b 44 24 0c	 mov	 ax, WORD PTR _ComboStep3$[esp-4]
  0001d	66 89 41 28	 mov	 WORD PTR [ecx+40], ax

; 576  : 	m_ComboSkillActionStep[4] = ComboStep4 ; 

  00021	66 8b 44 24 10	 mov	 ax, WORD PTR _ComboStep4$[esp-4]
  00026	66 89 41 2a	 mov	 WORD PTR [ecx+42], ax
$L109340:

; 577  : 
; 578  : }

  0002a	c2 10 00	 ret	 16			; 00000010H
?SetComboSkillActionStep@MActionInfo@@QAEXGGGG@Z ENDP	; MActionInfo::SetComboSkillActionStep
_TEXT	ENDS
PUBLIC	?GetComboSkillActionStep@MActionInfo@@QAEGE@Z	; MActionInfo::GetComboSkillActionStep
; Function compile flags: /Ogsy
;	COMDAT ?GetComboSkillActionStep@MActionInfo@@QAEGE@Z
_TEXT	SEGMENT
_byStep$ = 8						; size = 1
?GetComboSkillActionStep@MActionInfo@@QAEGE@Z PROC NEAR	; MActionInfo::GetComboSkillActionStep, COMDAT
; _this$ = ecx

; 589  : 	return	m_ComboSkillActionStep[byStep-1]  ; 

  00000	0f b6 44 24 04	 movzx	 eax, BYTE PTR _byStep$[esp-4]
  00005	66 8b 44 41 20	 mov	 ax, WORD PTR [ecx+eax*2+32]

; 590  : }

  0000a	c2 04 00	 ret	 4
?GetComboSkillActionStep@MActionInfo@@QAEGE@Z ENDP	; MActionInfo::GetComboSkillActionStep
_TEXT	ENDS
PUBLIC	?GetActionStep@MActionInfo@@QAEGE@Z		; MActionInfo::GetActionStep
; Function compile flags: /Ogsy
;	COMDAT ?GetActionStep@MActionInfo@@QAEGE@Z
_TEXT	SEGMENT
_step$ = 8						; size = 1
?GetActionStep@MActionInfo@@QAEGE@Z PROC NEAR		; MActionInfo::GetActionStep, COMDAT
; _this$ = ecx

; 595  : 	if(!IsUseActionStep() || step < 0 || step >= MAX_ACTION_STEP )

  00000	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00004	74 13		 je	 SHORT $L109351
  00006	80 7c 24 04 05	 cmp	 BYTE PTR _step$[esp-4], 5
  0000b	73 0c		 jae	 SHORT $L109351

; 597  : 
; 598  : 	return m_ActionStep[step];

  0000d	0f b6 44 24 04	 movzx	 eax, BYTE PTR _step$[esp-4]
  00012	66 8b 44 41 16	 mov	 ax, WORD PTR [ecx+eax*2+22]
  00017	eb 04		 jmp	 SHORT $L109349
$L109351:

; 596  : 		return ACTIONINFO_NULL;

  00019	66 0d ff ff	 or	 ax, 65535		; 0000ffffH
$L109349:

; 599  : }

  0001d	c2 04 00	 ret	 4
?GetActionStep@MActionInfo@@QAEGE@Z ENDP		; MActionInfo::GetActionStep
_TEXT	ENDS
PUBLIC	?SetParentActionInfo@MActionInfo@@QAEXG@Z	; MActionInfo::SetParentActionInfo
; Function compile flags: /Ogsy
;	COMDAT ?SetParentActionInfo@MActionInfo@@QAEXG@Z
_TEXT	SEGMENT
_Parent$ = 8						; size = 2
?SetParentActionInfo@MActionInfo@@QAEXG@Z PROC NEAR	; MActionInfo::SetParentActionInfo, COMDAT
; _this$ = ecx

; 603  : 	m_Parent = Parent;

  00000	66 8b 44 24 04	 mov	 ax, WORD PTR _Parent$[esp-4]
  00005	66 89 41 20	 mov	 WORD PTR [ecx+32], ax

; 604  : }

  00009	c2 04 00	 ret	 4
?SetParentActionInfo@MActionInfo@@QAEXG@Z ENDP		; MActionInfo::SetParentActionInfo
_TEXT	ENDS
PUBLIC	?GetParentActionInfo@MActionInfo@@QAEGXZ	; MActionInfo::GetParentActionInfo
; Function compile flags: /Ogsy
;	COMDAT ?GetParentActionInfo@MActionInfo@@QAEGXZ
_TEXT	SEGMENT
?GetParentActionInfo@MActionInfo@@QAEGXZ PROC NEAR	; MActionInfo::GetParentActionInfo, COMDAT
; _this$ = ecx

; 608  : 	return m_Parent;

  00000	66 8b 41 20	 mov	 ax, WORD PTR [ecx+32]

; 609  : }

  00004	c3		 ret	 0
?GetParentActionInfo@MActionInfo@@QAEGXZ ENDP		; MActionInfo::GetParentActionInfo
_TEXT	ENDS
PUBLIC	?SetComboSkillStartFrame@MActionInfo@@QAEXHHHHH@Z ; MActionInfo::SetComboSkillStartFrame
; Function compile flags: /Ogsy
;	COMDAT ?SetComboSkillStartFrame@MActionInfo@@QAEXHHHHH@Z
_TEXT	SEGMENT
_speed$ = 8						; size = 4
_Step1$ = 12						; size = 4
_Step2$ = 16						; size = 4
_Step3$ = 20						; size = 4
_Step4$ = 24						; size = 4
?SetComboSkillStartFrame@MActionInfo@@QAEXHHHHH@Z PROC NEAR ; MActionInfo::SetComboSkillStartFrame, COMDAT
; _this$ = ecx

; 614  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 615  : 	m_ComboSkillStartFrame[speed][0] = 	Step1 ; 

  00003	8b 45 08	 mov	 eax, DWORD PTR _speed$[ebp]
  00006	8d 50 0a	 lea	 edx, DWORD PTR [eax+10]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _Step1$[ebp]
  0000d	c1 e2 04	 shl	 edx, 4
  00010	89 34 0a	 mov	 DWORD PTR [edx+ecx], esi

; 616  : 	m_ComboSkillStartFrame[speed][1] = 	Step2 ;

  00013	c1 e0 04	 shl	 eax, 4
  00016	03 c1		 add	 eax, ecx
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _Step2$[ebp]
  0001b	89 88 a4 00 00
	00		 mov	 DWORD PTR [eax+164], ecx

; 617  : 	m_ComboSkillStartFrame[speed][2] = 	Step3 ;

  00021	8b 4d 14	 mov	 ecx, DWORD PTR _Step3$[ebp]
  00024	89 88 a8 00 00
	00		 mov	 DWORD PTR [eax+168], ecx

; 618  : 	m_ComboSkillStartFrame[speed][3] = 	Step4 ;

  0002a	8b 4d 18	 mov	 ecx, DWORD PTR _Step4$[ebp]
  0002d	89 88 ac 00 00
	00		 mov	 DWORD PTR [eax+172], ecx
  00033	5e		 pop	 esi

; 619  : }

  00034	5d		 pop	 ebp
  00035	c2 14 00	 ret	 20			; 00000014H
?SetComboSkillStartFrame@MActionInfo@@QAEXHHHHH@Z ENDP	; MActionInfo::SetComboSkillStartFrame
_TEXT	ENDS
PUBLIC	?SetChildMode@MActionInfoTable@@QAEXXZ		; MActionInfoTable::SetChildMode
; Function compile flags: /Ogsy
;	COMDAT ?SetChildMode@MActionInfoTable@@QAEXXZ
_TEXT	SEGMENT
?SetChildMode@MActionInfoTable@@QAEXXZ PROC NEAR	; MActionInfoTable::SetChildMode, COMDAT
; _this$ = ecx

; 647  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f1		 mov	 esi, ecx

; 648  : 	for (int i=0; i<m_Size; i++)

  00005	33 db		 xor	 ebx, ebx
  00007	33 ff		 xor	 edi, edi
  00009	39 1e		 cmp	 DWORD PTR [esi], ebx
  0000b	7e 15		 jle	 SHORT $L109379
$L109377:

; 649  : 	{
; 650  : 		m_pTypeInfo[i].SetChildMode();

  0000d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00010	03 cb		 add	 ecx, ebx
  00012	e8 00 00 00 00	 call	 ?SetChildMode@MActionInfo@@QAEXXZ ; MActionInfo::SetChildMode
  00017	47		 inc	 edi
  00018	81 c3 38 01 00
	00		 add	 ebx, 312		; 00000138H
  0001e	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00020	7c eb		 jl	 SHORT $L109377
$L109379:

; 651  : 	}
; 652  : 
; 653  : 	m_pTypeInfo[RESULT_VAMPIRE_DIE].SetStartFrameAll( 8 );	

  00022	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00025	6a 08		 push	 8
  00027	5f		 pop	 edi
  00028	bb b0 6a 09 00	 mov	 ebx, 617136		; 00096ab0H
  0002d	57		 push	 edi
  0002e	03 cb		 add	 ecx, ebx
  00030	e8 00 00 00 00	 call	 ?SetStartFrameAll@MActionInfo@@QAEXH@Z ; MActionInfo::SetStartFrameAll

; 654  : 	m_pTypeInfo[RESULT_VAMPIRE_DIE].SetCastingStartFrameAll( 8 );

  00035	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00038	03 c3		 add	 eax, ebx
  0003a	89 78 3c	 mov	 DWORD PTR [eax+60], edi
  0003d	89 78 38	 mov	 DWORD PTR [eax+56], edi
  00040	89 78 34	 mov	 DWORD PTR [eax+52], edi
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx

; 655  : }

  00046	c3		 ret	 0
?SetChildMode@MActionInfoTable@@QAEXXZ ENDP		; MActionInfoTable::SetChildMode
_TEXT	ENDS
PUBLIC	??0?$CTypeTable@VACTION_INFO_NODE@@@@QAE@XZ	; CTypeTable<ACTION_INFO_NODE>::CTypeTable<ACTION_INFO_NODE>
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\ctypetable.h
;	COMDAT ??0?$CTypeTable@VACTION_INFO_NODE@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CTypeTable@VACTION_INFO_NODE@@@@QAE@XZ PROC NEAR	; CTypeTable<ACTION_INFO_NODE>::CTypeTable<ACTION_INFO_NODE>, COMDAT
; _this$ = ecx

; 64   : {

  00000	8b c1		 mov	 eax, ecx

; 65   : 	m_pTypeInfo	= NULL;

  00002	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 66   : 	m_Size		= 0;

  00006	83 20 00	 and	 DWORD PTR [eax], 0

; 67   : }

  00009	c3		 ret	 0
??0?$CTypeTable@VACTION_INFO_NODE@@@@QAE@XZ ENDP	; CTypeTable<ACTION_INFO_NODE>::CTypeTable<ACTION_INFO_NODE>
_TEXT	ENDS
PUBLIC	??1?$CBitAttribute@EI@@QAE@XZ			; CBitAttribute<unsigned char,unsigned int>::~CBitAttribute<unsigned char,unsigned int>
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\bitattribute.h
;	COMDAT ??1?$CBitAttribute@EI@@QAE@XZ
_TEXT	SEGMENT
??1?$CBitAttribute@EI@@QAE@XZ PROC NEAR			; CBitAttribute<unsigned char,unsigned int>::~CBitAttribute<unsigned char,unsigned int>, COMDAT
; _this$ = ecx

; 66   : 
; 67   : }

  00000	c3		 ret	 0
??1?$CBitAttribute@EI@@QAE@XZ ENDP			; CBitAttribute<unsigned char,unsigned int>::~CBitAttribute<unsigned char,unsigned int>
_TEXT	ENDS
PUBLIC	??4?$CBitAttribute@EI@@QAEEE@Z			; CBitAttribute<unsigned char,unsigned int>::operator=
; Function compile flags: /Ogsy
;	COMDAT ??4?$CBitAttribute@EI@@QAEEE@Z
_TEXT	SEGMENT
_attr$ = 8						; size = 1
??4?$CBitAttribute@EI@@QAEEE@Z PROC NEAR		; CBitAttribute<unsigned char,unsigned int>::operator=, COMDAT
; _this$ = ecx

; 72   : 	return m_nAttribute = attr;

  00000	8a 44 24 04	 mov	 al, BYTE PTR _attr$[esp-4]
  00004	88 01		 mov	 BYTE PTR [ecx], al

; 73   : }

  00006	c2 04 00	 ret	 4
??4?$CBitAttribute@EI@@QAEEE@Z ENDP			; CBitAttribute<unsigned char,unsigned int>::operator=
_TEXT	ENDS
PUBLIC	??0?$CTypeTable@VMActionInfo@@@@QAE@XZ		; CTypeTable<MActionInfo>::CTypeTable<MActionInfo>
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\ctypetable.h
;	COMDAT ??0?$CTypeTable@VMActionInfo@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CTypeTable@VMActionInfo@@@@QAE@XZ PROC NEAR	; CTypeTable<MActionInfo>::CTypeTable<MActionInfo>, COMDAT
; _this$ = ecx

; 64   : {

  00000	8b c1		 mov	 eax, ecx

; 65   : 	m_pTypeInfo	= NULL;

  00002	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 66   : 	m_Size		= 0;

  00006	83 20 00	 and	 DWORD PTR [eax], 0

; 67   : }

  00009	c3		 ret	 0
??0?$CTypeTable@VMActionInfo@@@@QAE@XZ ENDP		; CTypeTable<MActionInfo>::CTypeTable<MActionInfo>
_TEXT	ENDS
PUBLIC	?rdbuf@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QBEPAV?$basic_streambuf@DV?$char_traits@D@_STL@@@2@XZ ; _STL::basic_ios<char,_STL::char_traits<char> >::rdbuf
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_ios.h
;	COMDAT ?rdbuf@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QBEPAV?$basic_streambuf@DV?$char_traits@D@_STL@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QBEPAV?$basic_streambuf@DV?$char_traits@D@_STL@@@2@XZ PROC NEAR ; _STL::basic_ios<char,_STL::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 72   :     { return _M_streambuf; }

  00000	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
  00003	c3		 ret	 0
?rdbuf@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QBEPAV?$basic_streambuf@DV?$char_traits@D@_STL@@@2@XZ ENDP ; _STL::basic_ios<char,_STL::char_traits<char> >::rdbuf
_TEXT	ENDS
PUBLIC	??Bsentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ ; _STL::basic_ostream<char,_STL::char_traits<char> >::sentry::operator bool
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_ostream.h
;	COMDAT ??Bsentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ PROC NEAR ; _STL::basic_ostream<char,_STL::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 176  :       operator bool() const { return _M_ok; }

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ ENDP ; _STL::basic_ostream<char,_STL::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
PUBLIC	?clear@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z ; _STL::basic_ios<char,_STL::char_traits<char> >::clear
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_ios.h
;	COMDAT ?clear@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z
_TEXT	SEGMENT
___state$ = 8						; size = 4
?clear@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z PROC NEAR ; _STL::basic_ios<char,_STL::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 91   :     _M_clear_nothrow(this->rdbuf() ? __state : iostate(__state|ios_base::badbit));

  00000	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00004	8b 44 24 04	 mov	 eax, DWORD PTR ___state$[esp-4]
  00008	75 03		 jne	 SHORT $L110655
  0000a	83 c8 01	 or	 eax, 1
$L110655:

; 92   :     _M_check_exception_mask();

  0000d	85 41 14	 test	 DWORD PTR [ecx+20], eax
  00010	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00013	74 05		 je	 SHORT $L110667
  00015	e8 00 00 00 00	 call	 ?_M_throw_failure@ios_base@_STL@@IAEXXZ ; _STL::ios_base::_M_throw_failure
$L110667:

; 93   :   }

  0001a	c2 04 00	 ret	 4
?clear@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z ENDP ; _STL::basic_ios<char,_STL::char_traits<char> >::clear
_TEXT	ENDS
PUBLIC	?_M_handle_exception@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z ; _STL::basic_ios<char,_STL::char_traits<char> >::_M_handle_exception
EXTRN	__CxxThrowException@8:NEAR
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_ios.c
;	COMDAT ?_M_handle_exception@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z
_TEXT	SEGMENT
___flag$ = 8						; size = 4
?_M_handle_exception@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z PROC NEAR ; _STL::basic_ios<char,_STL::char_traits<char> >::_M_handle_exception, COMDAT
; _this$ = ecx

; 118  :   this->_M_setstate_nothrow(__flag);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___flag$[esp-4]
  00004	09 41 08	 or	 DWORD PTR [ecx+8], eax

; 119  :   if (this->_M_get_exception_mask() & __flag)

  00007	85 41 14	 test	 DWORD PTR [ecx+20], eax
  0000a	74 09		 je	 SHORT $L109825

; 120  :     _STLP_RETHROW;

  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	e8 00 00 00 00	 call	 __CxxThrowException@8
$L110680:
$L109825:

; 121  : }

  00015	c2 04 00	 ret	 4
$L110679:
?_M_handle_exception@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z ENDP ; _STL::basic_ios<char,_STL::char_traits<char> >::_M_handle_exception
_TEXT	ENDS
PUBLIC	?SetNULL@?$CBitAttribute@EI@@QAEXXZ		; CBitAttribute<unsigned char,unsigned int>::SetNULL
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\bitattribute.h
;	COMDAT ?SetNULL@?$CBitAttribute@EI@@QAEXXZ
_TEXT	SEGMENT
?SetNULL@?$CBitAttribute@EI@@QAEXXZ PROC NEAR		; CBitAttribute<unsigned char,unsigned int>::SetNULL, COMDAT
; _this$ = ecx

; 79   : 	m_nAttribute = 0;

  00000	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 80   : }

  00003	c3		 ret	 0
?SetNULL@?$CBitAttribute@EI@@QAEXXZ ENDP		; CBitAttribute<unsigned char,unsigned int>::SetNULL
_TEXT	ENDS
PUBLIC	??_EACTION_INFO_NODE@@QAEPAXI@Z			; ACTION_INFO_NODE::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Ogsy
;	COMDAT ??_EACTION_INFO_NODE@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_EACTION_INFO_NODE@@QAEPAXI@Z PROC NEAR		; ACTION_INFO_NODE::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	74 24		 je	 SHORT $L109935
  0000d	56		 push	 esi
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??1ACTION_INFO_NODE@@QAE@XZ ; ACTION_INFO_NODE::~ACTION_INFO_NODE
  00013	8d 77 fc	 lea	 esi, DWORD PTR [edi-4]
  00016	ff 36		 push	 DWORD PTR [esi]
  00018	6a 10		 push	 16			; 00000010H
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00020	f6 c3 01	 test	 bl, 1
  00023	74 07		 je	 SHORT $L109936
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002b	59		 pop	 ecx
$L109936:
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	eb 0e		 jmp	 SHORT $L109934
$L109935:
  00031	f6 c3 01	 test	 bl, 1
  00034	74 07		 je	 SHORT $L109938
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	59		 pop	 ecx
$L109938:
  0003d	8b c7		 mov	 eax, edi
$L109934:
  0003f	5f		 pop	 edi
  00040	5b		 pop	 ebx
  00041	c2 04 00	 ret	 4
??_EACTION_INFO_NODE@@QAEPAXI@Z ENDP			; ACTION_INFO_NODE::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?tie@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QBEPAV?$basic_ostream@DV?$char_traits@D@_STL@@@2@XZ ; _STL::basic_ios<char,_STL::char_traits<char> >::tie
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_ios.h
;	COMDAT ?tie@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QBEPAV?$basic_ostream@DV?$char_traits@D@_STL@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QBEPAV?$basic_ostream@DV?$char_traits@D@_STL@@@2@XZ PROC NEAR ; _STL::basic_ios<char,_STL::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 62   :     return _M_tied_ostream;

  00000	8b 41 5c	 mov	 eax, DWORD PTR [ecx+92]

; 63   :   }

  00003	c3		 ret	 0
?tie@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QBEPAV?$basic_ostream@DV?$char_traits@D@_STL@@@2@XZ ENDP ; _STL::basic_ios<char,_STL::char_traits<char> >::tie
_TEXT	ENDS
PUBLIC	??0?$CBitAttribute@EI@@QAE@XZ			; CBitAttribute<unsigned char,unsigned int>::CBitAttribute<unsigned char,unsigned int>
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\bitattribute.h
;	COMDAT ??0?$CBitAttribute@EI@@QAE@XZ
_TEXT	SEGMENT
??0?$CBitAttribute@EI@@QAE@XZ PROC NEAR			; CBitAttribute<unsigned char,unsigned int>::CBitAttribute<unsigned char,unsigned int>, COMDAT
; _this$ = ecx

; 51   : {

  00000	8b c1		 mov	 eax, ecx

; 52   : 	SetNULL();

  00002	c6 00 00	 mov	 BYTE PTR [eax], 0

; 53   : }

  00005	c3		 ret	 0
??0?$CBitAttribute@EI@@QAE@XZ ENDP			; CBitAttribute<unsigned char,unsigned int>::CBitAttribute<unsigned char,unsigned int>
_TEXT	ENDS
PUBLIC	?setstate@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z ; _STL::basic_ios<char,_STL::char_traits<char> >::setstate
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_ios.h
;	COMDAT ?setstate@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z
_TEXT	SEGMENT
___state$ = 8						; size = 4
?setstate@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z PROC NEAR ; _STL::basic_ios<char,_STL::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 94   :   void setstate(iostate __state) { this->clear(rdstate() | __state); }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	0b 44 24 04	 or	 eax, DWORD PTR ___state$[esp-4]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?clear@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z ; _STL::basic_ios<char,_STL::char_traits<char> >::clear
  0000d	c2 04 00	 ret	 4
?setstate@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z ENDP ; _STL::basic_ios<char,_STL::char_traits<char> >::setstate
_TEXT	ENDS
PUBLIC	?flush@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@XZ ; _STL::basic_ostream<char,_STL::char_traits<char> >::flush
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_ostream.h
;	COMDAT ?flush@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@XZ
_TEXT	SEGMENT
?flush@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@XZ PROC NEAR ; _STL::basic_ostream<char,_STL::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 120  :   _Self& flush() {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 121  :     if (this->rdbuf())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00008	8b 4c 30 58	 mov	 ecx, DWORD PTR [eax+esi+88]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 1d		 je	 SHORT $L110728

; 122  :       if (this->rdbuf()->pubsync() == -1)

  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	ff 50 10	 call	 DWORD PTR [eax+16]
  00015	83 f8 ff	 cmp	 eax, -1
  00018	75 13		 jne	 SHORT $L110728

; 123  :         this->setstate(ios_base::badbit);

  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001f	03 ce		 add	 ecx, esi
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	83 c8 01	 or	 eax, 1
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?clear@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z ; _STL::basic_ios<char,_STL::char_traits<char> >::clear
$L110728:

; 124  :     return *this;

  0002d	8b c6		 mov	 eax, esi
  0002f	5e		 pop	 esi

; 125  :   }

  00030	c3		 ret	 0
?flush@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@XZ ENDP ; _STL::basic_ostream<char,_STL::char_traits<char> >::flush
_TEXT	ENDS
PUBLIC	?Release@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXXZ ; CTypeTable<ACTION_INFO_NODE>::Release
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\ctypetable.h
;	COMDAT ?Release@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXXZ
_TEXT	SEGMENT
?Release@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXXZ PROC NEAR ; CTypeTable<ACTION_INFO_NODE>::Release, COMDAT
; _this$ = ecx

; 108  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 109  : 	if (m_pTypeInfo != NULL)

  00003	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0e		 je	 SHORT $L109885

; 110  : 	{
; 111  : 		// 모든 CSprite를 지운다.
; 112  : 		delete [] m_pTypeInfo;

  0000a	6a 03		 push	 3
  0000c	e8 00 00 00 00	 call	 ??_EACTION_INFO_NODE@@QAEPAXI@Z

; 113  : 		m_pTypeInfo = NULL;

  00011	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 114  : 		
; 115  : 		m_Size = 0;

  00015	83 26 00	 and	 DWORD PTR [esi], 0
$L109885:
  00018	5e		 pop	 esi

; 116  : 	}
; 117  : }

  00019	c3		 ret	 0
?Release@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXXZ ENDP	; CTypeTable<ACTION_INFO_NODE>::Release
_TEXT	ENDS
PUBLIC	??$_M_init@DV?$char_traits@D@_STL@@@_STL@@YA_NAAV?$basic_ostream@DV?$char_traits@D@_STL@@@0@@Z ; _STL::_M_init<char,_STL::char_traits<char> >
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_ostream.c
;	COMDAT ??$_M_init@DV?$char_traits@D@_STL@@@_STL@@YA_NAAV?$basic_ostream@DV?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT
___str$ = 8						; size = 4
??$_M_init@DV?$char_traits@D@_STL@@@_STL@@YA_NAAV?$basic_ostream@DV?$char_traits@D@_STL@@@0@@Z PROC NEAR ; _STL::_M_init<char,_STL::char_traits<char> >, COMDAT

; 37   : _M_init(basic_ostream<_CharT, _Traits>& __str) {

  00000	56		 push	 esi

; 38   :   if (__str.good()) {

  00001	8b 74 24 08	 mov	 esi, DWORD PTR ___str$[esp]
  00005	8b 06		 mov	 eax, DWORD PTR [esi]
  00007	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000a	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0000d	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00011	75 36		 jne	 SHORT $L109927

; 39   :     // boris : check if this is needed !
; 40   :     if (!__str.rdbuf())

  00013	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00017	75 0c		 jne	 SHORT $L110755

; 41   :       __str.setstate(ios_base::badbit);

  00019	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001c	83 c8 01	 or	 eax, 1
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?clear@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z ; _STL::basic_ios<char,_STL::char_traits<char> >::clear
$L110755:

; 42   :     if (__str.tie())

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	8b 4c 30 5c	 mov	 ecx, DWORD PTR [eax+esi+92]
  0002e	85 c9		 test	 ecx, ecx
  00030	74 05		 je	 SHORT $L109929

; 43   :       __str.tie()->flush();

  00032	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@XZ ; _STL::basic_ostream<char,_STL::char_traits<char> >::flush
$L109929:

; 44   :     return __str.good();

  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003c	33 c9		 xor	 ecx, ecx
  0003e	39 4c 30 08	 cmp	 DWORD PTR [eax+esi+8], ecx
  00042	5e		 pop	 esi
  00043	0f 94 c1	 sete	 cl
  00046	8a c1		 mov	 al, cl

; 47   : }

  00048	c3		 ret	 0
$L109927:

; 45   :   } else
; 46   :     return false;

  00049	32 c0		 xor	 al, al
  0004b	5e		 pop	 esi

; 47   : }

  0004c	c3		 ret	 0
??$_M_init@DV?$char_traits@D@_STL@@@_STL@@YA_NAAV?$basic_ostream@DV?$char_traits@D@_STL@@@0@@Z ENDP ; _STL::_M_init<char,_STL::char_traits<char> >
_TEXT	ENDS
PUBLIC	??1?$CTypeTable@VACTION_INFO_NODE@@@@QAE@XZ	; CTypeTable<ACTION_INFO_NODE>::~CTypeTable<ACTION_INFO_NODE>
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\ctypetable.h
;	COMDAT ??1?$CTypeTable@VACTION_INFO_NODE@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CTypeTable@VACTION_INFO_NODE@@@@QAE@XZ PROC NEAR	; CTypeTable<ACTION_INFO_NODE>::~CTypeTable<ACTION_INFO_NODE>, COMDAT
; _this$ = ecx

; 72   : 	Release();

  00000	e9 00 00 00 00	 jmp	 ?Release@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXXZ ; CTypeTable<ACTION_INFO_NODE>::Release
??1?$CTypeTable@VACTION_INFO_NODE@@@@QAE@XZ ENDP	; CTypeTable<ACTION_INFO_NODE>::~CTypeTable<ACTION_INFO_NODE>
_TEXT	ENDS
PUBLIC	??0sentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAE@AAV12@@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_ostream.h
;	COMDAT ??0sentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAE@AAV12@@Z
_TEXT	SEGMENT
___str$ = 8						; size = 4
??0sentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAE@AAV12@@Z PROC NEAR ; _STL::basic_ostream<char,_STL::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 165  :       {

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___str$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	50		 push	 eax
  00008	89 06		 mov	 DWORD PTR [esi], eax
  0000a	e8 00 00 00 00	 call	 ??$_M_init@DV?$char_traits@D@_STL@@@_STL@@YA_NAAV?$basic_ostream@DV?$char_traits@D@_STL@@@0@@Z ; _STL::_M_init<char,_STL::char_traits<char> >
  0000f	88 46 04	 mov	 BYTE PTR [esi+4], al
  00012	59		 pop	 ecx

; 166  :       }

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0sentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAE@AAV12@@Z ENDP ; _STL::basic_ostream<char,_STL::char_traits<char> >::sentry::sentry
_TEXT	ENDS
PUBLIC	??1sentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAE@XZ ; _STL::basic_ostream<char,_STL::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogsy
;	COMDAT ??1sentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAE@XZ PROC NEAR ; _STL::basic_ostream<char,_STL::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 169  :         if (_M_str.flags() & ios_base::unitbuf)

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	8b 01		 mov	 eax, DWORD PTR [ecx]
  00004	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00007	f6 44 08 05 20	 test	 BYTE PTR [eax+ecx+5], 32 ; 00000020H
  0000c	74 05		 je	 SHORT $L109780

; 170  : # ifndef _STLP_INCOMPLETE_EXCEPTION_HEADER 
; 171  :           if (!_STLP_VENDOR_EXCEPT_STD::uncaught_exception())
; 172  : # endif
; 173  :             _M_str.flush();

  0000e	e9 00 00 00 00	 jmp	 ?flush@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@XZ ; _STL::basic_ostream<char,_STL::char_traits<char> >::flush
$L109780:

; 174  :       }

  00013	c3		 ret	 0
??1sentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAE@XZ ENDP ; _STL::basic_ostream<char,_STL::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	?Init@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXH@Z	; CTypeTable<ACTION_INFO_NODE>::Init
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:NEAR			; `eh vector constructor iterator'
EXTRN	__EH_prolog:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
;	COMDAT xdata$x
; File c:\darkeden\designed_common\project\client\ctypetable.h
xdata$x	SEGMENT
$T110797 DD	0ffffffffH
	DD	FLAT:$L110789
$T110793 DD	019930520H
	DD	01H
	DD	FLAT:$T110797
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?Init@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T110786 = 8						; size = 4
_size$ = 8						; size = 4
?Init@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXH@Z PROC NEAR ; CTypeTable<ACTION_INFO_NODE>::Init, COMDAT
; _this$ = ecx

; 87   : {

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?Init@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXH@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	53		 push	 ebx
  0000b	56		 push	 esi

; 88   : 	// 개수가 없을 경우 
; 89   : 	if (size==0) 

  0000c	8b 75 08	 mov	 esi, DWORD PTR _size$[ebp]
  0000f	57		 push	 edi
  00010	33 ff		 xor	 edi, edi
  00012	3b f7		 cmp	 esi, edi
  00014	8b d9		 mov	 ebx, ecx
  00016	74 3b		 je	 SHORT $L109872

; 90   : 		return;
; 91   : 
; 92   : 	// 일단 해제
; 93   : 	Release();

  00018	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXXZ ; CTypeTable<ACTION_INFO_NODE>::Release

; 94   : 
; 95   : 	// 메모리 잡기
; 96   : 	m_Size = size;
; 97   : 	
; 98   : 	m_pTypeInfo = new Type [m_Size];	

  0001d	8b c6		 mov	 eax, esi
  0001f	c1 e0 04	 shl	 eax, 4
  00022	83 c0 04	 add	 eax, 4
  00025	50		 push	 eax
  00026	89 33		 mov	 DWORD PTR [ebx], esi
  00028	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002d	59		 pop	 ecx
  0002e	89 45 08	 mov	 DWORD PTR $T110786[ebp], eax
  00031	3b c7		 cmp	 eax, edi
  00033	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00036	74 18		 je	 SHORT $L110788
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??1ACTION_INFO_NODE@@QAE@XZ ; ACTION_INFO_NODE::~ACTION_INFO_NODE
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??0ACTION_INFO_NODE@@QAE@XZ ; ACTION_INFO_NODE::ACTION_INFO_NODE
  00042	56		 push	 esi
  00043	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00046	6a 10		 push	 16			; 00000010H
  00048	57		 push	 edi
  00049	89 30		 mov	 DWORD PTR [eax], esi
  0004b	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
$L110788:
  00050	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
$L109872:

; 99   : }

  00053	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	c9		 leave
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L110789:
  00000	ff 75 08	 push	 DWORD PTR $T110786[ebp]
  00003	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?Init@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXH@Z:
  0000a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T110793
  0000f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Init@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXH@Z ENDP	; CTypeTable<ACTION_INFO_NODE>::Init
PUBLIC	??0MActionInfo@@QAE@XZ				; MActionInfo::MActionInfo
EXTRN	??0MString@@QAE@XZ:NEAR				; MString::MString
;	COMDAT xdata$x
; File c:\darkeden\designed_common\project\client\bitattribute.h
xdata$x	SEGMENT
$T110835 DD	0ffffffffH
	DD	FLAT:$L110803
$T110821 DD	019930520H
	DD	01H
	DD	FLAT:$T110835
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mactioninfotable.cpp
xdata$x	ENDS
;	COMDAT ??0MActionInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0MActionInfo@@QAE@XZ PROC NEAR			; MActionInfo::MActionInfo, COMDAT
; _this$ = ecx

; 118  : { 

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$??0MActionInfo@@QAE@XZ
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	51		 push	 ecx
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx
  0000f	33 db		 xor	 ebx, ebx
  00011	57		 push	 edi
  00012	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00015	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00018	89 1e		 mov	 DWORD PTR [esi], ebx
  0001a	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0001d	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00020	e8 00 00 00 00	 call	 ??0MString@@QAE@XZ	; MString::MString
  00025	88 9e 2e 01 00
	00		 mov	 BYTE PTR [esi+302], bl

; 119  : 	m_bAdvancementClassSkill = false;
; 120  : 	m_bNonAdvancementClassSkill = false;
; 121  : 
; 122  : 	m_CastingActionInfo = ACTIONINFO_NULL;	// casting Action Info를 없앤다.

  0002b	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00030	6a 03		 push	 3
  00032	88 9e 34 01 00
	00		 mov	 BYTE PTR [esi+308], bl
  00038	88 9e 35 01 00
	00		 mov	 BYTE PTR [esi+309], bl
  0003e	66 89 56 2a	 mov	 WORD PTR [esi+42], dx

; 123  : 	m_bCastingAction	= false;			// casting 동작은 아니라고 설정..

  00042	88 5e 2c	 mov	 BYTE PTR [esi+44], bl

; 124  : 	m_CastingTime		= 0;

  00045	66 89 5e 52	 mov	 WORD PTR [esi+82], bx

; 125  : 
; 126  : 	m_fUserType = FLAG_ACTIONINFO_USER_ALL;

  00049	c6 46 57 ff	 mov	 BYTE PTR [esi+87], 255	; 000000ffH

; 127  : 	m_fWeaponType = 0;//FLAG_ACTIONINFO_WEAPON_ALL;

  0004d	66 89 5e 58	 mov	 WORD PTR [esi+88], bx

; 128  : 	m_fCurrentWeapon = 0;	// 현재 들고 있는 무기의 적용을 받는가?

  00051	88 5e 5a	 mov	 BYTE PTR [esi+90], bl

; 129  : 	m_MainNode = MAIN_NODE_NULL;

  00054	89 56 70	 mov	 DWORD PTR [esi+112], edx

; 130  : 	m_bAttack = TRUE;			// 기본적으로 공격기술로 설정

  00057	c7 46 74 01 00
	00 00		 mov	 DWORD PTR [esi+116], 1

; 131  : 
; 132  : 	m_bComboAttackSkill = FALSE;

  0005e	89 5e 78	 mov	 DWORD PTR [esi+120], ebx

; 133  : 	
; 134  : 	m_bUseRepeatFrame = false;

  00061	88 9e e0 00 00
	00		 mov	 BYTE PTR [esi+224], bl
  00067	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  0006a	59		 pop	 ecx
$L109123:

; 135  : 	for (int b=0;b<3;b++)
; 136  : 	{
; 137  : 	m_CastingStartFrame[b] = 0;	// casting effect의 시작 frame

  0006b	89 58 f4	 mov	 DWORD PTR [eax-12], ebx

; 138  : 	m_CastingFrames[b]		= 0;	// casting effect의 지속 frame

  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	83 c0 04	 add	 eax, 4
  00073	49		 dec	 ecx
  00074	75 f5		 jne	 SHORT $L109123

; 139  : 	}
; 140  : 	for (int i=0; i<9; i++)

  00076	6a 09		 push	 9
  00078	8d 86 08 01 00
	00		 lea	 eax, DWORD PTR [esi+264]
  0007e	59		 pop	 ecx
$L109127:

; 141  : 	{
; 142  : 		//m_CastingStartFrame[i] = 0;	// casting effect의 시작 frame
; 143  : 		//m_CastingFrames[i]		= 0;	// casting effect의 지속 frame
; 144  : 		
; 145  : 		m_StartFrame[i] = 0xFFFF;	// max값은 아니지만. 이 정도면 충분.. 음냐하.
; 146  : 
; 147  : 		m_RepeatStartFrame[i] = m_RepeatEndFrame[i] = -1;

  0007f	83 08 ff	 or	 DWORD PTR [eax], -1
  00082	83 48 dc ff	 or	 DWORD PTR [eax-36], -1
  00086	89 90 74 ff ff
	ff		 mov	 DWORD PTR [eax-140], edx
  0008c	83 c0 04	 add	 eax, 4
  0008f	49		 dec	 ecx
  00090	75 ed		 jne	 SHORT $L109127

; 148  : 	}
; 149  : 
; 150  : 
; 151  : 	for (int ispeed=0; ispeed<3; ispeed++)
; 152  : 	{
; 153  : 		for (int iStep=0; iStep<4 ; iStep++)
; 154  : 		{
; 155  : 			m_ComboSkillStartFrame[ispeed][iStep] = 0xFFFF; 

  00092	6a 0c		 push	 12			; 0000000cH
  00094	59		 pop	 ecx
  00095	8d be a0 00 00
	00		 lea	 edi, DWORD PTR [esi+160]
  0009b	8b c2		 mov	 eax, edx
  0009d	f3 ab		 rep stosd

; 156  : 		}
; 157  : 	}
; 158  : 
; 159  : 
; 160  : 
; 161  : 	m_RepeatLimit = 0xFFFF;
; 162  : 	
; 163  : 
; 164  : 	m_PacketType = ACTIONINFO_PACKET_NONE;
; 165  : 
; 166  : 	m_ActionEffectSpriteTypeFemale = EFFECTSPRITETYPE_NULL;
; 167  : 
; 168  : 	// 
; 169  : 	m_fOption = 0;
; 170  : 
; 171  : 	m_EffectStatus = EFFECTSTATUS_NULL;
; 172  : 
; 173  : 	// 결과 id
; 174  : 	m_ActionResultID	= ACTIONRESULTNODE_NULL;
; 175  : 	m_ActionResultValue	= 0;
; 176  : 
; 177  : 	m_PlusActionInfo = 0;
; 178  : 
; 179  : 	m_bCastingEffectToSelf = true;
; 180  : 
; 181  : 	m_SelectCreatureAttr = FLAG_ACTIONINFO_SELECT_ALL;
; 182  : 	m_bUseGrade = false;
; 183  : 	m_bUseActionStep = false;
; 184  : 	
; 185  : 	for( i = 0 ; i< MAX_ACTION_STEP ;i ++ )
; 186  : 	{
; 187  : 		m_ActionStep[i] = 0;
; 188  : 		
; 189  : 	}
; 190  : 
; 191  : 	
; 192  : 	for( i = 0 ; i< (MAX_ACTION_STEP -1) ;i ++ )
; 193  : 	{
; 194  : 			m_ComboSkillActionStep[i] = ACTIONINFO_NULL;
; 195  : 		
; 196  : 	}
; 197  : 
; 198  : 
; 199  : 	//m_ComboActionResultEffect[i] = 0;
; 200  : 
; 201  : 
; 202  : 	m_bAttachSelf = false;
; 203  : 	m_Parent = ACTIONINFO_NULL;
; 204  : 	
; 205  : 	m_MasterySkillStep = 0;
; 206  : 	m_bIgnoreFailDelay = false;
; 207  : 	m_byActionStepCnt = 0 ; 
; 208  : 
; 209  : 
; 210  : }

  0009f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a2	89 5e 5c	 mov	 DWORD PTR [esi+92], ebx
  000a5	88 9e d8 00 00
	00		 mov	 BYTE PTR [esi+216], bl
  000ab	66 89 9e d0 00
	00 00		 mov	 WORD PTR [esi+208], bx
  000b2	89 9e d4 00 00
	00		 mov	 DWORD PTR [esi+212], ebx
  000b8	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx
  000bb	88 9e 2f 01 00
	00		 mov	 BYTE PTR [esi+303], bl
  000c1	88 5e 15	 mov	 BYTE PTR [esi+21], bl
  000c4	66 89 96 2c 01
	00 00		 mov	 WORD PTR [esi+300], dx
  000cb	66 89 56 30	 mov	 WORD PTR [esi+48], dx
  000cf	c7 86 dc 00 00
	00 83 04 00 00	 mov	 DWORD PTR [esi+220], 1155 ; 00000483H
  000d9	c6 46 50 01	 mov	 BYTE PTR [esi+80], 1
  000dd	c6 86 2e 01 00
	00 ff		 mov	 BYTE PTR [esi+302], 255	; 000000ffH
  000e4	33 c0		 xor	 eax, eax
  000e6	8d 7e 16	 lea	 edi, DWORD PTR [esi+22]
  000e9	ab		 stosd
  000ea	ab		 stosd
  000eb	66 ab		 stosw
  000ed	8d 7e 22	 lea	 edi, DWORD PTR [esi+34]
  000f0	83 c8 ff	 or	 eax, -1
  000f3	ab		 stosd
  000f4	ab		 stosd
  000f5	88 9e 30 01 00
	00		 mov	 BYTE PTR [esi+304], bl
  000fb	88 9e 31 01 00
	00		 mov	 BYTE PTR [esi+305], bl
  00101	88 9e 32 01 00
	00		 mov	 BYTE PTR [esi+306], bl
  00107	88 9e 33 01 00
	00		 mov	 BYTE PTR [esi+307], bl
  0010d	5f		 pop	 edi
  0010e	66 89 56 20	 mov	 WORD PTR [esi+32], dx
  00112	8b c6		 mov	 eax, esi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx
  00116	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0011d	c9		 leave
  0011e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L110803:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CTypeTable@VACTION_INFO_NODE@@@@QAE@XZ ; CTypeTable<ACTION_INFO_NODE>::~CTypeTable<ACTION_INFO_NODE>
__ehhandler$??0MActionInfo@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T110821
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0MActionInfo@@QAE@XZ ENDP				; MActionInfo::MActionInfo
PUBLIC	??1MActionInfo@@QAE@XZ				; MActionInfo::~MActionInfo
EXTRN	??1MString@@UAE@XZ:NEAR				; MString::~MString
;	COMDAT xdata$x
; File c:\darkeden\designed_common\project\client\ctypetable.h
xdata$x	SEGMENT
$T110851 DD	0ffffffffH
	DD	FLAT:$L110840
$T110849 DD	019930520H
	DD	01H
	DD	FLAT:$T110851
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mactioninfotable.cpp
xdata$x	ENDS
;	COMDAT ??1MActionInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1MActionInfo@@QAE@XZ PROC NEAR			; MActionInfo::~MActionInfo, COMDAT
; _this$ = ecx

; 216  : {

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$??1MActionInfo@@QAE@XZ
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	51		 push	 ecx
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 217  : }

  00015	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00018	e8 00 00 00 00	 call	 ??1MString@@UAE@XZ	; MString::~MString
  0001d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXXZ ; CTypeTable<ACTION_INFO_NODE>::Release
  00028	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0002b	5e		 pop	 esi
  0002c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00033	c9		 leave
  00034	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L110840:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CTypeTable@VACTION_INFO_NODE@@@@QAE@XZ ; CTypeTable<ACTION_INFO_NODE>::~CTypeTable<ACTION_INFO_NODE>
__ehhandler$??1MActionInfo@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T110849
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1MActionInfo@@QAE@XZ ENDP				; MActionInfo::~MActionInfo
PUBLIC	?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write
;	COMDAT xdata$x
; File c:\stlport-4.6.1\stlport\stl\_ios_base.h
xdata$x	SEGMENT
$T110895 DD	0ffffffffH
	DD	FLAT:$L110859
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T110897 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L110858
$T110896 DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T110897
$T110892 DD	019930520H
	DD	03H
	DD	FLAT:$T110895
	DD	01H
	DD	FLAT:$T110896
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_ostream.c
xdata$x	ENDS
;	COMDAT ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z
_TEXT	SEGMENT
___sentry$ = -32					; size = 8
_this$ = -24						; size = 4
___failed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
___s$ = 8						; size = 4
___n$ = 12						; size = 4
?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z PROC NEAR ; _STL::basic_ostream<char,_STL::char_traits<char> >::write, COMDAT
; _this$ = ecx

; 359  : {

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 14	 sub	 esp, 20			; 00000014H
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b f1		 mov	 esi, ecx
  00012	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 360  :   sentry __sentry(*this);

  00015	56		 push	 esi
  00016	8d 4d e0	 lea	 ecx, DWORD PTR ___sentry$[ebp]
  00019	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  0001c	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAE@AAV12@@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::sentry::sentry
  00021	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 361  :   bool __failed = true;
; 362  : 
; 363  :   if (__sentry) {

  00025	80 7d e4 00	 cmp	 BYTE PTR ___sentry$[ebp+4], 0
  00029	c6 45 ef 01	 mov	 BYTE PTR ___failed$[ebp], 1
  0002d	74 3b		 je	 SHORT $L109549

; 364  :     _STLP_TRY {
; 365  :       __failed = this->rdbuf()->sputn(__s, __n) != __n;

  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	ff 75 0c	 push	 DWORD PTR ___n$[ebp]
  00037	8b 4c 30 58	 mov	 ecx, DWORD PTR [eax+esi+88]
  0003b	ff 75 08	 push	 DWORD PTR ___s$[ebp]
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00044	ff 50 28	 call	 DWORD PTR [eax+40]
  00047	3b 45 0c	 cmp	 eax, DWORD PTR ___n$[ebp]
  0004a	0f 95 45 ef	 setne	 BYTE PTR ___failed$[ebp]
  0004e	eb 1a		 jmp	 SHORT $L109549
$L110858:

; 366  :     }
; 367  :     _STLP_CATCH_ALL {
; 368  :       this->_M_handle_exception(ios_base::badbit);

  00050	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00058	6a 01		 push	 1
  0005a	03 c8		 add	 ecx, eax
  0005c	e8 00 00 00 00	 call	 ?_M_handle_exception@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z ; _STL::basic_ios<char,_STL::char_traits<char> >::_M_handle_exception

; 369  :     }

  00061	b8 00 00 00 00	 mov	 eax, $L110893
  00066	c3		 ret	 0
$L110893:
  00067	8b 75 e8	 mov	 esi, DWORD PTR _this$[ebp]
$L109549:
  0006a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 370  :   }
; 371  : 
; 372  :   if (__failed)

  0006e	80 7d ef 00	 cmp	 BYTE PTR ___failed$[ebp], 0
  00072	74 13		 je	 SHORT $L110876

; 373  :     this->setstate(ios_base::badbit);

  00074	8b 06		 mov	 eax, DWORD PTR [esi]
  00076	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00079	03 ce		 add	 ecx, esi
  0007b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0007e	83 c8 01	 or	 eax, 1
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?clear@?$basic_ios@DV?$char_traits@D@_STL@@@_STL@@QAEXH@Z ; _STL::basic_ios<char,_STL::char_traits<char> >::clear
$L110876:

; 374  : 
; 375  :   return *this;

  00087	8b 4d e0	 mov	 ecx, DWORD PTR ___sentry$[ebp]
  0008a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00093	f6 44 08 05 20	 test	 BYTE PTR [eax+ecx+5], 32 ; 00000020H
  00098	74 05		 je	 SHORT $L110887
  0009a	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@XZ ; _STL::basic_ostream<char,_STL::char_traits<char> >::flush
$L110887:

; 376  : }

  0009f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a2	5f		 pop	 edi
  000a3	8b c6		 mov	 eax, esi
  000a5	5e		 pop	 esi
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ad	5b		 pop	 ebx
  000ae	c9		 leave
  000af	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L110859:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR ___sentry$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAE@XZ ; _STL::basic_ostream<char,_STL::char_traits<char> >::sentry::~sentry
__ehhandler$?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T110892
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ENDP ; _STL::basic_ostream<char,_STL::char_traits<char> >::write
PUBLIC	?LoadFromFile@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXAAVivfstream@@@Z ; CTypeTable<ACTION_INFO_NODE>::LoadFromFile
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\ctypetable.h
;	COMDAT ?LoadFromFile@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_numSize$ = -4						; size = 4
tv191 = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFile@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXAAVivfstream@@@Z PROC NEAR ; CTypeTable<ACTION_INFO_NODE>::LoadFromFile, COMDAT
; _this$ = ecx

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 147  : 	int numSize;
; 148  : 	
; 149  : 	// size 읽어오기
; 150  : 	file.read((char*)&numSize, 4);

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _file$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	33 ff		 xor	 edi, edi
  0000c	39 7b 04	 cmp	 DWORD PTR [ebx+4], edi
  0000f	8b f1		 mov	 esi, ecx
  00011	74 0e		 je	 SHORT $L110905
  00013	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 fc	 lea	 edx, DWORD PTR _numSize$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L110905:

; 151  : 
; 152  : 	// 현재 잡혀있는 메모리와 다르면 다시 메모리를 잡는다.
; 153  : 	if (m_Size != numSize)

  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR _numSize$[ebp]
  00026	74 11		 je	 SHORT $L109684

; 154  : 	{
; 155  : 		// 메모리 해제
; 156  : 		Release();

  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXXZ ; CTypeTable<ACTION_INFO_NODE>::Release

; 157  : 
; 158  : 		// 메모리 잡기
; 159  : 		Init( numSize );

  0002f	ff 75 fc	 push	 DWORD PTR _numSize$[ebp]
  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXH@Z ; CTypeTable<ACTION_INFO_NODE>::Init
$L109684:

; 160  : 	}
; 161  : 
; 162  : 	// file에서 각각의 정보를 읽어들인다.
; 163  : 	for (int i=0; i<m_Size; i++)

  00039	39 3e		 cmp	 DWORD PTR [esi], edi
  0003b	7e 18		 jle	 SHORT $L109688
  0003d	89 7d 08	 mov	 DWORD PTR tv191[ebp], edi
$L110909:
  00040	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00043	03 4d 08	 add	 ecx, DWORD PTR tv191[ebp]

; 164  : 	{
; 165  :  		m_pTypeInfo[i].LoadFromFile( file );

  00046	53		 push	 ebx
  00047	e8 00 00 00 00	 call	 ?LoadFromFile@ACTION_INFO_NODE@@QAEXAAVivfstream@@@Z ; ACTION_INFO_NODE::LoadFromFile
  0004c	83 45 08 10	 add	 DWORD PTR tv191[ebp], 16 ; 00000010H
  00050	47		 inc	 edi
  00051	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00053	7c eb		 jl	 SHORT $L110909
$L109688:
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx

; 166  : 	}
; 167  : }

  00058	c9		 leave
  00059	c2 04 00	 ret	 4
?LoadFromFile@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXAAVivfstream@@@Z ENDP ; CTypeTable<ACTION_INFO_NODE>::LoadFromFile
_TEXT	ENDS
PUBLIC	??_EMActionInfo@@QAEPAXI@Z			; MActionInfo::`vector deleting destructor'
; Function compile flags: /Ogsy
;	COMDAT ??_EMActionInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_EMActionInfo@@QAEPAXI@Z PROC NEAR			; MActionInfo::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 27		 je	 SHORT $L109941
  0000d	57		 push	 edi
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??1MActionInfo@@QAE@XZ ; MActionInfo::~MActionInfo
  00013	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00016	ff 37		 push	 DWORD PTR [edi]
  00018	68 38 01 00 00	 push	 312			; 00000138H
  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00023	f6 c3 01	 test	 bl, 1
  00026	74 07		 je	 SHORT $L109942
  00028	57		 push	 edi
  00029	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002e	59		 pop	 ecx
$L109942:
  0002f	8b c7		 mov	 eax, edi
  00031	5f		 pop	 edi
  00032	eb 15		 jmp	 SHORT $L109940
$L109941:
  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 ??1MActionInfo@@QAE@XZ	; MActionInfo::~MActionInfo
  0003b	f6 c3 01	 test	 bl, 1
  0003e	74 07		 je	 SHORT $L109944
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00046	59		 pop	 ecx
$L109944:
  00047	8b c6		 mov	 eax, esi
$L109940:
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	c2 04 00	 ret	 4
??_EMActionInfo@@QAEPAXI@Z ENDP				; MActionInfo::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?SaveToFile@ACTION_INFO_NODE@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ; ACTION_INFO_NODE::SaveToFile
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mactioninfotable.cpp
;	COMDAT ?SaveToFile@ACTION_INFO_NODE@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
?SaveToFile@ACTION_INFO_NODE@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z PROC NEAR ; ACTION_INFO_NODE::SaveToFile, COMDAT
; _this$ = ecx

; 74   : {			

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 75   : 	file.write((const char*)&EffectGeneratorID, SIZE_EFFECTGENERATORID);			

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _file$[esp+8]
  00007	6a 02		 push	 2
  00009	5b		 pop	 ebx
  0000a	8b f1		 mov	 esi, ecx
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b cf		 mov	 ecx, edi
  00010	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 76   : 	file.write((const char*)&EffectSpriteType, SIZE_EFFECTSPRITETYPE);

  00015	53		 push	 ebx
  00016	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  00019	50		 push	 eax
  0001a	8b cf		 mov	 ecx, edi
  0001c	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 77   : 	file.write((const char*)&Step, 2);

  00021	53		 push	 ebx
  00022	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00025	50		 push	 eax
  00026	8b cf		 mov	 ecx, edi
  00028	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 78   : 	file.write((const char*)&Count, 2);

  0002d	53		 push	 ebx
  0002e	8d 46 06	 lea	 eax, DWORD PTR [esi+6]
  00031	50		 push	 eax
  00032	8b cf		 mov	 ecx, edi
  00034	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 79   : 	file.write((const char*)&LinkCount, 2);

  00039	53		 push	 ebx
  0003a	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0003d	50		 push	 eax
  0003e	8b cf		 mov	 ecx, edi
  00040	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 80   : 	file.write((const char*)&SoundID, SIZE_SOUNDID);

  00045	53		 push	 ebx
  00046	8d 46 0a	 lea	 eax, DWORD PTR [esi+10]
  00049	50		 push	 eax
  0004a	8b cf		 mov	 ecx, edi
  0004c	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 81   : 	//file.write((const char*)&Light, 1);
; 82   : 	file.write((const char*)&bDelayNode, 1);	

  00051	6a 01		 push	 1
  00053	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00056	50		 push	 eax
  00057	8b cf		 mov	 ecx, edi
  00059	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 83   : 	file.write((const char*)&bResultTime, 1);	

  0005e	6a 01		 push	 1
  00060	83 c6 0d	 add	 esi, 13			; 0000000dH
  00063	56		 push	 esi
  00064	8b cf		 mov	 ecx, edi
  00066	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx

; 84   : }

  0006e	c2 04 00	 ret	 4
?SaveToFile@ACTION_INFO_NODE@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ENDP ; ACTION_INFO_NODE::SaveToFile
_TEXT	ENDS
PUBLIC	?LoadFromFile@MActionInfo@@QAEXAAVivfstream@@@Z	; MActionInfo::LoadFromFile
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFile@MActionInfo@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
tv1378 = -12						; size = 4
tv785 = -12						; size = 4
tv571 = -12						; size = 4
tv302 = -12						; size = 4
tv213 = -12						; size = 4
_es$ = -8						; size = 2
_bComboAttackSkill$ = -3				; size = 1
_bAttack$ = -2						; size = 1
_pt$ = -1						; size = 1
_file$ = 8						; size = 4
_flag$ = 11						; size = 1
?LoadFromFile@MActionInfo@@QAEXAAVivfstream@@@Z PROC NEAR ; MActionInfo::LoadFromFile, COMDAT
; _this$ = ecx

; 432  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 433  : 	m_Name.LoadFromFile( file );

  00008	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	56		 push	 esi
  00014	ff 50 08	 call	 DWORD PTR [eax+8]

; 434  : 
; 435  : 	file.read((char*)&m_Action, 1);

  00017	33 db		 xor	 ebx, ebx
  00019	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  0001c	74 4a		 je	 SHORT $L110936
  0001e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	6a 01		 push	 1
  00025	8d 57 14	 lea	 edx, DWORD PTR [edi+20]
  00028	52		 push	 edx
  00029	ff 50 10	 call	 DWORD PTR [eax+16]

; 436  : 	file.read((char*)&m_ActionEffectSpriteType, SIZE_EFFECTSPRITETYPE);

  0002c	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  0002f	74 37		 je	 SHORT $L110936
  00031	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00034	8b 01		 mov	 eax, DWORD PTR [ecx]
  00036	6a 02		 push	 2
  00038	8d 57 2e	 lea	 edx, DWORD PTR [edi+46]
  0003b	52		 push	 edx
  0003c	ff 50 10	 call	 DWORD PTR [eax+16]

; 437  : 	file.read((char*)&m_ActionEffectSpriteTypeFemale, SIZE_EFFECTSPRITETYPE);

  0003f	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  00042	74 24		 je	 SHORT $L110936
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	8b 01		 mov	 eax, DWORD PTR [ecx]
  00049	6a 02		 push	 2
  0004b	8d 57 30	 lea	 edx, DWORD PTR [edi+48]
  0004e	52		 push	 edx
  0004f	ff 50 10	 call	 DWORD PTR [eax+16]

; 438  : 
; 439  : 	file.read((char*)&m_bUseRepeatFrame, 1);

  00052	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  00055	74 11		 je	 SHORT $L110936
  00057	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005c	6a 01		 push	 1
  0005e	8d 97 e0 00 00
	00		 lea	 edx, DWORD PTR [edi+224]
  00064	52		 push	 edx
  00065	ff 50 10	 call	 DWORD PTR [eax+16]
$L110936:

; 440  : 	for (int b=0;b<3;b++)

  00068	8d 5f 40	 lea	 ebx, DWORD PTR [edi+64]
  0006b	c7 45 f4 03 00
	00 00		 mov	 DWORD PTR tv785[ebp], 3
$L109253:

; 441  : 	{
; 442  : 	file.read((char*)&m_CastingStartFrame[b],4);	// casting effect의 시작 frame

  00072	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00076	74 1f		 je	 SHORT $L109254
  00078	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0007b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007d	6a 04		 push	 4
  0007f	8d 53 f4	 lea	 edx, DWORD PTR [ebx-12]
  00082	52		 push	 edx
  00083	ff 50 10	 call	 DWORD PTR [eax+16]

; 443  : 	file.read((char*)&m_CastingFrames[b],4);

  00086	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0008a	74 0b		 je	 SHORT $L109254
  0008c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0008f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00091	6a 04		 push	 4
  00093	53		 push	 ebx
  00094	ff 50 10	 call	 DWORD PTR [eax+16]
$L109254:
  00097	83 c3 04	 add	 ebx, 4
  0009a	ff 4d f4	 dec	 DWORD PTR tv785[ebp]
  0009d	75 d3		 jne	 SHORT $L109253

; 444  : 	}
; 445  : 	for (int i=0; i<9; i++)

  0009f	8d 9f e4 00 00
	00		 lea	 ebx, DWORD PTR [edi+228]
  000a5	c7 45 f4 09 00
	00 00		 mov	 DWORD PTR tv302[ebp], 9
$L109259:

; 446  : 	{
; 447  : 		file.read((char*)&m_StartFrame[i], 4);

  000ac	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  000b0	74 33		 je	 SHORT $L109260
  000b2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b5	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b7	6a 04		 push	 4
  000b9	8d 53 98	 lea	 edx, DWORD PTR [ebx-104]
  000bc	52		 push	 edx
  000bd	ff 50 10	 call	 DWORD PTR [eax+16]

; 448  : 
; 449  : 		//file.read((char*)&m_CastingStartFrame[i], 4);	
; 450  : 		//file.read((char*)&m_CastingFrames[i], 4);
; 451  : 
; 452  : 		file.read((char*)&m_RepeatStartFrame[i], 4);	

  000c0	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  000c4	74 1f		 je	 SHORT $L109260
  000c6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000c9	8b 01		 mov	 eax, DWORD PTR [ecx]
  000cb	6a 04		 push	 4
  000cd	53		 push	 ebx
  000ce	ff 50 10	 call	 DWORD PTR [eax+16]

; 453  : 		file.read((char*)&m_RepeatEndFrame[i], 4);	

  000d1	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  000d5	74 0e		 je	 SHORT $L109260
  000d7	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000da	8b 01		 mov	 eax, DWORD PTR [ecx]
  000dc	6a 04		 push	 4
  000de	8d 53 24	 lea	 edx, DWORD PTR [ebx+36]
  000e1	52		 push	 edx
  000e2	ff 50 10	 call	 DWORD PTR [eax+16]
$L109260:
  000e5	83 c3 04	 add	 ebx, 4
  000e8	ff 4d f4	 dec	 DWORD PTR tv302[ebp]
  000eb	75 bf		 jne	 SHORT $L109259

; 454  : 	}
; 455  : 
; 456  : 	for (int ispeed=0; ispeed<3; ispeed++)

  000ed	c7 45 f4 28 00
	00 00		 mov	 DWORD PTR tv1378[ebp], 40 ; 00000028H
$L109266:

; 457  : 	{
; 458  : 		for (int iStep=0; iStep<4 ; iStep++)

  000f4	33 db		 xor	 ebx, ebx
$L111148:

; 459  : 		{
; 460  : 			file.read((char*)&m_ComboSkillStartFrame[ispeed][iStep], 4);

  000f6	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  000fa	74 13		 je	 SHORT $L109271
  000fc	8b 55 f4	 mov	 edx, DWORD PTR tv1378[ebp]
  000ff	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00102	8b 01		 mov	 eax, DWORD PTR [ecx]
  00104	03 d3		 add	 edx, ebx
  00106	6a 04		 push	 4
  00108	8d 14 97	 lea	 edx, DWORD PTR [edi+edx*4]
  0010b	52		 push	 edx
  0010c	ff 50 10	 call	 DWORD PTR [eax+16]
$L109271:
  0010f	43		 inc	 ebx
  00110	83 fb 04	 cmp	 ebx, 4
  00113	7c e1		 jl	 SHORT $L111148
  00115	83 45 f4 04	 add	 DWORD PTR tv1378[ebp], 4
  00119	83 7d f4 34	 cmp	 DWORD PTR tv1378[ebp], 52 ; 00000034H
  0011d	7c d5		 jl	 SHORT $L109266

; 461  : 		}
; 462  : 	}
; 463  : 
; 464  : 
; 465  : 	file.read((char*)&m_RepeatLimit, 2);	

  0011f	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00123	0f 84 34 01 00
	00		 je	 $L111036
  00129	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0012c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0012e	6a 02		 push	 2
  00130	8d 97 2c 01 00
	00		 lea	 edx, DWORD PTR [edi+300]
  00136	52		 push	 edx
  00137	ff 50 10	 call	 DWORD PTR [eax+16]

; 466  : 
; 467  : 	file.read((char*)&m_bCastingEffectToSelf, 1);

  0013a	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0013e	0f 84 19 01 00
	00		 je	 $L111036
  00144	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00147	8b 01		 mov	 eax, DWORD PTR [ecx]
  00149	6a 01		 push	 1
  0014b	8d 57 50	 lea	 edx, DWORD PTR [edi+80]
  0014e	52		 push	 edx
  0014f	ff 50 10	 call	 DWORD PTR [eax+16]

; 468  : 	file.read((char*)&m_CastingActionInfo, 4);

  00152	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00156	0f 84 01 01 00
	00		 je	 $L111036
  0015c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0015f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00161	6a 04		 push	 4
  00163	8d 57 2a	 lea	 edx, DWORD PTR [edi+42]
  00166	52		 push	 edx
  00167	ff 50 10	 call	 DWORD PTR [eax+16]

; 469  : 	file.read((char*)&m_bCastingAction, 1);

  0016a	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0016e	0f 84 e9 00 00
	00		 je	 $L111036
  00174	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00177	8b 01		 mov	 eax, DWORD PTR [ecx]
  00179	6a 01		 push	 1
  0017b	8d 57 2c	 lea	 edx, DWORD PTR [edi+44]
  0017e	52		 push	 edx
  0017f	ff 50 10	 call	 DWORD PTR [eax+16]

; 470  : 	file.read((char*)&m_CastingTime, 2);

  00182	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00186	0f 84 d1 00 00
	00		 je	 $L111036
  0018c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0018f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00191	6a 02		 push	 2
  00193	8d 57 52	 lea	 edx, DWORD PTR [edi+82]
  00196	52		 push	 edx
  00197	ff 50 10	 call	 DWORD PTR [eax+16]

; 471  : 
; 472  : 	file.read((char*)&m_Range, 1);

  0019a	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0019e	0f 84 b9 00 00
	00		 je	 $L111036
  001a4	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  001a7	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a9	6a 01		 push	 1
  001ab	8d 57 54	 lea	 edx, DWORD PTR [edi+84]
  001ae	52		 push	 edx
  001af	ff 50 10	 call	 DWORD PTR [eax+16]

; 473  : 	file.read((char*)&m_fTarget, 1);

  001b2	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  001b6	0f 84 a1 00 00
	00		 je	 $L111036
  001bc	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  001bf	8b 01		 mov	 eax, DWORD PTR [ecx]
  001c1	6a 01		 push	 1
  001c3	8d 57 55	 lea	 edx, DWORD PTR [edi+85]
  001c6	52		 push	 edx
  001c7	ff 50 10	 call	 DWORD PTR [eax+16]

; 474  : 	file.read((char*)&m_fStart, 1);

  001ca	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  001ce	0f 84 89 00 00
	00		 je	 $L111036
  001d4	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  001d7	8b 01		 mov	 eax, DWORD PTR [ecx]
  001d9	6a 01		 push	 1
  001db	8d 57 56	 lea	 edx, DWORD PTR [edi+86]
  001de	52		 push	 edx
  001df	ff 50 10	 call	 DWORD PTR [eax+16]

; 475  : 	file.read((char*)&m_fUserType, 1);

  001e2	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  001e6	74 75		 je	 SHORT $L111036
  001e8	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  001eb	8b 01		 mov	 eax, DWORD PTR [ecx]
  001ed	6a 01		 push	 1
  001ef	8d 57 57	 lea	 edx, DWORD PTR [edi+87]
  001f2	52		 push	 edx
  001f3	ff 50 10	 call	 DWORD PTR [eax+16]

; 476  : 	file.read((char*)&m_fWeaponType, 2);

  001f6	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  001fa	74 61		 je	 SHORT $L111036
  001fc	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  001ff	8b 01		 mov	 eax, DWORD PTR [ecx]
  00201	6a 02		 push	 2
  00203	8d 57 58	 lea	 edx, DWORD PTR [edi+88]
  00206	52		 push	 edx
  00207	ff 50 10	 call	 DWORD PTR [eax+16]

; 477  : 	file.read((char*)&m_fCurrentWeapon, 1);

  0020a	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0020e	74 4d		 je	 SHORT $L111036
  00210	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00213	8b 01		 mov	 eax, DWORD PTR [ecx]
  00215	6a 01		 push	 1
  00217	8d 57 5a	 lea	 edx, DWORD PTR [edi+90]
  0021a	52		 push	 edx
  0021b	ff 50 10	 call	 DWORD PTR [eax+16]

; 478  : 	file.read((char*)&m_fOption, 1);

  0021e	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00222	74 39		 je	 SHORT $L111036
  00224	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00227	8b 01		 mov	 eax, DWORD PTR [ecx]
  00229	6a 01		 push	 1
  0022b	8d 97 d8 00 00
	00		 lea	 edx, DWORD PTR [edi+216]
  00231	52		 push	 edx
  00232	ff 50 10	 call	 DWORD PTR [eax+16]

; 479  : 	file.read((char*)&m_PlusActionInfo, 4);

  00235	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00239	74 22		 je	 SHORT $L111036
  0023b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0023e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00240	6a 04		 push	 4
  00242	8d 57 4c	 lea	 edx, DWORD PTR [edi+76]
  00245	52		 push	 edx
  00246	ff 50 10	 call	 DWORD PTR [eax+16]

; 480  : 
; 481  : 	BYTE pt;
; 482  : 	file.read((char*)&pt, 1);

  00249	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0024d	74 0e		 je	 SHORT $L111036
  0024f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00252	8b 01		 mov	 eax, DWORD PTR [ecx]
  00254	6a 01		 push	 1
  00256	8d 55 ff	 lea	 edx, DWORD PTR _pt$[ebp]
  00259	52		 push	 edx
  0025a	ff 50 10	 call	 DWORD PTR [eax+16]
$L111036:

; 483  : 	m_PacketType = (ACTIONINFO_PACKET)pt;

  0025d	0f b6 45 ff	 movzx	 eax, BYTE PTR _pt$[ebp]
  00261	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 484  : 
; 485  : 
; 486  : 	file.read((char*)&m_Delay, 2);

  00264	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00268	0f 84 bc 00 00
	00		 je	 $L111081
  0026e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00271	8b 01		 mov	 eax, DWORD PTR [ecx]
  00273	6a 02		 push	 2
  00275	8d 57 60	 lea	 edx, DWORD PTR [edi+96]
  00278	52		 push	 edx
  00279	ff 50 10	 call	 DWORD PTR [eax+16]

; 487  : 	file.read((char*)&m_Value, 4);

  0027c	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00280	0f 84 a4 00 00
	00		 je	 $L111081
  00286	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00289	8b 01		 mov	 eax, DWORD PTR [ecx]
  0028b	6a 04		 push	 4
  0028d	8d 57 64	 lea	 edx, DWORD PTR [edi+100]
  00290	52		 push	 edx
  00291	ff 50 10	 call	 DWORD PTR [eax+16]

; 488  : 	file.read((char*)&m_SoundID, SIZE_SOUNDID);

  00294	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00298	0f 84 8c 00 00
	00		 je	 $L111081
  0029e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  002a1	8b 01		 mov	 eax, DWORD PTR [ecx]
  002a3	6a 02		 push	 2
  002a5	8d 57 68	 lea	 edx, DWORD PTR [edi+104]
  002a8	52		 push	 edx
  002a9	ff 50 10	 call	 DWORD PTR [eax+16]

; 489  : 	file.read((char*)&m_SoundMaleID, SIZE_SOUNDID);

  002ac	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  002b0	74 78		 je	 SHORT $L111081
  002b2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  002b5	8b 01		 mov	 eax, DWORD PTR [ecx]
  002b7	6a 02		 push	 2
  002b9	8d 57 6a	 lea	 edx, DWORD PTR [edi+106]
  002bc	52		 push	 edx
  002bd	ff 50 10	 call	 DWORD PTR [eax+16]

; 490  : 	file.read((char*)&m_SoundFemaleID, SIZE_SOUNDID);

  002c0	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  002c4	74 64		 je	 SHORT $L111081
  002c6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  002c9	8b 01		 mov	 eax, DWORD PTR [ecx]
  002cb	6a 02		 push	 2
  002cd	8d 57 6c	 lea	 edx, DWORD PTR [edi+108]
  002d0	52		 push	 edx
  002d1	ff 50 10	 call	 DWORD PTR [eax+16]

; 491  : 	file.read((char*)&m_MainNode, 4);

  002d4	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  002d8	74 50		 je	 SHORT $L111081
  002da	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  002dd	8b 01		 mov	 eax, DWORD PTR [ecx]
  002df	6a 04		 push	 4
  002e1	8d 57 70	 lea	 edx, DWORD PTR [edi+112]
  002e4	52		 push	 edx
  002e5	ff 50 10	 call	 DWORD PTR [eax+16]

; 492  : 	
; 493  : 	// 결과 
; 494  : 	file.read((char*)&m_ActionResultID, SIZE_ACTIONRESULTID);

  002e8	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  002ec	74 3c		 je	 SHORT $L111081
  002ee	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  002f1	8b 01		 mov	 eax, DWORD PTR [ecx]
  002f3	6a 02		 push	 2
  002f5	8d 97 d0 00 00
	00		 lea	 edx, DWORD PTR [edi+208]
  002fb	52		 push	 edx
  002fc	ff 50 10	 call	 DWORD PTR [eax+16]

; 495  : 	file.read((char*)&m_ActionResultValue, 4);

  002ff	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00303	74 25		 je	 SHORT $L111081
  00305	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00308	8b 01		 mov	 eax, DWORD PTR [ecx]
  0030a	6a 04		 push	 4
  0030c	8d 97 d4 00 00
	00		 lea	 edx, DWORD PTR [edi+212]
  00312	52		 push	 edx
  00313	ff 50 10	 call	 DWORD PTR [eax+16]

; 496  : 
; 497  : 	WORD es;
; 498  : 	file.read((char*)&es, 2);

  00316	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0031a	74 0e		 je	 SHORT $L111081
  0031c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0031f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00321	6a 02		 push	 2
  00323	8d 55 f8	 lea	 edx, DWORD PTR _es$[ebp]
  00326	52		 push	 edx
  00327	ff 50 10	 call	 DWORD PTR [eax+16]
$L111081:

; 499  : 	m_EffectStatus = (EFFECTSTATUS)es;

  0032a	0f b7 45 f8	 movzx	 eax, WORD PTR _es$[ebp]
  0032e	89 87 dc 00 00
	00		 mov	 DWORD PTR [edi+220], eax

; 500  : 	bool bAttack;
; 501  : 	file.read((char*)&bAttack, 1);

  00334	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00338	74 0e		 je	 SHORT $L111086
  0033a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0033d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0033f	6a 01		 push	 1
  00341	8d 55 fe	 lea	 edx, DWORD PTR _bAttack$[ebp]
  00344	52		 push	 edx
  00345	ff 50 10	 call	 DWORD PTR [eax+16]
$L111086:

; 502  : 	m_bAttack = bAttack;

  00348	0f b6 45 fe	 movzx	 eax, BYTE PTR _bAttack$[ebp]
  0034c	89 47 74	 mov	 DWORD PTR [edi+116], eax

; 503  : 
; 504  : 	bool bComboAttackSkill;
; 505  : 	file.read((char*)&bComboAttackSkill, 1);	 // Sjheon 2005.06.20

  0034f	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00353	74 0e		 je	 SHORT $L111091
  00355	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00358	8b 01		 mov	 eax, DWORD PTR [ecx]
  0035a	6a 01		 push	 1
  0035c	8d 55 fd	 lea	 edx, DWORD PTR _bComboAttackSkill$[ebp]
  0035f	52		 push	 edx
  00360	ff 50 10	 call	 DWORD PTR [eax+16]
$L111091:

; 506  : 	m_bComboAttackSkill = bComboAttackSkill;	

  00363	0f b6 45 fd	 movzx	 eax, BYTE PTR _bComboAttackSkill$[ebp]
  00367	89 47 78	 mov	 DWORD PTR [edi+120], eax

; 507  : 
; 508  : 	file.read((char*)&m_SelectCreatureAttr, 1);

  0036a	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0036e	74 11		 je	 SHORT $L111096
  00370	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00373	8b 01		 mov	 eax, DWORD PTR [ecx]
  00375	6a 01		 push	 1
  00377	8d 97 2e 01 00
	00		 lea	 edx, DWORD PTR [edi+302]
  0037d	52		 push	 edx
  0037e	ff 50 10	 call	 DWORD PTR [eax+16]
$L111096:

; 509  : 
; 510  : 	char flag = 0;
; 511  : 	file.read((char*)&flag, sizeof(char) );

  00381	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00385	c6 45 0b 00	 mov	 BYTE PTR _flag$[ebp], 0
  00389	74 0e		 je	 SHORT $L111101
  0038b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0038e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00390	6a 01		 push	 1
  00392	8d 55 0b	 lea	 edx, DWORD PTR _flag$[ebp]
  00395	52		 push	 edx
  00396	ff 50 10	 call	 DWORD PTR [eax+16]
$L111101:

; 512  : 
; 513  : 	m_bUseGrade = (flag & 0x1) != 0;

  00399	8a 45 0b	 mov	 al, BYTE PTR _flag$[ebp]

; 514  : 	m_bUseActionStep = (flag & 0x2) != 0;

  0039c	0f be 4d 0b	 movsx	 ecx, BYTE PTR _flag$[ebp]
  003a0	24 01		 and	 al, 1
  003a2	88 87 2f 01 00
	00		 mov	 BYTE PTR [edi+303], al
  003a8	8b c1		 mov	 eax, ecx
  003aa	d1 e8		 shr	 eax, 1

; 515  : 	m_bAttachSelf = (flag & 0x4) != 0;		

  003ac	c1 e9 02	 shr	 ecx, 2
  003af	24 01		 and	 al, 1
  003b1	80 e1 01	 and	 cl, 1

; 516  : 	
; 517  : 	if( m_bUseActionStep )

  003b4	84 c0		 test	 al, al
  003b6	88 47 15	 mov	 BYTE PTR [edi+21], al
  003b9	88 8f 30 01 00
	00		 mov	 BYTE PTR [edi+304], cl
  003bf	74 22		 je	 SHORT $L111146

; 518  : 	{
; 519  : 		for( i = 0;i<MAX_ACTION_STEP; i++)

  003c1	8d 5f 16	 lea	 ebx, DWORD PTR [edi+22]
  003c4	c7 45 f4 05 00
	00 00		 mov	 DWORD PTR tv571[ebp], 5
$L109310:

; 520  : 		{
; 521  : 			file.read((char*)&m_ActionStep[i],sizeof( TYPE_ACTIONINFO ) );

  003cb	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  003cf	74 0b		 je	 SHORT $L109311
  003d1	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  003d4	8b 01		 mov	 eax, DWORD PTR [ecx]
  003d6	6a 02		 push	 2
  003d8	53		 push	 ebx
  003d9	ff 50 10	 call	 DWORD PTR [eax+16]
$L109311:
  003dc	43		 inc	 ebx
  003dd	43		 inc	 ebx
  003de	ff 4d f4	 dec	 DWORD PTR tv571[ebp]
  003e1	75 e8		 jne	 SHORT $L109310
$L111146:

; 522  : 		}
; 523  : 	}
; 524  : 
; 525  : 	if(m_bComboAttackSkill)

  003e3	83 7f 78 00	 cmp	 DWORD PTR [edi+120], 0
  003e7	74 22		 je	 SHORT $L109318

; 526  : 	{
; 527  : 		for( i = 0;i< (MAX_ACTION_STEP - 1); i++)

  003e9	8d 5f 22	 lea	 ebx, DWORD PTR [edi+34]
  003ec	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR tv213[ebp], 4
$L111149:

; 528  : 		{
; 529  : 			file.read((char*)&m_ComboSkillActionStep[i],sizeof( TYPE_ACTIONINFO ) );

  003f3	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  003f7	74 0b		 je	 SHORT $L109317
  003f9	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  003fc	8b 01		 mov	 eax, DWORD PTR [ecx]
  003fe	6a 02		 push	 2
  00400	53		 push	 ebx
  00401	ff 50 10	 call	 DWORD PTR [eax+16]
$L109317:
  00404	43		 inc	 ebx
  00405	43		 inc	 ebx
  00406	ff 4d f4	 dec	 DWORD PTR tv213[ebp]
  00409	75 e8		 jne	 SHORT $L111149
$L109318:

; 530  : 		}
; 531  : 	}
; 532  : 
; 533  : 	//file.read((char*)&m_ComboActionResultEffect,sizeof( TYPE_ACTIONINFO ) );
; 534  : 	
; 535  : 	file.read((char*)&m_Parent, sizeof(TYPE_ACTIONINFO ) );

  0040b	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0040f	74 53		 je	 SHORT $L111130
  00411	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00414	8b 01		 mov	 eax, DWORD PTR [ecx]
  00416	6a 02		 push	 2
  00418	8d 57 20	 lea	 edx, DWORD PTR [edi+32]
  0041b	52		 push	 edx
  0041c	ff 50 10	 call	 DWORD PTR [eax+16]

; 536  : 	file.read((char*)&m_MasterySkillStep, 1 );

  0041f	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00423	74 3f		 je	 SHORT $L111130
  00425	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00428	8b 01		 mov	 eax, DWORD PTR [ecx]
  0042a	6a 01		 push	 1
  0042c	8d 97 31 01 00
	00		 lea	 edx, DWORD PTR [edi+305]
  00432	52		 push	 edx
  00433	ff 50 10	 call	 DWORD PTR [eax+16]

; 537  : 	file.read((char*)&m_bIgnoreFailDelay, 1 );

  00436	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0043a	74 28		 je	 SHORT $L111130
  0043c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0043f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00441	6a 01		 push	 1
  00443	8d 97 32 01 00
	00		 lea	 edx, DWORD PTR [edi+306]
  00449	52		 push	 edx
  0044a	ff 50 10	 call	 DWORD PTR [eax+16]

; 538  : 	file.read((char*)&m_byActionStepCnt, 1 );

  0044d	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00451	74 11		 je	 SHORT $L111130
  00453	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00456	8b 01		 mov	 eax, DWORD PTR [ecx]
  00458	6a 01		 push	 1
  0045a	8d 97 33 01 00
	00		 lea	 edx, DWORD PTR [edi+307]
  00460	52		 push	 edx
  00461	ff 50 10	 call	 DWORD PTR [eax+16]
$L111130:

; 539  : /*
; 540  : 	file.read((char*)&flag, sizeof( char ) );
; 541  : 
; 542  : 	m_bAdvancementClassSkill = (flag & 0x1 ) != 0;
; 543  : 	m_bNonAdvancementClassSkill = (flag & 0x2) != 0;
; 544  : */
; 545  : 	// 각 단계에 대한 정보
; 546  : 	CTypeTable<ACTION_INFO_NODE>::LoadFromFile(file);

  00464	56		 push	 esi
  00465	8b cf		 mov	 ecx, edi
  00467	e8 00 00 00 00	 call	 ?LoadFromFile@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXAAVivfstream@@@Z ; CTypeTable<ACTION_INFO_NODE>::LoadFromFile
  0046c	5f		 pop	 edi
  0046d	5e		 pop	 esi
  0046e	5b		 pop	 ebx

; 547  : }

  0046f	c9		 leave
  00470	c2 04 00	 ret	 4
?LoadFromFile@MActionInfo@@QAEXAAVivfstream@@@Z ENDP	; MActionInfo::LoadFromFile
_TEXT	ENDS
PUBLIC	?SaveToFile@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ; CTypeTable<ACTION_INFO_NODE>::SaveToFile
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\ctypetable.h
;	COMDAT ?SaveToFile@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
?SaveToFile@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z PROC NEAR ; CTypeTable<ACTION_INFO_NODE>::SaveToFile, COMDAT
; _this$ = ecx

; 125  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 126  : 	// size 저장
; 127  : 	file.write((const char*)&m_Size, 4);

  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR _file$[esp+4]
  00008	6a 04		 push	 4
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 128  : 
; 129  : 	// 아무 것도 없는 경우
; 130  : 	if (m_pTypeInfo==NULL)

  00010	33 db		 xor	 ebx, ebx
  00012	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  00015	74 1e		 je	 SHORT $L109676
  00017	57		 push	 edi

; 131  : 		return;
; 132  : 
; 133  : 	// 각각의 정보 저장
; 134  : 	for (int i=0; i<m_Size; i++)

  00018	33 ff		 xor	 edi, edi
  0001a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0001c	7e 16		 jle	 SHORT $L111181
$L109674:
  0001e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 135  : 	{
; 136  : 		m_pTypeInfo[i].SaveToFile(file);

  00021	ff 74 24 10	 push	 DWORD PTR _file$[esp+8]
  00025	03 cb		 add	 ecx, ebx
  00027	e8 00 00 00 00	 call	 ?SaveToFile@ACTION_INFO_NODE@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ; ACTION_INFO_NODE::SaveToFile
  0002c	47		 inc	 edi
  0002d	83 c3 10	 add	 ebx, 16			; 00000010H
  00030	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00032	7c ea		 jl	 SHORT $L109674
$L111181:
  00034	5f		 pop	 edi
$L109676:
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 137  : 	}
; 138  : }

  00037	c2 04 00	 ret	 4
?SaveToFile@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ENDP ; CTypeTable<ACTION_INFO_NODE>::SaveToFile
_TEXT	ENDS
PUBLIC	?Release@?$CTypeTable@VMActionInfo@@@@QAEXXZ	; CTypeTable<MActionInfo>::Release
; Function compile flags: /Ogsy
;	COMDAT ?Release@?$CTypeTable@VMActionInfo@@@@QAEXXZ
_TEXT	SEGMENT
?Release@?$CTypeTable@VMActionInfo@@@@QAEXXZ PROC NEAR	; CTypeTable<MActionInfo>::Release, COMDAT
; _this$ = ecx

; 108  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 109  : 	if (m_pTypeInfo != NULL)

  00003	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0e		 je	 SHORT $L109910

; 110  : 	{
; 111  : 		// 모든 CSprite를 지운다.
; 112  : 		delete [] m_pTypeInfo;

  0000a	6a 03		 push	 3
  0000c	e8 00 00 00 00	 call	 ??_EMActionInfo@@QAEPAXI@Z

; 113  : 		m_pTypeInfo = NULL;

  00011	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 114  : 		
; 115  : 		m_Size = 0;

  00015	83 26 00	 and	 DWORD PTR [esi], 0
$L109910:
  00018	5e		 pop	 esi

; 116  : 	}
; 117  : }

  00019	c3		 ret	 0
?Release@?$CTypeTable@VMActionInfo@@@@QAEXXZ ENDP	; CTypeTable<MActionInfo>::Release
_TEXT	ENDS
PUBLIC	?SaveToFile@MActionInfo@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ; MActionInfo::SaveToFile
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mactioninfotable.cpp
;	COMDAT ?SaveToFile@MActionInfo@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z
_TEXT	SEGMENT
_es$ = -20						; size = 2
tv810 = -16						; size = 4
tv753 = -16						; size = 4
tv695 = -16						; size = 4
tv667 = -12						; size = 4
tv261 = -12						; size = 4
tv154 = -12						; size = 4
tv832 = -8						; size = 4
tv775 = -8						; size = 4
tv626 = -8						; size = 4
tv597 = -8						; size = 4
tv543 = -8						; size = 4
_bComboAttackSkill$ = -3				; size = 1
_bAttack$ = -2						; size = 1
_pt$ = -1						; size = 1
_file$ = 8						; size = 4
_flag$ = 11						; size = 1
?SaveToFile@MActionInfo@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z PROC NEAR ; MActionInfo::SaveToFile, COMDAT
; _this$ = ecx

; 285  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 286  : 	// 임시로 계산.. - -;
; 287  : 	// startframe이 늦은 만큼 delay도 줄어든다
; 288  : 	/*
; 289  : 	if (m_StartFrame==0xFFFF)
; 290  : 	{
; 291  : 		m_Delay = 0;
; 292  : 	}
; 293  : 	else 
; 294  : 	{
; 295  : 		int minusDelay = m_StartFrame * 1000 / 16;
; 296  : 
; 297  : 		if (m_Delay < minusDelay)
; 298  : 		{
; 299  : 			m_Delay = 0;
; 300  : 		}
; 301  : 		else
; 302  : 		{
; 303  : 			m_Delay -= minusDelay;
; 304  : 		}
; 305  : 	}
; 306  : 	*/
; 307  : 	m_Name.SaveToFile( file );

  00009	8b 7d 08	 mov	 edi, DWORD PTR _file$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	57		 push	 edi
  00014	ff 50 04	 call	 DWORD PTR [eax+4]

; 308  : 
; 309  : 	file.write((const char*)&m_Action, 1);

  00017	33 db		 xor	 ebx, ebx
  00019	43		 inc	 ebx
  0001a	53		 push	 ebx
  0001b	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  0001e	50		 push	 eax
  0001f	8b cf		 mov	 ecx, edi
  00021	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 310  : 	file.write((const char*)&m_ActionEffectSpriteType, SIZE_EFFECTSPRITETYPE);

  00026	6a 02		 push	 2
  00028	8d 46 2e	 lea	 eax, DWORD PTR [esi+46]
  0002b	50		 push	 eax
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 311  : 	file.write((const char*)&m_ActionEffectSpriteTypeFemale, SIZE_EFFECTSPRITETYPE);

  00033	6a 02		 push	 2
  00035	8d 46 30	 lea	 eax, DWORD PTR [esi+48]
  00038	50		 push	 eax
  00039	8b cf		 mov	 ecx, edi
  0003b	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 312  : 
; 313  : 	file.write((const char*)&m_bUseRepeatFrame, 1);

  00040	53		 push	 ebx
  00041	8d 86 e0 00 00
	00		 lea	 eax, DWORD PTR [esi+224]
  00047	50		 push	 eax
  00048	8b cf		 mov	 ecx, edi
  0004a	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write
  0004f	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  00052	89 45 f8	 mov	 DWORD PTR tv543[ebp], eax
  00055	c7 45 f4 03 00
	00 00		 mov	 DWORD PTR tv261[ebp], 3
$L111204:

; 314  : 	for (int b=0;b<3;b++)
; 315  : 	{
; 316  : 	file.write((const char*)&m_CastingStartFrame[b],4);	// casting effect의 시작 frame

  0005c	8b 45 f8	 mov	 eax, DWORD PTR tv543[ebp]
  0005f	6a 04		 push	 4
  00061	83 c0 f4	 add	 eax, -12		; fffffff4H
  00064	50		 push	 eax
  00065	8b cf		 mov	 ecx, edi
  00067	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 317  : 	file.write((const char*)&m_CastingFrames[b],4);

  0006c	6a 04		 push	 4
  0006e	ff 75 f8	 push	 DWORD PTR tv543[ebp]
  00071	8b cf		 mov	 ecx, edi
  00073	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write
  00078	83 45 f8 04	 add	 DWORD PTR tv543[ebp], 4
  0007c	ff 4d f4	 dec	 DWORD PTR tv261[ebp]
  0007f	75 db		 jne	 SHORT $L111204

; 318  : 	}
; 319  : 	for (int i=0; i<9; i++)

  00081	8d 86 e4 00 00
	00		 lea	 eax, DWORD PTR [esi+228]
  00087	89 45 f8	 mov	 DWORD PTR tv597[ebp], eax
  0008a	c7 45 f4 09 00
	00 00		 mov	 DWORD PTR tv154[ebp], 9
$L111205:

; 320  : 	{
; 321  : 		file.write((const char*)&m_StartFrame[i], 4);

  00091	8b 45 f8	 mov	 eax, DWORD PTR tv597[ebp]
  00094	6a 04		 push	 4
  00096	83 c0 98	 add	 eax, -104		; ffffff98H
  00099	50		 push	 eax
  0009a	8b cf		 mov	 ecx, edi
  0009c	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 322  : 		//file.write((const char*)&m_CastingStartFrame[i], 4);
; 323  : 		//file.write((const char*)&m_CastingFrames[i], 4);		
; 324  : 
; 325  : 		file.write((const char*)&m_RepeatStartFrame[i], 4);	

  000a1	6a 04		 push	 4
  000a3	ff 75 f8	 push	 DWORD PTR tv597[ebp]
  000a6	8b cf		 mov	 ecx, edi
  000a8	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 326  : 		file.write((const char*)&m_RepeatEndFrame[i], 4);	

  000ad	8b 45 f8	 mov	 eax, DWORD PTR tv597[ebp]
  000b0	6a 04		 push	 4
  000b2	83 c0 24	 add	 eax, 36			; 00000024H
  000b5	50		 push	 eax
  000b6	8b cf		 mov	 ecx, edi
  000b8	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write
  000bd	83 45 f8 04	 add	 DWORD PTR tv597[ebp], 4
  000c1	ff 4d f4	 dec	 DWORD PTR tv154[ebp]
  000c4	75 cb		 jne	 SHORT $L111205

; 327  : 
; 328  : 	}
; 329  : 
; 330  : 
; 331  : 	for (int ispeed=0; ispeed<3; ispeed++)

  000c6	8d 86 a0 00 00
	00		 lea	 eax, DWORD PTR [esi+160]
  000cc	c7 45 f0 03 00
	00 00		 mov	 DWORD PTR tv695[ebp], 3
$L109182:

; 332  : 	{
; 333  : 		for (int iStep=0; iStep<4 ; iStep++)

  000d3	89 45 f8	 mov	 DWORD PTR tv626[ebp], eax
  000d6	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR tv667[ebp], 4
$L111206:

; 334  : 		{
; 335  : 			file.write((const char*)&m_ComboSkillStartFrame[ispeed][iStep], 4);

  000dd	6a 04		 push	 4
  000df	ff 75 f8	 push	 DWORD PTR tv626[ebp]
  000e2	8b cf		 mov	 ecx, edi
  000e4	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write
  000e9	83 45 f8 04	 add	 DWORD PTR tv626[ebp], 4
  000ed	ff 4d f4	 dec	 DWORD PTR tv667[ebp]
  000f0	75 eb		 jne	 SHORT $L111206
  000f2	ff 4d f0	 dec	 DWORD PTR tv695[ebp]
  000f5	8b 45 f8	 mov	 eax, DWORD PTR tv626[ebp]
  000f8	75 d9		 jne	 SHORT $L109182

; 336  : 		}
; 337  : 	}
; 338  : 
; 339  : 
; 340  : 
; 341  : 	file.write((const char*)&m_RepeatLimit, 2);	

  000fa	6a 02		 push	 2
  000fc	8d 86 2c 01 00
	00		 lea	 eax, DWORD PTR [esi+300]
  00102	50		 push	 eax
  00103	8b cf		 mov	 ecx, edi
  00105	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 342  : 
; 343  : 	file.write((const char*)&m_bCastingEffectToSelf, 1);

  0010a	53		 push	 ebx
  0010b	8d 46 50	 lea	 eax, DWORD PTR [esi+80]
  0010e	50		 push	 eax
  0010f	8b cf		 mov	 ecx, edi
  00111	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 344  : 	file.write((const char*)&m_CastingActionInfo, 4);

  00116	6a 04		 push	 4
  00118	8d 46 2a	 lea	 eax, DWORD PTR [esi+42]
  0011b	50		 push	 eax
  0011c	8b cf		 mov	 ecx, edi
  0011e	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 345  : 	file.write((const char*)&m_bCastingAction, 1);

  00123	53		 push	 ebx
  00124	8d 46 2c	 lea	 eax, DWORD PTR [esi+44]
  00127	50		 push	 eax
  00128	8b cf		 mov	 ecx, edi
  0012a	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 346  : 	file.write((const char*)&m_CastingTime, 2);

  0012f	6a 02		 push	 2
  00131	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00134	50		 push	 eax
  00135	8b cf		 mov	 ecx, edi
  00137	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 347  : 
; 348  : 	file.write((const char*)&m_Range, 1);

  0013c	53		 push	 ebx
  0013d	8d 46 54	 lea	 eax, DWORD PTR [esi+84]
  00140	50		 push	 eax
  00141	8b cf		 mov	 ecx, edi
  00143	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 349  : 	file.write((const char*)&m_fTarget, 1);	

  00148	53		 push	 ebx
  00149	8d 46 55	 lea	 eax, DWORD PTR [esi+85]
  0014c	50		 push	 eax
  0014d	8b cf		 mov	 ecx, edi
  0014f	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 350  : 	file.write((const char*)&m_fStart, 1);

  00154	53		 push	 ebx
  00155	8d 46 56	 lea	 eax, DWORD PTR [esi+86]
  00158	50		 push	 eax
  00159	8b cf		 mov	 ecx, edi
  0015b	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 351  : 	file.write((const char*)&m_fUserType, 1);

  00160	53		 push	 ebx
  00161	8d 46 57	 lea	 eax, DWORD PTR [esi+87]
  00164	50		 push	 eax
  00165	8b cf		 mov	 ecx, edi
  00167	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 352  : 	file.write((const char*)&m_fWeaponType, 2);

  0016c	6a 02		 push	 2
  0016e	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  00171	50		 push	 eax
  00172	8b cf		 mov	 ecx, edi
  00174	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 353  : 	file.write((const char*)&m_fCurrentWeapon, 1);

  00179	53		 push	 ebx
  0017a	8d 46 5a	 lea	 eax, DWORD PTR [esi+90]
  0017d	50		 push	 eax
  0017e	8b cf		 mov	 ecx, edi
  00180	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 354  : 	file.write((const char*)&m_fOption, 1);

  00185	53		 push	 ebx
  00186	8d 86 d8 00 00
	00		 lea	 eax, DWORD PTR [esi+216]
  0018c	50		 push	 eax
  0018d	8b cf		 mov	 ecx, edi
  0018f	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 355  : 	file.write((const char*)&m_PlusActionInfo, 4);

  00194	6a 04		 push	 4
  00196	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  00199	50		 push	 eax
  0019a	8b cf		 mov	 ecx, edi
  0019c	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 356  : 
; 357  : 	BYTE pt = (BYTE)m_PacketType;

  001a1	8a 46 5c	 mov	 al, BYTE PTR [esi+92]
  001a4	88 45 ff	 mov	 BYTE PTR _pt$[ebp], al

; 358  : 	file.write((const char*)&pt, 1);		

  001a7	53		 push	 ebx
  001a8	8d 45 ff	 lea	 eax, DWORD PTR _pt$[ebp]
  001ab	50		 push	 eax
  001ac	8b cf		 mov	 ecx, edi
  001ae	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 359  : 
; 360  : 	file.write((const char*)&m_Delay, 2);

  001b3	6a 02		 push	 2
  001b5	8d 46 60	 lea	 eax, DWORD PTR [esi+96]
  001b8	50		 push	 eax
  001b9	8b cf		 mov	 ecx, edi
  001bb	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 361  : 	file.write((const char*)&m_Value, 4);

  001c0	6a 04		 push	 4
  001c2	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  001c5	50		 push	 eax
  001c6	8b cf		 mov	 ecx, edi
  001c8	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 362  : 	file.write((const char*)&m_SoundID, SIZE_SOUNDID);

  001cd	6a 02		 push	 2
  001cf	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  001d2	50		 push	 eax
  001d3	8b cf		 mov	 ecx, edi
  001d5	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 363  : 	file.write((const char*)&m_SoundMaleID, SIZE_SOUNDID);

  001da	6a 02		 push	 2
  001dc	8d 46 6a	 lea	 eax, DWORD PTR [esi+106]
  001df	50		 push	 eax
  001e0	8b cf		 mov	 ecx, edi
  001e2	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 364  : 	file.write((const char*)&m_SoundFemaleID, SIZE_SOUNDID);

  001e7	6a 02		 push	 2
  001e9	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  001ec	50		 push	 eax
  001ed	8b cf		 mov	 ecx, edi
  001ef	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 365  : 
; 366  : 	file.write((const char*)&m_MainNode, 4);

  001f4	6a 04		 push	 4
  001f6	8d 46 70	 lea	 eax, DWORD PTR [esi+112]
  001f9	50		 push	 eax
  001fa	8b cf		 mov	 ecx, edi
  001fc	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 367  : 	
; 368  : 	// 결과 
; 369  : 	file.write((const char*)&m_ActionResultID, SIZE_ACTIONRESULTID);

  00201	6a 02		 push	 2
  00203	8d 86 d0 00 00
	00		 lea	 eax, DWORD PTR [esi+208]
  00209	50		 push	 eax
  0020a	8b cf		 mov	 ecx, edi
  0020c	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 370  : 	file.write((const char*)&m_ActionResultValue, 4);

  00211	6a 04		 push	 4
  00213	8d 86 d4 00 00
	00		 lea	 eax, DWORD PTR [esi+212]
  00219	50		 push	 eax
  0021a	8b cf		 mov	 ecx, edi
  0021c	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 371  : 
; 372  : 	WORD es = m_EffectStatus;

  00221	33 c0		 xor	 eax, eax
  00223	66 8b 86 dc 00
	00 00		 mov	 ax, WORD PTR [esi+220]

; 373  : 	file.write((const char*)&es, 2);

  0022a	6a 02		 push	 2
  0022c	8b cf		 mov	 ecx, edi
  0022e	89 45 ec	 mov	 DWORD PTR _es$[ebp], eax
  00231	8d 45 ec	 lea	 eax, DWORD PTR _es$[ebp]
  00234	50		 push	 eax
  00235	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 374  : 	
; 375  : 
; 376  : 	bool bAttack = (m_bAttack==TRUE);

  0023a	39 5e 74	 cmp	 DWORD PTR [esi+116], ebx

; 377  : 	file.write((const char*)&bAttack, 1);

  0023d	53		 push	 ebx
  0023e	0f 94 c0	 sete	 al
  00241	88 45 fe	 mov	 BYTE PTR _bAttack$[ebp], al
  00244	8d 45 fe	 lea	 eax, DWORD PTR _bAttack$[ebp]
  00247	50		 push	 eax
  00248	8b cf		 mov	 ecx, edi
  0024a	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 378  : 	
; 379  : 	bool bComboAttackSkill = (m_bComboAttackSkill==TRUE);

  0024f	39 5e 78	 cmp	 DWORD PTR [esi+120], ebx

; 380  : 	file.write((const char*)&bComboAttackSkill, 1);

  00252	53		 push	 ebx
  00253	0f 94 c0	 sete	 al
  00256	88 45 fd	 mov	 BYTE PTR _bComboAttackSkill$[ebp], al
  00259	8d 45 fd	 lea	 eax, DWORD PTR _bComboAttackSkill$[ebp]
  0025c	50		 push	 eax
  0025d	8b cf		 mov	 ecx, edi
  0025f	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 381  : 
; 382  : 
; 383  : 	file.write((const char*)&m_SelectCreatureAttr, 1);	

  00264	53		 push	 ebx
  00265	8d 86 2e 01 00
	00		 lea	 eax, DWORD PTR [esi+302]
  0026b	50		 push	 eax
  0026c	8b cf		 mov	 ecx, edi
  0026e	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 384  : 
; 385  : 	char flag = 0;	
; 386  : 	if( m_bUseGrade )

  00273	80 be 2f 01 00
	00 00		 cmp	 BYTE PTR [esi+303], 0
  0027a	c6 45 0b 00	 mov	 BYTE PTR _flag$[ebp], 0
  0027e	74 03		 je	 SHORT $L109222

; 387  : 		flag |= 0x1;

  00280	88 5d 0b	 mov	 BYTE PTR _flag$[ebp], bl
$L109222:

; 388  : 	if( m_bUseActionStep )

  00283	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  00287	74 04		 je	 SHORT $L109223

; 389  : 		flag |= 0x2;

  00289	80 4d 0b 02	 or	 BYTE PTR _flag$[ebp], 2
$L109223:

; 390  : 	if( m_bAttachSelf )

  0028d	80 be 30 01 00
	00 00		 cmp	 BYTE PTR [esi+304], 0
  00294	74 04		 je	 SHORT $L109224

; 391  : 		flag |= 0x4;

  00296	80 4d 0b 04	 or	 BYTE PTR _flag$[ebp], 4
$L109224:

; 392  : 	file.write((const char*)&flag, sizeof(char) );

  0029a	53		 push	 ebx
  0029b	8d 45 0b	 lea	 eax, DWORD PTR _flag$[ebp]
  0029e	50		 push	 eax
  0029f	8b cf		 mov	 ecx, edi
  002a1	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 393  : 	if( m_bUseActionStep )

  002a6	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  002aa	74 22		 je	 SHORT $L109230

; 394  : 	{
; 395  : 		for( i = 0;i<MAX_ACTION_STEP; i++)

  002ac	8d 46 16	 lea	 eax, DWORD PTR [esi+22]
  002af	89 45 f8	 mov	 DWORD PTR tv775[ebp], eax
  002b2	c7 45 f0 05 00
	00 00		 mov	 DWORD PTR tv753[ebp], 5
$L111207:

; 396  : 		{
; 397  : 			file.write((const char*)&m_ActionStep[i],sizeof( TYPE_ACTIONINFO ) );

  002b9	6a 02		 push	 2
  002bb	ff 75 f8	 push	 DWORD PTR tv775[ebp]
  002be	8b cf		 mov	 ecx, edi
  002c0	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write
  002c5	83 45 f8 02	 add	 DWORD PTR tv775[ebp], 2
  002c9	ff 4d f0	 dec	 DWORD PTR tv753[ebp]
  002cc	75 eb		 jne	 SHORT $L111207
$L109230:

; 398  : 		}
; 399  : 	}
; 400  : 
; 401  : 	if(m_bComboAttackSkill)

  002ce	83 7e 78 00	 cmp	 DWORD PTR [esi+120], 0
  002d2	74 22		 je	 SHORT $L109236

; 402  : 	{
; 403  : 		for( i = 0;i< (MAX_ACTION_STEP - 1); i++)

  002d4	8d 46 22	 lea	 eax, DWORD PTR [esi+34]
  002d7	89 45 f8	 mov	 DWORD PTR tv832[ebp], eax
  002da	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR tv810[ebp], 4
$L111208:

; 404  : 		{
; 405  : 			file.write((char*)&m_ComboSkillActionStep[i],sizeof( TYPE_ACTIONINFO ) );

  002e1	6a 02		 push	 2
  002e3	ff 75 f8	 push	 DWORD PTR tv832[ebp]
  002e6	8b cf		 mov	 ecx, edi
  002e8	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write
  002ed	83 45 f8 02	 add	 DWORD PTR tv832[ebp], 2
  002f1	ff 4d f0	 dec	 DWORD PTR tv810[ebp]
  002f4	75 eb		 jne	 SHORT $L111208
$L109236:

; 406  : 		}
; 407  : 	}
; 408  : 	
; 409  : 	//file.write((const char*)&m_ComboActionResultEffect,sizeof( TYPE_ACTIONINFO ) );
; 410  : 	
; 411  : 	file.write((const char*)&m_Parent, sizeof(TYPE_ACTIONINFO ) );

  002f6	6a 02		 push	 2
  002f8	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  002fb	50		 push	 eax
  002fc	8b cf		 mov	 ecx, edi
  002fe	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 412  : 	file.write((const char*)&m_MasterySkillStep, 1 );

  00303	53		 push	 ebx
  00304	8d 86 31 01 00
	00		 lea	 eax, DWORD PTR [esi+305]
  0030a	50		 push	 eax
  0030b	8b cf		 mov	 ecx, edi
  0030d	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 413  : 	file.write((const char*)&m_bIgnoreFailDelay, 1 );

  00312	53		 push	 ebx
  00313	8d 86 32 01 00
	00		 lea	 eax, DWORD PTR [esi+306]
  00319	50		 push	 eax
  0031a	8b cf		 mov	 ecx, edi
  0031c	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 414  : 
; 415  : 	file.write((const char*)&m_byActionStepCnt, 1 );

  00321	53		 push	 ebx
  00322	8d 86 33 01 00
	00		 lea	 eax, DWORD PTR [esi+307]
  00328	50		 push	 eax
  00329	8b cf		 mov	 ecx, edi
  0032b	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 416  : 
; 417  : 	flag = 0;
; 418  : /*	
; 419  : 	if( m_bAdvancementClassSkill ) flag |= 0x1;
; 420  : 	if( m_bNonAdvancementClassSkill ) flag |= 0x2;
; 421  : 	file.write( (const char*)&flag, sizeof( char ) );
; 422  : */	
; 423  : 	// 각 단계에 대한 정보
; 424  : 	CTypeTable<ACTION_INFO_NODE>::SaveToFile(file);

  00330	57		 push	 edi
  00331	8b ce		 mov	 ecx, esi
  00333	c6 45 0b 00	 mov	 BYTE PTR _flag$[ebp], 0
  00337	e8 00 00 00 00	 call	 ?SaveToFile@?$CTypeTable@VACTION_INFO_NODE@@@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ; CTypeTable<ACTION_INFO_NODE>::SaveToFile
  0033c	5f		 pop	 edi
  0033d	5e		 pop	 esi
  0033e	5b		 pop	 ebx

; 425  : }

  0033f	c9		 leave
  00340	c2 04 00	 ret	 4
?SaveToFile@MActionInfo@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ENDP ; MActionInfo::SaveToFile
_TEXT	ENDS
PUBLIC	??1?$CTypeTable@VMActionInfo@@@@QAE@XZ		; CTypeTable<MActionInfo>::~CTypeTable<MActionInfo>
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\ctypetable.h
;	COMDAT ??1?$CTypeTable@VMActionInfo@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CTypeTable@VMActionInfo@@@@QAE@XZ PROC NEAR	; CTypeTable<MActionInfo>::~CTypeTable<MActionInfo>, COMDAT
; _this$ = ecx

; 72   : 	Release();

  00000	e9 00 00 00 00	 jmp	 ?Release@?$CTypeTable@VMActionInfo@@@@QAEXXZ ; CTypeTable<MActionInfo>::Release
??1?$CTypeTable@VMActionInfo@@@@QAE@XZ ENDP		; CTypeTable<MActionInfo>::~CTypeTable<MActionInfo>
_TEXT	ENDS
PUBLIC	?SaveToFile@?$CTypeTable@VMActionInfo@@@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ; CTypeTable<MActionInfo>::SaveToFile
; Function compile flags: /Ogsy
;	COMDAT ?SaveToFile@?$CTypeTable@VMActionInfo@@@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
?SaveToFile@?$CTypeTable@VMActionInfo@@@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z PROC NEAR ; CTypeTable<MActionInfo>::SaveToFile, COMDAT
; _this$ = ecx

; 125  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 126  : 	// size 저장
; 127  : 	file.write((const char*)&m_Size, 4);

  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR _file$[esp+4]
  00008	6a 04		 push	 4
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 128  : 
; 129  : 	// 아무 것도 없는 경우
; 130  : 	if (m_pTypeInfo==NULL)

  00010	33 db		 xor	 ebx, ebx
  00012	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  00015	74 21		 je	 SHORT $L109723
  00017	57		 push	 edi

; 131  : 		return;
; 132  : 
; 133  : 	// 각각의 정보 저장
; 134  : 	for (int i=0; i<m_Size; i++)

  00018	33 ff		 xor	 edi, edi
  0001a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0001c	7e 19		 jle	 SHORT $L111216
$L109721:

; 135  : 	{
; 136  : 		m_pTypeInfo[i].SaveToFile(file);

  0001e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00021	ff 74 24 10	 push	 DWORD PTR _file$[esp+8]
  00025	03 cb		 add	 ecx, ebx
  00027	e8 00 00 00 00	 call	 ?SaveToFile@MActionInfo@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ; MActionInfo::SaveToFile
  0002c	47		 inc	 edi
  0002d	81 c3 38 01 00
	00		 add	 ebx, 312		; 00000138H
  00033	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00035	7c e7		 jl	 SHORT $L109721
$L111216:
  00037	5f		 pop	 edi
$L109723:
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx

; 137  : 	}
; 138  : }

  0003a	c2 04 00	 ret	 4
?SaveToFile@?$CTypeTable@VMActionInfo@@@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ENDP ; CTypeTable<MActionInfo>::SaveToFile
_TEXT	ENDS
PUBLIC	?Init@?$CTypeTable@VMActionInfo@@@@QAEXH@Z	; CTypeTable<MActionInfo>::Init
;	COMDAT xdata$x
xdata$x	SEGMENT
$T111229 DD	0ffffffffH
	DD	FLAT:$L111225
$T111227 DD	019930520H
	DD	01H
	DD	FLAT:$T111229
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?Init@?$CTypeTable@VMActionInfo@@@@QAEXH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T111222 = 8						; size = 4
_size$ = 8						; size = 4
?Init@?$CTypeTable@VMActionInfo@@@@QAEXH@Z PROC NEAR	; CTypeTable<MActionInfo>::Init, COMDAT
; _this$ = ecx

; 87   : {

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?Init@?$CTypeTable@VMActionInfo@@@@QAEXH@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	53		 push	 ebx
  0000b	56		 push	 esi

; 88   : 	// 개수가 없을 경우 
; 89   : 	if (size==0) 

  0000c	8b 75 08	 mov	 esi, DWORD PTR _size$[ebp]
  0000f	57		 push	 edi
  00010	33 ff		 xor	 edi, edi
  00012	3b f7		 cmp	 esi, edi
  00014	8b d9		 mov	 ebx, ecx
  00016	74 41		 je	 SHORT $L109897

; 90   : 		return;
; 91   : 
; 92   : 	// 일단 해제
; 93   : 	Release();

  00018	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VMActionInfo@@@@QAEXXZ ; CTypeTable<MActionInfo>::Release

; 94   : 
; 95   : 	// 메모리 잡기
; 96   : 	m_Size = size;
; 97   : 	
; 98   : 	m_pTypeInfo = new Type [m_Size];	

  0001d	8b c6		 mov	 eax, esi
  0001f	69 c0 38 01 00
	00		 imul	 eax, 312		; 00000138H
  00025	83 c0 04	 add	 eax, 4
  00028	50		 push	 eax
  00029	89 33		 mov	 DWORD PTR [ebx], esi
  0002b	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00030	59		 pop	 ecx
  00031	89 45 08	 mov	 DWORD PTR $T111222[ebp], eax
  00034	3b c7		 cmp	 eax, edi
  00036	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00039	74 1b		 je	 SHORT $L111224
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:??1MActionInfo@@QAE@XZ ; MActionInfo::~MActionInfo
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??0MActionInfo@@QAE@XZ ; MActionInfo::MActionInfo
  00045	56		 push	 esi
  00046	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00049	68 38 01 00 00	 push	 312			; 00000138H
  0004e	57		 push	 edi
  0004f	89 30		 mov	 DWORD PTR [eax], esi
  00051	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
$L111224:
  00056	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
$L109897:

; 99   : }

  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00066	c9		 leave
  00067	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L111225:
  00000	ff 75 08	 push	 DWORD PTR $T111222[ebp]
  00003	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?Init@?$CTypeTable@VMActionInfo@@@@QAEXH@Z:
  0000a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T111227
  0000f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Init@?$CTypeTable@VMActionInfo@@@@QAEXH@Z ENDP		; CTypeTable<MActionInfo>::Init
PUBLIC	??0MActionInfoTable@@QAE@XZ			; MActionInfoTable::MActionInfoTable
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mactioninfotable.cpp
;	COMDAT ??0MActionInfoTable@@QAE@XZ
_TEXT	SEGMENT
??0MActionInfoTable@@QAE@XZ PROC NEAR			; MActionInfoTable::MActionInfoTable, COMDAT
; _this$ = ecx

; 628  : {

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 629  : 	m_nMinResultActionInfo = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 630  : 	m_nMaxResultActionInfo = 0;

  0000c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 631  : }

  0000f	c3		 ret	 0
??0MActionInfoTable@@QAE@XZ ENDP			; MActionInfoTable::MActionInfoTable
_TEXT	ENDS
PUBLIC	??1MActionInfoTable@@QAE@XZ			; MActionInfoTable::~MActionInfoTable
; Function compile flags: /Ogsy
;	COMDAT ??1MActionInfoTable@@QAE@XZ
_TEXT	SEGMENT
??1MActionInfoTable@@QAE@XZ PROC NEAR			; MActionInfoTable::~MActionInfoTable, COMDAT
; _this$ = ecx

; 635  : }

  00000	e9 00 00 00 00	 jmp	 ?Release@?$CTypeTable@VMActionInfo@@@@QAEXXZ ; CTypeTable<MActionInfo>::Release
??1MActionInfoTable@@QAE@XZ ENDP			; MActionInfoTable::~MActionInfoTable
_TEXT	ENDS
PUBLIC	?SaveToFile@MActionInfoTable@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ; MActionInfoTable::SaveToFile
; Function compile flags: /Ogsy
;	COMDAT ?SaveToFile@MActionInfoTable@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
?SaveToFile@MActionInfoTable@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z PROC NEAR ; MActionInfoTable::SaveToFile, COMDAT
; _this$ = ecx

; 665  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 666  : 	file.write((const char*)&m_nMinResultActionInfo, 4);

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _file$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	6a 04		 push	 4
  0000a	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0000d	50		 push	 eax
  0000e	8b cf		 mov	 ecx, edi
  00010	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 667  : 	file.write((const char*)&m_nMaxResultActionInfo, 4);

  00015	6a 04		 push	 4
  00017	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0001a	50		 push	 eax
  0001b	8b cf		 mov	 ecx, edi
  0001d	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DV?$char_traits@D@_STL@@@_STL@@QAEAAV12@PBDH@Z ; _STL::basic_ostream<char,_STL::char_traits<char> >::write

; 668  : 
; 669  : 	CTypeTable<MActionInfo>::SaveToFile( file );

  00022	57		 push	 edi
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?SaveToFile@?$CTypeTable@VMActionInfo@@@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ; CTypeTable<MActionInfo>::SaveToFile
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi

; 670  : }

  0002c	c2 04 00	 ret	 4
?SaveToFile@MActionInfoTable@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ENDP ; MActionInfoTable::SaveToFile
_TEXT	ENDS
PUBLIC	?LoadFromFile@?$CTypeTable@VMActionInfo@@@@QAEXAAVivfstream@@@Z ; CTypeTable<MActionInfo>::LoadFromFile
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\ctypetable.h
;	COMDAT ?LoadFromFile@?$CTypeTable@VMActionInfo@@@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_numSize$ = -4						; size = 4
tv191 = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFile@?$CTypeTable@VMActionInfo@@@@QAEXAAVivfstream@@@Z PROC NEAR ; CTypeTable<MActionInfo>::LoadFromFile, COMDAT
; _this$ = ecx

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 147  : 	int numSize;
; 148  : 	
; 149  : 	// size 읽어오기
; 150  : 	file.read((char*)&numSize, 4);

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _file$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	33 ff		 xor	 edi, edi
  0000c	39 7b 04	 cmp	 DWORD PTR [ebx+4], edi
  0000f	8b f1		 mov	 esi, ecx
  00011	74 0e		 je	 SHORT $L111253
  00013	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 fc	 lea	 edx, DWORD PTR _numSize$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L111253:

; 151  : 
; 152  : 	// 현재 잡혀있는 메모리와 다르면 다시 메모리를 잡는다.
; 153  : 	if (m_Size != numSize)

  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR _numSize$[ebp]
  00026	74 11		 je	 SHORT $L109731

; 154  : 	{
; 155  : 		// 메모리 해제
; 156  : 		Release();

  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VMActionInfo@@@@QAEXXZ ; CTypeTable<MActionInfo>::Release

; 157  : 
; 158  : 		// 메모리 잡기
; 159  : 		Init( numSize );

  0002f	ff 75 fc	 push	 DWORD PTR _numSize$[ebp]
  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VMActionInfo@@@@QAEXH@Z ; CTypeTable<MActionInfo>::Init
$L109731:

; 160  : 	}
; 161  : 
; 162  : 	// file에서 각각의 정보를 읽어들인다.
; 163  : 	for (int i=0; i<m_Size; i++)

  00039	39 3e		 cmp	 DWORD PTR [esi], edi
  0003b	7e 1b		 jle	 SHORT $L109735
  0003d	89 7d 08	 mov	 DWORD PTR tv191[ebp], edi
$L111258:

; 164  : 	{
; 165  :  		m_pTypeInfo[i].LoadFromFile( file );

  00040	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00043	03 4d 08	 add	 ecx, DWORD PTR tv191[ebp]
  00046	53		 push	 ebx
  00047	e8 00 00 00 00	 call	 ?LoadFromFile@MActionInfo@@QAEXAAVivfstream@@@Z ; MActionInfo::LoadFromFile
  0004c	81 45 08 38 01
	00 00		 add	 DWORD PTR tv191[ebp], 312 ; 00000138H
  00053	47		 inc	 edi
  00054	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00056	7c e8		 jl	 SHORT $L111258
$L109735:
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx

; 166  : 	}
; 167  : }

  0005b	c9		 leave
  0005c	c2 04 00	 ret	 4
?LoadFromFile@?$CTypeTable@VMActionInfo@@@@QAEXAAVivfstream@@@Z ENDP ; CTypeTable<MActionInfo>::LoadFromFile
_TEXT	ENDS
PUBLIC	?LoadFromFile@MActionInfoTable@@QAEXAAVivfstream@@@Z ; MActionInfoTable::LoadFromFile
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mactioninfotable.cpp
;	COMDAT ?LoadFromFile@MActionInfoTable@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
?LoadFromFile@MActionInfoTable@@QAEXAAVivfstream@@@Z PROC NEAR ; MActionInfoTable::LoadFromFile, COMDAT
; _this$ = ecx

; 677  : {

  00000	56		 push	 esi

; 678  : 	file.read((char*)&m_nMinResultActionInfo, 4);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _file$[esp]
  00005	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	74 22		 je	 SHORT $L111268
  0000e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	6a 04		 push	 4
  00015	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  00018	52		 push	 edx
  00019	ff 50 10	 call	 DWORD PTR [eax+16]

; 679  : 	file.read((char*)&m_nMaxResultActionInfo, 4);

  0001c	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00020	74 0e		 je	 SHORT $L111268
  00022	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	6a 04		 push	 4
  00029	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  0002c	52		 push	 edx
  0002d	ff 50 10	 call	 DWORD PTR [eax+16]
$L111268:

; 680  : 
; 681  : 	CTypeTable<MActionInfo>::LoadFromFile( file );

  00030	56		 push	 esi
  00031	8b cf		 mov	 ecx, edi
  00033	e8 00 00 00 00	 call	 ?LoadFromFile@?$CTypeTable@VMActionInfo@@@@QAEXAAVivfstream@@@Z ; CTypeTable<MActionInfo>::LoadFromFile
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 682  : }

  0003a	c2 04 00	 ret	 4
?LoadFromFile@MActionInfoTable@@QAEXAAVivfstream@@@Z ENDP ; MActionInfoTable::LoadFromFile
_TEXT	ENDS
END
