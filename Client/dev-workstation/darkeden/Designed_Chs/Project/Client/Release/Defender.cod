; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\Defender.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BB@EBHMODHD@?2DKLDefender?4exe?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KCIFKPFK@?$DM?$DM?$DMDKLDefender?$DO?$DO?$DO?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HPCMFOIE@VVProtect?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06DIBEOEIP@?2?2?4?2?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?getDriverHandle@Defender@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getProcessHandle@Defender@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setCheckLive@Defender@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Defender@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GDefender@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Defender@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckChildProcess@@YGKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@Defender@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setProtectProcessPid@Defender@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?startProtect@Defender@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnLoadDriver@Defender@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getCheck@Defender@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?openVVProtect@Defender@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3Defender@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2Defender@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@Defender@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVDefender@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4Defender@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7Defender@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?getDriverHandle@Defender@@QBEPAXXZ		; Defender::getDriverHandle
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\defender.h
;	COMDAT ?getDriverHandle@Defender@@QBEPAXXZ
_TEXT	SEGMENT
?getDriverHandle@Defender@@QBEPAXXZ PROC NEAR		; Defender::getDriverHandle, COMDAT
; _this$ = ecx

; 13   : 	HANDLE	getDriverHandle() const { return m_hDriver; }

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?getDriverHandle@Defender@@QBEPAXXZ ENDP		; Defender::getDriverHandle
_TEXT	ENDS
PUBLIC	?getProcessHandle@Defender@@QBEPAXXZ		; Defender::getProcessHandle
; Function compile flags: /Ogsy
;	COMDAT ?getProcessHandle@Defender@@QBEPAXXZ
_TEXT	SEGMENT
?getProcessHandle@Defender@@QBEPAXXZ PROC NEAR		; Defender::getProcessHandle, COMDAT
; _this$ = ecx

; 15   : 	HANDLE	getProcessHandle() const { return m_hProcess; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?getProcessHandle@Defender@@QBEPAXXZ ENDP		; Defender::getProcessHandle
_TEXT	ENDS
PUBLIC	?setCheckLive@Defender@@QAEXH@Z			; Defender::setCheckLive
; Function compile flags: /Ogsy
;	COMDAT ?setCheckLive@Defender@@QAEXH@Z
_TEXT	SEGMENT
_isLive$ = 8						; size = 4
?setCheckLive@Defender@@QAEXH@Z PROC NEAR		; Defender::setCheckLive, COMDAT
; _this$ = ecx

; 22   : 	void	setCheckLive(const BOOL isLive) { checkLive = isLive; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _isLive$[esp-4]
  00004	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00007	c2 04 00	 ret	 4
?setCheckLive@Defender@@QAEXH@Z ENDP			; Defender::setCheckLive
_TEXT	ENDS
PUBLIC	??0Defender@@QAE@XZ				; Defender::Defender
PUBLIC	??_7Defender@@6B@				; Defender::`vftable'
PUBLIC	??_GDefender@@UAEPAXI@Z				; Defender::`scalar deleting destructor'
PUBLIC	??_R4Defender@@6B@				; Defender::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDefender@@@8				; Defender `RTTI Type Descriptor'
PUBLIC	??_R3Defender@@8				; Defender::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Defender@@8				; Defender::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@Defender@@8			; Defender::`RTTI Base Class Descriptor at (0,-1,0,0)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EDefender@@UAEPAXI@Z:NEAR			; Defender::`vector deleting destructor'
;	COMDAT ??_7Defender@@6B@
; File c:\darkeden\designed_common\project\client\defender.cpp
CONST	SEGMENT
??_7Defender@@6B@ DD FLAT:??_R4Defender@@6B@		; Defender::`vftable'
	DD	FLAT:??_EDefender@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4Defender@@6B@
rdata$r	SEGMENT
??_R4Defender@@6B@ DD 00H				; Defender::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDefender@@@8
	DD	FLAT:??_R3Defender@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDefender@@@8
_DATA	SEGMENT
??_R0?AVDefender@@@8 DD FLAT:??_7type_info@@6B@		; Defender `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDefender@@', 00H
_DATA	ENDS
;	COMDAT ??_R3Defender@@8
rdata$r	SEGMENT
??_R3Defender@@8 DD 00H					; Defender::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Defender@@8
rdata$r	ENDS
;	COMDAT ??_R2Defender@@8
rdata$r	SEGMENT
??_R2Defender@@8 DD FLAT:??_R1A@?0A@A@Defender@@8	; Defender::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@Defender@@8
rdata$r	SEGMENT
??_R1A@?0A@A@Defender@@8 DD FLAT:??_R0?AVDefender@@@8	; Defender::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Ogsy
rdata$r	ENDS
;	COMDAT ??0Defender@@QAE@XZ
_TEXT	SEGMENT
??0Defender@@QAE@XZ PROC NEAR				; Defender::Defender, COMDAT
; _this$ = ecx

; 7    : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7Defender@@6B@

; 8    : #ifndef _DEBUG
; 9    : 	VM_START_WITHLEVEL(20)

  00008	eb		 DB	 -21			; ffffffebH
  00009	10		 DB	 16			; 00000010H
  0000a	57		 DB	 87			; 00000057H
  0000b	4c		 DB	 76			; 0000004cH
  0000c	20		 DB	 32			; 00000020H
  0000d	20		 DB	 32			; 00000020H
  0000e	0c		 DB	 12			; 0000000cH
  0000f	00		 DB	 0
  00010	00		 DB	 0
  00011	00		 DB	 0
  00012	00		 DB	 0
  00013	14		 DB	 20			; 00000014H
  00014	00		 DB	 0
  00015	00		 DB	 0
  00016	57		 DB	 87			; 00000057H
  00017	4c		 DB	 76			; 0000004cH
  00018	20		 DB	 32			; 00000020H
  00019	20		 DB	 32			; 00000020H

; 10   : #endif
; 11   : 	m_pid = 0;

  0001a	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 12   : 	m_hProcess = INVALID_HANDLE_VALUE;

  0001e	83 48 08 ff	 or	 DWORD PTR [eax+8], -1

; 13   : 	m_hDriver = INVALID_HANDLE_VALUE;

  00022	83 48 0c ff	 or	 DWORD PTR [eax+12], -1

; 14   : 	checkLive = TRUE;

  00026	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 15   : #ifndef _DEBUG
; 16   : 	VM_END

  0002d	eb		 DB	 -21			; ffffffebH
  0002e	10		 DB	 16			; 00000010H
  0002f	57		 DB	 87			; 00000057H
  00030	4c		 DB	 76			; 0000004cH
  00031	20		 DB	 32			; 00000020H
  00032	20		 DB	 32			; 00000020H
  00033	0d		 DB	 13			; 0000000dH
  00034	00		 DB	 0
  00035	00		 DB	 0
  00036	00		 DB	 0
  00037	00		 DB	 0
  00038	00		 DB	 0
  00039	00		 DB	 0
  0003a	00		 DB	 0
  0003b	57		 DB	 87			; 00000057H
  0003c	4c		 DB	 76			; 0000004cH
  0003d	20		 DB	 32			; 00000020H
  0003e	20		 DB	 32			; 00000020H

; 17   : #endif
; 18   : }

  0003f	c3		 ret	 0
??0Defender@@QAE@XZ ENDP				; Defender::Defender
_TEXT	ENDS
PUBLIC	??1Defender@@UAE@XZ				; Defender::~Defender
; Function compile flags: /Ogsy
;	COMDAT ??1Defender@@UAE@XZ
_TEXT	SEGMENT
??1Defender@@UAE@XZ PROC NEAR				; Defender::~Defender, COMDAT
; _this$ = ecx

; 21   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7Defender@@6B@

; 22   : #ifndef _DEBUG
; 23   : 	VM_START_WITHLEVEL(20)

  00006	eb		 DB	 -21			; ffffffebH
  00007	10		 DB	 16			; 00000010H
  00008	57		 DB	 87			; 00000057H
  00009	4c		 DB	 76			; 0000004cH
  0000a	20		 DB	 32			; 00000020H
  0000b	20		 DB	 32			; 00000020H
  0000c	0c		 DB	 12			; 0000000cH
  0000d	00		 DB	 0
  0000e	00		 DB	 0
  0000f	00		 DB	 0
  00010	00		 DB	 0
  00011	14		 DB	 20			; 00000014H
  00012	00		 DB	 0
  00013	00		 DB	 0
  00014	57		 DB	 87			; 00000057H
  00015	4c		 DB	 76			; 0000004cH
  00016	20		 DB	 32			; 00000020H
  00017	20		 DB	 32			; 00000020H

; 24   : #endif
; 25   : 	//	DWORD retnum;
; 26   : 	//	if(m_hDriver!=INVALID_HANDLE_VALUE)
; 27   : 	//		DeviceIoControl(m_hDriver, GM_STOP, NULL, 0, NULL, 0, &retnum, NULL);
; 28   : 	
; 29   : 	//	if(m_hProcess!=INVALID_HANDLE_VALUE)
; 30   : 	//		::TerminateProcess(m_hProcess, 0);
; 31   : #ifndef _DEBUG
; 32   : 	VM_END

  00018	eb		 DB	 -21			; ffffffebH
  00019	10		 DB	 16			; 00000010H
  0001a	57		 DB	 87			; 00000057H
  0001b	4c		 DB	 76			; 0000004cH
  0001c	20		 DB	 32			; 00000020H
  0001d	20		 DB	 32			; 00000020H
  0001e	0d		 DB	 13			; 0000000dH
  0001f	00		 DB	 0
  00020	00		 DB	 0
  00021	00		 DB	 0
  00022	00		 DB	 0
  00023	00		 DB	 0
  00024	00		 DB	 0
  00025	00		 DB	 0
  00026	57		 DB	 87			; 00000057H
  00027	4c		 DB	 76			; 0000004cH
  00028	20		 DB	 32			; 00000020H
  00029	20		 DB	 32			; 00000020H

; 33   : #endif
; 34   : }

  0002a	c3		 ret	 0
??1Defender@@UAE@XZ ENDP				; Defender::~Defender
_TEXT	ENDS
PUBLIC	?CheckChildProcess@@YGKPAX@Z			; CheckChildProcess
EXTRN	__imp__DeviceIoControl@32:NEAR
EXTRN	__imp__GetCurrentProcessId@0:NEAR
EXTRN	__imp__ExitProcess@4:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?CheckChildProcess@@YGKPAX@Z
_TEXT	SEGMENT
_gm_pid$ = -12						; size = 8
_ret$ = -4						; size = 4
_retnum$ = 8						; size = 4
_lpParameter$ = 8					; size = 4
?CheckChildProcess@@YGKPAX@Z PROC NEAR			; CheckChildProcess, COMDAT

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 38   : 	Defender* pDefender = (Defender*)lpParameter;
; 39   : 	HANDLE hProcess = pDefender->getProcessHandle();
; 40   : 
; 41   : 	::WaitForSingleObject(hProcess, INFINITE);

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpParameter$[ebp]
  0000a	6a ff		 push	 -1
  0000c	ff 76 08	 push	 DWORD PTR [esi+8]
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 42   : 	
; 43   : 	pDefender->setCheckLive(FALSE);

  00015	83 66 10 00	 and	 DWORD PTR [esi+16], 0

; 44   : 
; 45   : // 	if(pDefender->openVVProtect()!=INVALID_HANDLE_VALUE)
; 46   : // 		pDefender->UnLoadDriver();
; 47   : 
; 48   : 	GM_PID_PARAM gm_pid;
; 49   : 	gm_pid.ulProcessId = ::GetCurrentProcessId();

  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0

; 50   : 	DWORD ret;
; 51   : 	DWORD retnum;
; 52   : 	int Ret = ::DeviceIoControl(pDefender->getDriverHandle(), GM_STOP, &gm_pid, sizeof(GM_PID_PARAM), &ret, sizeof(DWORD), &retnum, NULL);

  0001f	6a 00		 push	 0
  00021	89 45 f4	 mov	 DWORD PTR _gm_pid$[ebp], eax
  00024	8d 45 08	 lea	 eax, DWORD PTR _retnum$[ebp]
  00027	50		 push	 eax
  00028	6a 04		 push	 4
  0002a	8d 45 fc	 lea	 eax, DWORD PTR _ret$[ebp]
  0002d	50		 push	 eax
  0002e	6a 08		 push	 8
  00030	8d 45 f4	 lea	 eax, DWORD PTR _gm_pid$[ebp]
  00033	50		 push	 eax
  00034	68 6b c8 30 21	 push	 556845163		; 2130c86bH
  00039	ff 76 0c	 push	 DWORD PTR [esi+12]
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 53   : 
; 54   : 	::ExitProcess(0);

  00042	6a 00		 push	 0
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExitProcess@4
$L100224:
$L100223:
  0004a	cc		 int	 3
?CheckChildProcess@@YGKPAX@Z ENDP			; CheckChildProcess
_TEXT	ENDS
PUBLIC	?setProtectProcessPid@Defender@@QAEHXZ		; Defender::setProtectProcessPid
; Function compile flags: /Ogsy
;	COMDAT ?setProtectProcessPid@Defender@@QAEHXZ
_TEXT	SEGMENT
_pid$ = -16						; size = 8
_ret$ = -8						; size = 4
_retnum$ = -4						; size = 4
?setProtectProcessPid@Defender@@QAEHXZ PROC NEAR	; Defender::setProtectProcessPid, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 138  : #ifndef _DEBUG
; 139  : 	VM_START_WITHLEVEL(20)

  00009	eb		 DB	 -21			; ffffffebH
  0000a	10		 DB	 16			; 00000010H
  0000b	57		 DB	 87			; 00000057H
  0000c	4c		 DB	 76			; 0000004cH
  0000d	20		 DB	 32			; 00000020H
  0000e	20		 DB	 32			; 00000020H
  0000f	0c		 DB	 12			; 0000000cH
  00010	00		 DB	 0
  00011	00		 DB	 0
  00012	00		 DB	 0
  00013	00		 DB	 0
  00014	14		 DB	 20			; 00000014H
  00015	00		 DB	 0
  00016	00		 DB	 0
  00017	57		 DB	 87			; 00000057H
  00018	4c		 DB	 76			; 0000004cH
  00019	20		 DB	 32			; 00000020H
  0001a	20		 DB	 32			; 00000020H

; 140  : #endif
; 141  : 	if(m_hDriver == INVALID_HANDLE_VALUE)

  0001b	83 7e 0c ff	 cmp	 DWORD PTR [esi+12], -1
  0001f	75 04		 jne	 SHORT $L99512

; 142  : 		return FALSE;

  00021	33 c0		 xor	 eax, eax
  00023	eb 3e		 jmp	 SHORT $L99509
$L99512:

; 143  : 
; 144  : 	GM_PID_PARAM pid;
; 145  : 	pid.ulProcessId = (ULONG)::GetCurrentProcessId();

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0

; 146  : 	DWORD ret;
; 147  : 	DWORD retnum;
; 148  : 	int Ret = DeviceIoControl(m_hDriver, GM_SET_PID, &pid, sizeof(GM_PID_PARAM), &ret, sizeof(DWORD), &retnum, NULL);

  0002b	6a 00		 push	 0
  0002d	89 45 f0	 mov	 DWORD PTR _pid$[ebp], eax
  00030	8d 45 fc	 lea	 eax, DWORD PTR _retnum$[ebp]
  00033	50		 push	 eax
  00034	6a 04		 push	 4
  00036	8d 45 f8	 lea	 eax, DWORD PTR _ret$[ebp]
  00039	50		 push	 eax
  0003a	6a 08		 push	 8
  0003c	8d 45 f0	 lea	 eax, DWORD PTR _pid$[ebp]
  0003f	50		 push	 eax
  00040	68 5f c8 30 21	 push	 556845151		; 2130c85fH
  00045	ff 76 0c	 push	 DWORD PTR [esi+12]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 149  : #ifndef _DEBUG
; 150  : 	VM_END

  0004e	eb		 DB	 -21			; ffffffebH
  0004f	10		 DB	 16			; 00000010H
  00050	57		 DB	 87			; 00000057H
  00051	4c		 DB	 76			; 0000004cH
  00052	20		 DB	 32			; 00000020H
  00053	20		 DB	 32			; 00000020H
  00054	0d		 DB	 13			; 0000000dH
  00055	00		 DB	 0
  00056	00		 DB	 0
  00057	00		 DB	 0
  00058	00		 DB	 0
  00059	00		 DB	 0
  0005a	00		 DB	 0
  0005b	00		 DB	 0
  0005c	57		 DB	 87			; 00000057H
  0005d	4c		 DB	 76			; 0000004cH
  0005e	20		 DB	 32			; 00000020H
  0005f	20		 DB	 32			; 00000020H

; 151  : #endif
; 152  : 	return TRUE;

  00060	33 c0		 xor	 eax, eax
  00062	40		 inc	 eax
$L99509:
  00063	5e		 pop	 esi

; 153  : }

  00064	c9		 leave
  00065	c3		 ret	 0
?setProtectProcessPid@Defender@@QAEHXZ ENDP		; Defender::setProtectProcessPid
_TEXT	ENDS
PUBLIC	?startProtect@Defender@@QAEHXZ			; Defender::startProtect
; Function compile flags: /Ogsy
;	COMDAT ?startProtect@Defender@@QAEHXZ
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_retnum$ = -4						; size = 4
?startProtect@Defender@@QAEHXZ PROC NEAR		; Defender::startProtect, COMDAT
; _this$ = ecx

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 157  : #ifndef _DEBUG
; 158  : 	VM_START_WITHLEVEL(20)

  00005	eb		 DB	 -21			; ffffffebH
  00006	10		 DB	 16			; 00000010H
  00007	57		 DB	 87			; 00000057H
  00008	4c		 DB	 76			; 0000004cH
  00009	20		 DB	 32			; 00000020H
  0000a	20		 DB	 32			; 00000020H
  0000b	0c		 DB	 12			; 0000000cH
  0000c	00		 DB	 0
  0000d	00		 DB	 0
  0000e	00		 DB	 0
  0000f	00		 DB	 0
  00010	14		 DB	 20			; 00000014H
  00011	00		 DB	 0
  00012	00		 DB	 0
  00013	57		 DB	 87			; 00000057H
  00014	4c		 DB	 76			; 0000004cH
  00015	20		 DB	 32			; 00000020H
  00016	20		 DB	 32			; 00000020H

; 159  : #endif
; 160  : 	if(m_hDriver == INVALID_HANDLE_VALUE)

  00017	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001a	83 f8 ff	 cmp	 eax, -1
  0001d	75 04		 jne	 SHORT $L99525

; 161  : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax

; 171  : }

  00021	c9		 leave
  00022	c3		 ret	 0
$L99525:

; 162  : 
; 163  : 	DWORD ret;
; 164  : 	DWORD retnum;
; 165  : 	int Ret = DeviceIoControl(m_hDriver, GM_START, NULL, 0, &ret, sizeof(DWORD), &retnum, NULL);

  00023	33 c9		 xor	 ecx, ecx
  00025	51		 push	 ecx
  00026	8d 55 fc	 lea	 edx, DWORD PTR _retnum$[ebp]
  00029	52		 push	 edx
  0002a	6a 04		 push	 4
  0002c	8d 55 f8	 lea	 edx, DWORD PTR _ret$[ebp]
  0002f	52		 push	 edx
  00030	51		 push	 ecx
  00031	51		 push	 ecx
  00032	68 67 c8 30 21	 push	 556845159		; 2130c867H
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 166  : 	
; 167  : #ifndef _DEBUG 
; 168  : 	VM_END

  0003e	eb		 DB	 -21			; ffffffebH
  0003f	10		 DB	 16			; 00000010H
  00040	57		 DB	 87			; 00000057H
  00041	4c		 DB	 76			; 0000004cH
  00042	20		 DB	 32			; 00000020H
  00043	20		 DB	 32			; 00000020H
  00044	0d		 DB	 13			; 0000000dH
  00045	00		 DB	 0
  00046	00		 DB	 0
  00047	00		 DB	 0
  00048	00		 DB	 0
  00049	00		 DB	 0
  0004a	00		 DB	 0
  0004b	00		 DB	 0
  0004c	57		 DB	 87			; 00000057H
  0004d	4c		 DB	 76			; 0000004cH
  0004e	20		 DB	 32			; 00000020H
  0004f	20		 DB	 32			; 00000020H

; 169  : #endif
; 170  : 	return TRUE;

  00050	33 c0		 xor	 eax, eax
  00052	40		 inc	 eax

; 171  : }

  00053	c9		 leave
  00054	c3		 ret	 0
?startProtect@Defender@@QAEHXZ ENDP			; Defender::startProtect
_TEXT	ENDS
PUBLIC	?UnLoadDriver@Defender@@QAEHXZ			; Defender::UnLoadDriver
PUBLIC	??_C@_09HPCMFOIE@VVProtect?$AA@			; `string'
EXTRN	__imp__CloseServiceHandle@4:NEAR
EXTRN	__imp__ControlService@12:NEAR
EXTRN	__imp__DeleteService@4:NEAR
EXTRN	__imp__OpenSCManagerA@12:NEAR
EXTRN	__imp__OpenServiceA@12:NEAR
;	COMDAT ??_C@_09HPCMFOIE@VVProtect?$AA@
CONST	SEGMENT
??_C@_09HPCMFOIE@VVProtect?$AA@ DB 'VVProtect', 00H	; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?UnLoadDriver@Defender@@QAEHXZ
_TEXT	SEGMENT
_ss$99538 = -28						; size = 28
?UnLoadDriver@Defender@@QAEHXZ PROC NEAR		; Defender::UnLoadDriver, COMDAT
; _this$ = ecx

; 174  : {

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 175  : #ifndef _DEBUG
; 176  : 	VM_START_WITHLEVEL(20)

  00003	eb		 DB	 -21			; ffffffebH
  00004	10		 DB	 16			; 00000010H
  00005	57		 DB	 87			; 00000057H
  00006	4c		 DB	 76			; 0000004cH
  00007	20		 DB	 32			; 00000020H
  00008	20		 DB	 32			; 00000020H
  00009	0c		 DB	 12			; 0000000cH
  0000a	00		 DB	 0
  0000b	00		 DB	 0
  0000c	00		 DB	 0
  0000d	00		 DB	 0
  0000e	14		 DB	 20			; 00000014H
  0000f	00		 DB	 0
  00010	00		 DB	 0
  00011	57		 DB	 87			; 00000057H
  00012	4c		 DB	 76			; 0000004cH
  00013	20		 DB	 32			; 00000020H
  00014	20		 DB	 32			; 00000020H

; 177  : #endif
; 178  : 	SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);

  00015	6a 02		 push	 2
  00017	6a 00		 push	 0
  00019	6a 00		 push	 0
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenSCManagerA@12

; 179  : 	if(hSCManager != NULL)

  00021	85 c0		 test	 eax, eax
  00023	74 3c		 je	 SHORT $L99534
  00025	56		 push	 esi
  00026	57		 push	 edi

; 180  : 	{
; 181  : 		SC_HANDLE hService = OpenService(hSCManager, EXE_DRIVER_NAME, DELETE | SERVICE_STOP);

  00027	68 20 00 01 00	 push	 65568			; 00010020H
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09HPCMFOIE@VVProtect?$AA@
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenServiceA@12

; 182  : 		if(hService != NULL)

  00038	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseServiceHandle@4
  0003e	8b f0		 mov	 esi, eax
  00040	85 f6		 test	 esi, esi
  00042	74 18		 je	 SHORT $L99537

; 183  : 		{
; 184  : 			SERVICE_STATUS ss;
; 185  : 			ControlService(hService, SERVICE_CONTROL_STOP, &ss);

  00044	8d 44 24 08	 lea	 eax, DWORD PTR _ss$99538[esp+36]
  00048	50		 push	 eax
  00049	6a 01		 push	 1
  0004b	56		 push	 esi
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ControlService@12

; 186  : 			DeleteService(hService);

  00052	56		 push	 esi
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteService@4

; 187  : 			CloseServiceHandle(hService);

  00059	56		 push	 esi
  0005a	ff d7		 call	 edi
$L99537:

; 188  : 		}
; 189  : 		CloseServiceHandle(hService);

  0005c	56		 push	 esi
  0005d	ff d7		 call	 edi
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
$L99534:

; 190  : 	}
; 191  : #ifndef _DEBUG
; 192  : 	VM_END

  00061	eb		 DB	 -21			; ffffffebH
  00062	10		 DB	 16			; 00000010H
  00063	57		 DB	 87			; 00000057H
  00064	4c		 DB	 76			; 0000004cH
  00065	20		 DB	 32			; 00000020H
  00066	20		 DB	 32			; 00000020H
  00067	0d		 DB	 13			; 0000000dH
  00068	00		 DB	 0
  00069	00		 DB	 0
  0006a	00		 DB	 0
  0006b	00		 DB	 0
  0006c	00		 DB	 0
  0006d	00		 DB	 0
  0006e	00		 DB	 0
  0006f	57		 DB	 87			; 00000057H
  00070	4c		 DB	 76			; 0000004cH
  00071	20		 DB	 32			; 00000020H
  00072	20		 DB	 32			; 00000020H

; 193  : #endif
; 194  : 	return TRUE;

  00073	33 c0		 xor	 eax, eax
  00075	40		 inc	 eax

; 195  : }

  00076	83 c4 1c	 add	 esp, 28			; 0000001cH
  00079	c3		 ret	 0
?UnLoadDriver@Defender@@QAEHXZ ENDP			; Defender::UnLoadDriver
_TEXT	ENDS
PUBLIC	?getCheck@Defender@@QAEKXZ			; Defender::getCheck
; Function compile flags: /Ogsy
;	COMDAT ?getCheck@Defender@@QAEKXZ
_TEXT	SEGMENT
_pid$ = -8						; size = 4
_retnum$ = -4						; size = 4
?getCheck@Defender@@QAEKXZ PROC NEAR			; Defender::getCheck, COMDAT
; _this$ = ecx

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 199  : #ifndef _DEBUG
; 200  : 	VM_START_WITHLEVEL(20)

  00005	eb		 DB	 -21			; ffffffebH
  00006	10		 DB	 16			; 00000010H
  00007	57		 DB	 87			; 00000057H
  00008	4c		 DB	 76			; 0000004cH
  00009	20		 DB	 32			; 00000020H
  0000a	20		 DB	 32			; 00000020H
  0000b	0c		 DB	 12			; 0000000cH
  0000c	00		 DB	 0
  0000d	00		 DB	 0
  0000e	00		 DB	 0
  0000f	00		 DB	 0
  00010	14		 DB	 20			; 00000014H
  00011	00		 DB	 0
  00012	00		 DB	 0
  00013	57		 DB	 87			; 00000057H
  00014	4c		 DB	 76			; 0000004cH
  00015	20		 DB	 32			; 00000020H
  00016	20		 DB	 32			; 00000020H

; 201  : #endif
; 202  : 	if(m_hDriver == INVALID_HANDLE_VALUE)

  00017	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001a	83 f8 ff	 cmp	 eax, -1

; 203  : 		return 0;

  0001d	74 21		 je	 SHORT $L100234

; 204  : 	DWORD pid, retnum;
; 205  : 	int ret = DeviceIoControl(m_hDriver, GM_CHECK, NULL, 0, &pid, sizeof(DWORD), &retnum, NULL);

  0001f	33 c9		 xor	 ecx, ecx
  00021	51		 push	 ecx
  00022	8d 55 fc	 lea	 edx, DWORD PTR _retnum$[ebp]
  00025	52		 push	 edx
  00026	6a 04		 push	 4
  00028	8d 55 f8	 lea	 edx, DWORD PTR _pid$[ebp]
  0002b	52		 push	 edx
  0002c	51		 push	 ecx
  0002d	51		 push	 ecx
  0002e	68 6f c8 30 21	 push	 556845167		; 2130c86fH
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 206  : 	if(retnum != sizeof(DWORD))

  0003a	83 7d fc 04	 cmp	 DWORD PTR _retnum$[ebp], 4
  0003e	74 04		 je	 SHORT $L99550
$L100234:

; 207  : 		return 0;

  00040	33 c0		 xor	 eax, eax

; 212  : }

  00042	c9		 leave
  00043	c3		 ret	 0
$L99550:

; 208  : #ifndef _DEBUG
; 209  : 	VM_END

  00044	eb		 DB	 -21			; ffffffebH
  00045	10		 DB	 16			; 00000010H
  00046	57		 DB	 87			; 00000057H
  00047	4c		 DB	 76			; 0000004cH
  00048	20		 DB	 32			; 00000020H
  00049	20		 DB	 32			; 00000020H
  0004a	0d		 DB	 13			; 0000000dH
  0004b	00		 DB	 0
  0004c	00		 DB	 0
  0004d	00		 DB	 0
  0004e	00		 DB	 0
  0004f	00		 DB	 0
  00050	00		 DB	 0
  00051	00		 DB	 0
  00052	57		 DB	 87			; 00000057H
  00053	4c		 DB	 76			; 0000004cH
  00054	20		 DB	 32			; 00000020H
  00055	20		 DB	 32			; 00000020H

; 210  : #endif
; 211  : 	return pid;

  00056	8b 45 f8	 mov	 eax, DWORD PTR _pid$[ebp]

; 212  : }

  00059	c9		 leave
  0005a	c3		 ret	 0
?getCheck@Defender@@QAEKXZ ENDP				; Defender::getCheck
_TEXT	ENDS
PUBLIC	?openVVProtect@Defender@@QAEPAXXZ		; Defender::openVVProtect
PUBLIC	??_C@_06DIBEOEIP@?2?2?4?2?$CFs?$AA@		; `string'
EXTRN	__imp__CreateFileA@28:NEAR
EXTRN	_sprintf:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
;	COMDAT ??_C@_06DIBEOEIP@?2?2?4?2?$CFs?$AA@
CONST	SEGMENT
??_C@_06DIBEOEIP@?2?2?4?2?$CFs?$AA@ DB '\\.\%s', 00H	; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?openVVProtect@Defender@@QAEPAXXZ
_TEXT	SEGMENT
_openname$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?openVVProtect@Defender@@QAEPAXXZ PROC NEAR		; Defender::openVVProtect, COMDAT
; _this$ = ecx

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 216  : 	HANDLE hDriver = INVALID_HANDLE_VALUE;
; 217  : 	char openname[MAX_PATH];
; 218  : 	sprintf(openname, "\\\\.\\%s", EXE_DRIVER_NAME);

  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09HPCMFOIE@VVProtect?$AA@
  00016	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _openname$[ebp]
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06DIBEOEIP@?2?2?4?2?$CFs?$AA@
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _sprintf
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 219  : 	hDriver = CreateFileA(openname, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

  0002a	33 c0		 xor	 eax, eax
  0002c	50		 push	 eax
  0002d	50		 push	 eax
  0002e	6a 03		 push	 3
  00030	50		 push	 eax
  00031	50		 push	 eax
  00032	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00037	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _openname$[ebp]
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28

; 220  : 	return hDriver;
; 221  : }

  00044	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	c9		 leave
  0004d	c3		 ret	 0
?openVVProtect@Defender@@QAEPAXXZ ENDP			; Defender::openVVProtect
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogsy
;	COMDAT ??_GDefender@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GDefender@@UAEPAXI@Z PROC NEAR			; Defender::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1Defender@@UAE@XZ	; Defender::~Defender
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 07		 je	 SHORT $L99470
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	59		 pop	 ecx
$L99470:
  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	c2 04 00	 ret	 4
??_GDefender@@UAEPAXI@Z ENDP				; Defender::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?init@Defender@@QAEHXZ				; Defender::init
PUBLIC	??_C@_0BB@EBHMODHD@?2DKLDefender?4exe?$AA@	; `string'
PUBLIC	??_C@_0BC@KCIFKPFK@?$DM?$DM?$DMDKLDefender?$DO?$DO?$DO?$AA@ ; `string'
EXTRN	__imp__CloseHandle@4:NEAR
EXTRN	__imp__GetCurrentDirectoryA@8:NEAR
EXTRN	__imp__CreateEventA@16:NEAR
EXTRN	__imp__CreateThread@24:NEAR
EXTRN	__imp__GetLastError@0:NEAR
EXTRN	__imp__CreateProcessA@40:NEAR
EXTRN	__imp__WaitForMultipleObjects@16:NEAR
EXTRN	_memset:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_strcat:NEAR
;	COMDAT ??_C@_0BB@EBHMODHD@?2DKLDefender?4exe?$AA@
CONST	SEGMENT
??_C@_0BB@EBHMODHD@?2DKLDefender?4exe?$AA@ DB '\DKLDefender.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KCIFKPFK@?$DM?$DM?$DMDKLDefender?$DO?$DO?$DO?$AA@
CONST	SEGMENT
??_C@_0BC@KCIFKPFK@?$DM?$DM?$DMDKLDefender?$DO?$DO?$DO?$AA@ DB '<<<DKLDef'
	DB	'ender>>>', 00H				; `string'
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT ?init@Defender@@QAEHXZ
_TEXT	SEGMENT
_si$99496 = -128					; size = 68
_ThreadId$99498 = -60					; size = 4
_pi$99497 = -56						; size = 16
_hWaitHandle$99499 = -40				; size = 8
_sa$ = -32						; size = 12
_hEvent$ = -20						; size = 4
_filename$ = -16					; size = 260
_filepath$ = 244					; size = 260
__$ArrayPad$ = 504					; size = 4
__$ReturnAddr$ = 512					; size = 4
?init@Defender@@QAEHXZ PROC NEAR			; Defender::init, COMDAT
; _this$ = ecx

; 59   : {

  00000	55		 push	 ebp
  00001	8d ac 24 04 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-508]
  00008	81 ec 7c 02 00
	00		 sub	 esp, 636		; 0000027cH
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	56		 push	 esi
  00014	89 85 f8 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001a	57		 push	 edi
  0001b	8b f1		 mov	 esi, ecx

; 60   : #ifndef _DEBUG
; 61   : 	VM_START_WITHLEVEL(20)

  0001d	eb		 DB	 -21			; ffffffebH
  0001e	10		 DB	 16			; 00000010H
  0001f	57		 DB	 87			; 00000057H
  00020	4c		 DB	 76			; 0000004cH
  00021	20		 DB	 32			; 00000020H
  00022	20		 DB	 32			; 00000020H
  00023	0c		 DB	 12			; 0000000cH
  00024	00		 DB	 0
  00025	00		 DB	 0
  00026	00		 DB	 0
  00027	00		 DB	 0
  00028	14		 DB	 20			; 00000014H
  00029	00		 DB	 0
  0002a	00		 DB	 0
  0002b	57		 DB	 87			; 00000057H
  0002c	4c		 DB	 76			; 0000004cH
  0002d	20		 DB	 32			; 00000020H
  0002e	20		 DB	 32			; 00000020H

; 62   : #endif
; 63   : 	char filename[MAX_PATH], filepath[MAX_PATH];
; 64   : 	::GetCurrentDirectory(MAX_PATH, filepath);

  0002f	8d 85 f4 00 00
	00		 lea	 eax, DWORD PTR _filepath$[ebp]
  00035	50		 push	 eax
  00036	68 04 01 00 00	 push	 260			; 00000104H
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentDirectoryA@8

; 65   : 	strcpy(filename, filepath);

  00041	8d 85 f4 00 00
	00		 lea	 eax, DWORD PTR _filepath$[ebp]
  00047	50		 push	 eax
  00048	8d 45 f0	 lea	 eax, DWORD PTR _filename$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _strcpy

; 66   : 	strcat(filename, "\\DKLDefender.exe");

  00051	8d 45 f0	 lea	 eax, DWORD PTR _filename$[ebp]
  00054	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@EBHMODHD@?2DKLDefender?4exe?$AA@
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _strcat
  0005f	83 c4 10	 add	 esp, 16			; 00000010H

; 67   : 
; 68   : 	SECURITY_ATTRIBUTES sa;
; 69   : 	sa.nLength = sizeof(sa);
; 70   :     sa.lpSecurityDescriptor = NULL;
; 71   :     sa.bInheritHandle = FALSE;
; 72   : 	HANDLE hEvent = ::CreateEvent(&sa, TRUE, FALSE, "<<<DKLDefender>>>");

  00062	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@KCIFKPFK@?$DM?$DM?$DMDKLDefender?$DO?$DO?$DO?$AA@
  00067	33 ff		 xor	 edi, edi
  00069	57		 push	 edi
  0006a	6a 01		 push	 1
  0006c	8d 45 e0	 lea	 eax, DWORD PTR _sa$[ebp]
  0006f	50		 push	 eax
  00070	c7 45 e0 0c 00
	00 00		 mov	 DWORD PTR _sa$[ebp], 12	; 0000000cH
  00077	89 7d e4	 mov	 DWORD PTR _sa$[ebp+4], edi
  0007a	89 7d e8	 mov	 DWORD PTR _sa$[ebp+8], edi
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventA@16
  00083	89 45 ec	 mov	 DWORD PTR _hEvent$[ebp], eax

; 73   : 	if(GetLastError() != ERROR_ALREADY_EXISTS)

  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0008c	3d b7 00 00 00	 cmp	 eax, 183		; 000000b7H
  00091	0f 84 a2 00 00
	00		 je	 $L100247

; 74   : 	{
; 75   : 		STARTUPINFO si;
; 76   : 		PROCESS_INFORMATION pi;
; 77   : 		ZeroMemory(&pi, sizeof(pi));

  00097	6a 10		 push	 16			; 00000010H
  00099	8d 45 c8	 lea	 eax, DWORD PTR _pi$99497[ebp]
  0009c	57		 push	 edi
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _memset

; 78   : 		ZeroMemory(&si, sizeof(si));

  000a3	6a 44		 push	 68			; 00000044H
  000a5	8d 45 80	 lea	 eax, DWORD PTR _si$99496[ebp]
  000a8	57		 push	 edi
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memset
  000af	83 c4 18	 add	 esp, 24			; 00000018H

; 79   : 		si.cb = sizeof(si);
; 80   : 		CreateProcess(NULL, filename, NULL, NULL, NULL, NULL, NULL, filepath, &si, &pi);

  000b2	8d 45 c8	 lea	 eax, DWORD PTR _pi$99497[ebp]
  000b5	50		 push	 eax
  000b6	8d 45 80	 lea	 eax, DWORD PTR _si$99496[ebp]
  000b9	50		 push	 eax
  000ba	8d 85 f4 00 00
	00		 lea	 eax, DWORD PTR _filepath$[ebp]
  000c0	50		 push	 eax
  000c1	57		 push	 edi
  000c2	57		 push	 edi
  000c3	57		 push	 edi
  000c4	57		 push	 edi
  000c5	57		 push	 edi
  000c6	8d 45 f0	 lea	 eax, DWORD PTR _filename$[ebp]
  000c9	50		 push	 eax
  000ca	57		 push	 edi
  000cb	c7 45 80 44 00
	00 00		 mov	 DWORD PTR _si$99496[ebp], 68 ; 00000044H
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateProcessA@40

; 81   : 		m_pid = pi.dwProcessId;

  000d8	8b 45 d0	 mov	 eax, DWORD PTR _pi$99497[ebp+8]
  000db	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 82   : 		m_hProcess = pi.hProcess;

  000de	8b 45 c8	 mov	 eax, DWORD PTR _pi$99497[ebp]
  000e1	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 83   : 		DWORD ThreadId;
; 84   : 		HANDLE hWaitHandle[2];
; 85   : 		hWaitHandle[0] = ::CreateThread(NULL, 0, CheckChildProcess, this, 0, &ThreadId);

  000e4	8d 45 c4	 lea	 eax, DWORD PTR _ThreadId$99498[ebp]
  000e7	50		 push	 eax
  000e8	57		 push	 edi
  000e9	56		 push	 esi
  000ea	68 00 00 00 00	 push	 OFFSET FLAT:?CheckChildProcess@@YGKPAX@Z ; CheckChildProcess
  000ef	57		 push	 edi
  000f0	57		 push	 edi
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24

; 86   : 		hWaitHandle[1] = hEvent;
; 87   : 		if(m_pid == 0 || m_hProcess == INVALID_HANDLE_VALUE)

  000f7	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  000fa	89 45 d8	 mov	 DWORD PTR _hWaitHandle$99499[ebp], eax
  000fd	8b 45 ec	 mov	 eax, DWORD PTR _hEvent$[ebp]
  00100	89 45 dc	 mov	 DWORD PTR _hWaitHandle$99499[ebp+4], eax
  00103	74 31		 je	 SHORT $L99503
  00105	83 7e 08 ff	 cmp	 DWORD PTR [esi+8], -1
  00109	74 2b		 je	 SHORT $L99503

; 91   : 		}
; 92   : 		
; 93   : 		//::WaitForSingleObject(hEvent, INFINITE);
; 94   : 		::WaitForMultipleObjects(2, hWaitHandle, FALSE, INFINITE);

  0010b	6a ff		 push	 -1
  0010d	57		 push	 edi
  0010e	8d 45 d8	 lea	 eax, DWORD PTR _hWaitHandle$99499[ebp]
  00111	50		 push	 eax
  00112	6a 02		 push	 2
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForMultipleObjects@16

; 95   : 		
; 96   : 		//char openname[MAX_PATH];
; 97   : 		//sprintf(openname, "\\\\.\\%s", EXE_DRIVER_NAME);
; 98   : 		//m_hDriver = CreateFileA(openname, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
; 99   : 		
; 100  : 		m_hDriver = openVVProtect();

  0011a	8b ce		 mov	 ecx, esi
  0011c	e8 00 00 00 00	 call	 ?openVVProtect@Defender@@QAEPAXXZ ; Defender::openVVProtect

; 101  : 		if(m_hDriver == INVALID_HANDLE_VALUE)

  00121	83 f8 ff	 cmp	 eax, -1
  00124	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00127	75 10		 jne	 SHORT $L100247

; 102  : 		{
; 103  : 			::CloseHandle(hEvent);

  00129	ff 75 ec	 push	 DWORD PTR _hEvent$[ebp]
$L100249:
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 104  : 			return FALSE;

  00132	33 c0		 xor	 eax, eax
  00134	eb 21		 jmp	 SHORT $L99488
$L99503:

; 88   : 		{
; 89   : 			::CloseHandle(hEvent);

  00136	50		 push	 eax

; 90   : 			return FALSE;

  00137	eb f3		 jmp	 SHORT $L100249
$L100247:

; 105  : 		}
; 106  : 	}
; 107  : 
; 108  : 	::CloseHandle(hEvent);

  00139	ff 75 ec	 push	 DWORD PTR _hEvent$[ebp]
  0013c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 109  : // 	else
; 110  : // 	{
; 111  : // 		HWND hWnd = ::FindWindow(NULL, "DKLegend Helper");
; 112  : // 		if(hWnd != NULL)
; 113  : // 		{
; 114  : // 			DWORD ProcessId=0;
; 115  : // 			::GetWindowThreadProcessId(hWnd, &ProcessId);
; 116  : // 			m_hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId);
; 117  : // 			if(m_hProcess != INVALID_HANDLE_VALUE)
; 118  : // 			{
; 119  : // 				DWORD ThreadId;
; 120  : // 				::CreateThread(NULL, 0, CheckChildProcess, this, 0, &ThreadId);
; 121  : // 			}
; 122  : // 			m_hDriver = openVVProtect();
; 123  : // 			if(m_hDriver == INVALID_HANDLE_VALUE) return FALSE;
; 124  : // 			::SendMessage(hWnd, 0, ::GetCurrentProcessId(), 0);
; 125  : // 		}
; 126  : // 		else
; 127  : // 			return FALSE;
; 128  : // 	}
; 129  : 
; 130  : #ifndef _DEBUG
; 131  : 	VM_END

  00142	eb		 DB	 -21			; ffffffebH
  00143	10		 DB	 16			; 00000010H
  00144	57		 DB	 87			; 00000057H
  00145	4c		 DB	 76			; 0000004cH
  00146	20		 DB	 32			; 00000020H
  00147	20		 DB	 32			; 00000020H
  00148	0d		 DB	 13			; 0000000dH
  00149	00		 DB	 0
  0014a	00		 DB	 0
  0014b	00		 DB	 0
  0014c	00		 DB	 0
  0014d	00		 DB	 0
  0014e	00		 DB	 0
  0014f	00		 DB	 0
  00150	57		 DB	 87			; 00000057H
  00151	4c		 DB	 76			; 0000004cH
  00152	20		 DB	 32			; 00000020H
  00153	20		 DB	 32			; 00000020H

; 132  : #endif
; 133  : 	return TRUE;

  00154	33 c0		 xor	 eax, eax
  00156	40		 inc	 eax
$L99488:

; 134  : }

  00157	8b 8d f8 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015d	5f		 pop	 edi
  0015e	5e		 pop	 esi
  0015f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00164	81 c5 fc 01 00
	00		 add	 ebp, 508		; 000001fcH
  0016a	c9		 leave
  0016b	c3		 ret	 0
?init@Defender@@QAEHXZ ENDP				; Defender::init
_TEXT	ENDS
END
