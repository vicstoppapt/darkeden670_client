; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\MGameTime.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??0MGameTime@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MGameTime@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStartTime@MGameTime@@QAEXKGEEEEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCurrentTime@MGameTime@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pGameTime@@3PAVMGameTime@@A			; g_pGameTime
_BSS	SEGMENT
?g_pGameTime@@3PAVMGameTime@@A DD 01H DUP (?)		; g_pGameTime
_BSS	ENDS
PUBLIC	??0MGameTime@@QAE@XZ				; MGameTime::MGameTime
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mgametime.cpp
;	COMDAT ??0MGameTime@@QAE@XZ
_TEXT	SEGMENT
??0MGameTime@@QAE@XZ PROC NEAR				; MGameTime::MGameTime, COMDAT
; _this$ = ecx

; 20   : {

  00000	8b c1		 mov	 eax, ecx

; 21   : 	m_StartYear		= 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	66 89 08	 mov	 WORD PTR [eax], cx

; 22   : 	m_StartMonth	= 0;

  00007	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 23   : 	m_StartDay		= 0;

  0000a	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 24   : 
; 25   : 	m_StartHour		= 0;

  0000d	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 26   : 	m_StartMinute	= 0;

  00010	88 48 05	 mov	 BYTE PTR [eax+5], cl

; 27   : 	m_StartSecond	= 0;

  00013	88 48 06	 mov	 BYTE PTR [eax+6], cl

; 28   : 
; 29   : 	// timeGetTime
; 30   : 	m_StartTime		= 0;

  00016	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 31   : 
; 32   : 	// 시간 비율
; 33   : 	m_TimeRatio		= 1;

  00019	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1

; 34   : 
; 35   : 	// 현재 시간
; 36   : 	m_Year			= 0;

  00020	66 89 48 10	 mov	 WORD PTR [eax+16], cx

; 37   : 	m_Month			= 0;

  00024	88 48 12	 mov	 BYTE PTR [eax+18], cl

; 38   : 	m_Day			= 0;

  00027	88 48 13	 mov	 BYTE PTR [eax+19], cl

; 39   : 
; 40   : 	m_Hour			= 0;

  0002a	88 48 14	 mov	 BYTE PTR [eax+20], cl

; 41   : 	m_Minute		= 0;

  0002d	88 48 15	 mov	 BYTE PTR [eax+21], cl

; 42   : 	m_Second		= 0;

  00030	88 48 16	 mov	 BYTE PTR [eax+22], cl

; 43   : }

  00033	c3		 ret	 0
??0MGameTime@@QAE@XZ ENDP				; MGameTime::MGameTime
_TEXT	ENDS
PUBLIC	??1MGameTime@@QAE@XZ				; MGameTime::~MGameTime
; Function compile flags: /Ogsy
;	COMDAT ??1MGameTime@@QAE@XZ
_TEXT	SEGMENT
??1MGameTime@@QAE@XZ PROC NEAR				; MGameTime::~MGameTime, COMDAT
; _this$ = ecx

; 47   : }

  00000	c3		 ret	 0
??1MGameTime@@QAE@XZ ENDP				; MGameTime::~MGameTime
_TEXT	ENDS
PUBLIC	?SetStartTime@MGameTime@@QAEXKGEEEEE@Z		; MGameTime::SetStartTime
; Function compile flags: /Ogsy
;	COMDAT ?SetStartTime@MGameTime@@QAEXKGEEEEE@Z
_TEXT	SEGMENT
_time$ = 8						; size = 4
_year$ = 12						; size = 2
_month$ = 16						; size = 1
_day$ = 20						; size = 1
_hour$ = 24						; size = 1
_minute$ = 28						; size = 1
_second$ = 32						; size = 1
?SetStartTime@MGameTime@@QAEXKGEEEEE@Z PROC NEAR	; MGameTime::SetStartTime, COMDAT
; _this$ = ecx

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 62   : 	// timeGetTime
; 63   : 	m_StartTime		= time;

  00003	8b 45 08	 mov	 eax, DWORD PTR _time$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 64   : 
; 65   : 	m_StartYear		= year;

  00009	66 8b 45 0c	 mov	 ax, WORD PTR _year$[ebp]
  0000d	66 89 01	 mov	 WORD PTR [ecx], ax

; 66   : 	m_StartMonth	= month;

  00010	8a 45 10	 mov	 al, BYTE PTR _month$[ebp]
  00013	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 67   : 	m_StartDay		= day;

  00016	8a 45 14	 mov	 al, BYTE PTR _day$[ebp]
  00019	88 41 03	 mov	 BYTE PTR [ecx+3], al

; 68   : 
; 69   : 	m_StartHour		= hour;

  0001c	8a 45 18	 mov	 al, BYTE PTR _hour$[ebp]
  0001f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 70   : 	m_StartMinute	= minute;

  00022	8a 45 1c	 mov	 al, BYTE PTR _minute$[ebp]
  00025	88 41 05	 mov	 BYTE PTR [ecx+5], al

; 71   : 	m_StartSecond	= second;	

  00028	8a 45 20	 mov	 al, BYTE PTR _second$[ebp]
  0002b	88 41 06	 mov	 BYTE PTR [ecx+6], al

; 72   : }

  0002e	5d		 pop	 ebp
  0002f	c2 1c 00	 ret	 28			; 0000001cH
?SetStartTime@MGameTime@@QAEXKGEEEEE@Z ENDP		; MGameTime::SetStartTime
_TEXT	ENDS
PUBLIC	?SetCurrentTime@MGameTime@@QAEXK@Z		; MGameTime::SetCurrentTime
EXTRN	?g_CurrentTime@@3KA:DWORD			; g_CurrentTime
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?SetCurrentTime@MGameTime@@QAEXK@Z
_TEXT	SEGMENT
_m$ = -36						; size = 4
tv357 = -32						; size = 4
_d$ = -28						; size = 4
_h$ = -24						; size = 4
_DaysPerMonth$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_days$ = 8						; size = 4
_time$ = 8						; size = 4
?SetCurrentTime@MGameTime@@QAEXK@Z PROC NEAR		; MGameTime::SetCurrentTime, COMDAT
; _this$ = ecx

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 82   : 	//------------------------------------------------------------
; 83   : 	// 초(second)로 환산한 값
; 84   : 	//------------------------------------------------------------
; 85   : 	const DWORD Day	= 24*60*60;
; 86   : 	const DWORD Hour	= 60*60;
; 87   : 	const DWORD Min	= 60;
; 88   : 	
; 89   : 	//------------------------------------------------------------
; 90   : 	// 31일인 달인가?
; 91   : 	//------------------------------------------------------------
; 92   : 	const BYTE DaysPerMonth[13] = 
; 93   : 	{
; 94   : 		0, 31, 28, 31, 30, 31, 30, 
; 95   : 		31, 31, 30, 31, 30, 31
; 96   : 	};
; 97   : 
; 98   : 
; 99   : 	//------------------------------------------------------------
; 100  : 	// 기준시간과 현재시간의 차이 
; 101  : 	//------------------------------------------------------------
; 102  : 	// 1000 = 1초, 시간비율 고려..
; 103  : 	//------------------------------------------------------------
; 104  : 	DWORD gap = (time - m_StartTime) / 1000 * m_TimeRatio;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _time$[ebp]
  00011	2b 41 08	 sub	 eax, DWORD PTR [ecx+8]
  00014	53		 push	 ebx
  00015	33 d2		 xor	 edx, edx
  00017	56		 push	 esi
  00018	be e8 03 00 00	 mov	 esi, 1000		; 000003e8H
  0001d	f7 f6		 div	 esi

; 105  : 
; 106  : 	int rem = gap;
; 107  : 
; 108  : 	// 기준시간 더해줌..
; 109  : 	rem += m_StartSecond + m_StartMinute*Min + m_StartHour*Hour;

  0001f	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]

; 110  : 
; 111  : 	//------------------------------------------------------------
; 112  : 	// 변화값	
; 113  : 	//------------------------------------------------------------
; 114  : 	int	d = rem/Day;			rem -= d*Day;	

  00023	be 80 51 01 00	 mov	 esi, 86400		; 00015180H

; 115  : 	int	h = rem/Hour;			rem -= h*Hour;	
; 116  : 	int	m = rem/Min;			rem -= m*Min;

  00028	6a 3c		 push	 60			; 0000003cH
  0002a	c6 45 ec 00	 mov	 BYTE PTR _DaysPerMonth$[ebp], 0
  0002e	c6 45 ed 1f	 mov	 BYTE PTR _DaysPerMonth$[ebp+1], 31 ; 0000001fH
  00032	c6 45 ee 1c	 mov	 BYTE PTR _DaysPerMonth$[ebp+2], 28 ; 0000001cH
  00036	c6 45 ef 1f	 mov	 BYTE PTR _DaysPerMonth$[ebp+3], 31 ; 0000001fH
  0003a	c6 45 f0 1e	 mov	 BYTE PTR _DaysPerMonth$[ebp+4], 30 ; 0000001eH
  0003e	c6 45 f1 1f	 mov	 BYTE PTR _DaysPerMonth$[ebp+5], 31 ; 0000001fH
  00042	c6 45 f2 1e	 mov	 BYTE PTR _DaysPerMonth$[ebp+6], 30 ; 0000001eH
  00046	c6 45 f3 1f	 mov	 BYTE PTR _DaysPerMonth$[ebp+7], 31 ; 0000001fH
  0004a	c6 45 f4 1f	 mov	 BYTE PTR _DaysPerMonth$[ebp+8], 31 ; 0000001fH
  0004e	c6 45 f5 1e	 mov	 BYTE PTR _DaysPerMonth$[ebp+9], 30 ; 0000001eH
  00052	c6 45 f6 1f	 mov	 BYTE PTR _DaysPerMonth$[ebp+10], 31 ; 0000001fH
  00056	c6 45 f7 1e	 mov	 BYTE PTR _DaysPerMonth$[ebp+11], 30 ; 0000001eH
  0005a	c6 45 f8 1f	 mov	 BYTE PTR _DaysPerMonth$[ebp+12], 31 ; 0000001fH
  0005e	8b d8		 mov	 ebx, eax
  00060	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00064	0f af 59 0c	 imul	 ebx, DWORD PTR [ecx+12]
  00068	6b c0 3c	 imul	 eax, 60			; 0000003cH
  0006b	03 c2		 add	 eax, edx
  0006d	6b c0 3c	 imul	 eax, 60			; 0000003cH

; 163  : 	{
; 164  : 		m_Month = m_StartMonth;
; 165  : 		m_Year	= m_StartYear;

  00070	03 d8		 add	 ebx, eax
  00072	0f b6 41 06	 movzx	 eax, BYTE PTR [ecx+6]
  00076	03 d8		 add	 ebx, eax
  00078	33 d2		 xor	 edx, edx
  0007a	8b c3		 mov	 eax, ebx
  0007c	f7 f6		 div	 esi
  0007e	33 d2		 xor	 edx, edx
  00080	be 10 0e 00 00	 mov	 esi, 3600		; 00000e10H
  00085	89 45 e4	 mov	 DWORD PTR _d$[ebp], eax
  00088	69 c0 80 ae fe
	ff		 imul	 eax, -86400		; fffeae80H
  0008e	03 d8		 add	 ebx, eax
  00090	8b c3		 mov	 eax, ebx
  00092	f7 f6		 div	 esi
  00094	33 d2		 xor	 edx, edx
  00096	5e		 pop	 esi
  00097	89 45 e8	 mov	 DWORD PTR _h$[ebp], eax
  0009a	69 c0 f0 f1 ff
	ff		 imul	 eax, -3600		; fffff1f0H
  000a0	03 d8		 add	 ebx, eax
  000a2	8b c3		 mov	 eax, ebx
  000a4	f7 f6		 div	 esi
  000a6	8a 55 e8	 mov	 dl, BYTE PTR _h$[ebp]
  000a9	88 51 14	 mov	 BYTE PTR [ecx+20], dl
  000ac	b2 3c		 mov	 dl, 60			; 0000003cH
  000ae	89 45 dc	 mov	 DWORD PTR _m$[ebp], eax
  000b1	88 41 15	 mov	 BYTE PTR [ecx+21], al
  000b4	f6 ea		 imul	 dl
  000b6	2a d8		 sub	 bl, al
  000b8	88 5d e0	 mov	 BYTE PTR tv357[ebp], bl
  000bb	88 59 16	 mov	 BYTE PTR [ecx+22], bl
  000be	8a 59 02	 mov	 bl, BYTE PTR [ecx+2]
  000c1	80 fb 02	 cmp	 bl, 2
  000c4	0f b6 c3	 movzx	 eax, bl
  000c7	0f b6 44 05 ec	 movzx	 eax, BYTE PTR _DaysPerMonth$[ebp+eax]
  000cc	89 45 08	 mov	 DWORD PTR _days$[ebp], eax
  000cf	75 26		 jne	 SHORT $L99474
  000d1	66 8b 01	 mov	 ax, WORD PTR [ecx]
  000d4	a8 03		 test	 al, 3
  000d6	75 0d		 jne	 SHORT $L99476
  000d8	0f b7 c0	 movzx	 eax, ax
  000db	6a 64		 push	 100			; 00000064H
  000dd	99		 cdq
  000de	5e		 pop	 esi
  000df	f7 fe		 idiv	 esi
  000e1	85 d2		 test	 edx, edx
  000e3	75 0f		 jne	 SHORT $L99475
$L99476:

; 117  : 	int	s = rem;
; 118  : 
; 119  : 	m_Hour		= h;
; 120  : 	m_Minute	= m;
; 121  : 	m_Second	= s;
; 122  : 
; 123  : 	// 이 달의 날 수?
; 124  : 	int days = DaysPerMonth[m_StartMonth];
; 125  : 
; 126  : 	// 2월
; 127  : 	if (m_StartMonth==2)
; 128  : 	{	
; 129  : 		// 100의 배수가 아니면서 4의 배수인 해, 400의 배수인 해.. 맞나?? - -;
; 130  : 		if ((m_StartYear&0x03)==0 && m_StartYear%100!=0 || m_StartYear%400==0)

  000e5	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  000e8	99		 cdq
  000e9	be 90 01 00 00	 mov	 esi, 400		; 00000190H
  000ee	f7 fe		 idiv	 esi
  000f0	85 d2		 test	 edx, edx
  000f2	75 03		 jne	 SHORT $L99474
$L99475:

; 131  : 		{
; 132  : 			days ++;

  000f4	ff 45 08	 inc	 DWORD PTR _days$[ebp]
$L99474:

; 133  : 		}
; 134  : 	}
; 135  : 	
; 136  : 	// 날
; 137  : 	m_Day = m_StartDay + d;
; 138  : 
; 139  : 	// 한달이 넘어간 경우
; 140  : 	if (m_StartDay+d > days)

  000f7	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  000fb	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  000fe	02 45 e4	 add	 al, BYTE PTR _d$[ebp]
  00101	03 55 e4	 add	 edx, DWORD PTR _d$[ebp]
  00104	88 41 13	 mov	 BYTE PTR [ecx+19], al
  00107	3b 55 08	 cmp	 edx, DWORD PTR _days$[ebp]
  0010a	7e 45		 jle	 SHORT $L99477

; 141  : 	{
; 142  : 		// 다음달 날짜로 계산..
; 143  : 		m_Day -= days;

  0010c	2a 45 08	 sub	 al, BYTE PTR _days$[ebp]

; 144  : 
; 145  : 		// 기준달 + 1
; 146  : 		m_Month = m_StartMonth + 1;

  0010f	fe c3		 inc	 bl

; 147  : 
; 148  : 		if (m_Month==13)

  00111	80 fb 0d	 cmp	 bl, 13			; 0000000dH
  00114	88 41 13	 mov	 BYTE PTR [ecx+19], al
  00117	88 59 12	 mov	 BYTE PTR [ecx+18], bl
  0011a	75 0a		 jne	 SHORT $L99478

; 149  : 		{
; 150  : 			m_Year ++;

  0011c	66 ff 41 10	 inc	 WORD PTR [ecx+16]

; 151  : 			m_Month = 1;

  00120	c6 41 12 01	 mov	 BYTE PTR [ecx+18], 1

; 152  : 		}
; 153  : 		else

  00124	eb 07		 jmp	 SHORT $L99479
$L99478:

; 154  : 		{
; 155  : 			// 1년이 넘어간 경우, 기준년 + 1
; 156  : 			m_Year = m_StartYear;

  00126	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00129	66 89 51 10	 mov	 WORD PTR [ecx+16], dx
$L99479:

; 157  : 		}
; 158  : 
; 159  : 		// 날짜 다시 설정
; 160  : 		SetStartTime(g_CurrentTime, m_Year, m_Month, m_Day, m_Hour, m_Minute, m_Second);

  0012d	ff 75 e0	 push	 DWORD PTR tv357[ebp]
  00130	ff 75 dc	 push	 DWORD PTR _m$[ebp]
  00133	ff 75 e8	 push	 DWORD PTR _h$[ebp]
  00136	50		 push	 eax
  00137	33 c0		 xor	 eax, eax
  00139	8a 41 12	 mov	 al, BYTE PTR [ecx+18]
  0013c	50		 push	 eax
  0013d	33 c0		 xor	 eax, eax
  0013f	66 8b 41 10	 mov	 ax, WORD PTR [ecx+16]
  00143	50		 push	 eax
  00144	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_CurrentTime@@3KA ; g_CurrentTime
  0014a	e8 00 00 00 00	 call	 ?SetStartTime@MGameTime@@QAEXKGEEEEE@Z ; MGameTime::SetStartTime

; 161  : 	}
; 162  : 	else

  0014f	eb 0a		 jmp	 SHORT $L99480
$L99477:

; 163  : 	{
; 164  : 		m_Month = m_StartMonth;
; 165  : 		m_Year	= m_StartYear;

  00151	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00154	88 59 12	 mov	 BYTE PTR [ecx+18], bl
  00157	66 89 41 10	 mov	 WORD PTR [ecx+16], ax
$L99480:

; 166  : 	}
; 167  : 
; 168  : }

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015e	5e		 pop	 esi
  0015f	5b		 pop	 ebx
  00160	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00165	c9		 leave
  00166	c2 04 00	 ret	 4
?SetCurrentTime@MGameTime@@QAEXK@Z ENDP			; MGameTime::SetCurrentTime
_TEXT	ENDS
END
