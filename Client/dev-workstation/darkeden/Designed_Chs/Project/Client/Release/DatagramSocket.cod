; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\Packet\DatagramSocket.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0O@JKENFCBN@MinTrace?52003?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MNEJIGLM@__MinTrace?5Window__?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KLPNNMEP@?$CF8d?0?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@PBBGJLAO@?$FLDatagramSocket?$FN?5available?$DN?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@BEPHCLOD@?$FLDatagramSocket?$FN?5received?$DN?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?getData@Datagram@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getLength@Datagram@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getAddress@Datagram@@QAEPAUsockaddr@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_MinTraceA@@YAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_MinTraceErrA@@YAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_MinTraceWarA@@YAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_ClMinTraceA@@YAXKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_CmdMinTraceA@@YAXHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DEBUG_ADD@@YAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DEBUG_ADD_FORMAT@@YAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DatagramSocket@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DatagramSocket@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1DatagramSocket@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?send@DatagramSocket@@QAEIPAVDatagram@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?receive@DatagramSocket@@QAEPAVDatagram@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R0?AVThrowable@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@PBDABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@_STL@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@JKENFCBN@MinTrace?52003?$AA@		; `string'
PUBLIC	??_C@_0BE@MNEJIGLM@__MinTrace?5Window__?$AA@	; `string'
;	COMDAT ??_C@_0O@JKENFCBN@MinTrace?52003?$AA@
CONST	SEGMENT
??_C@_0O@JKENFCBN@MinTrace?52003?$AA@ DB 'MinTrace 2003', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_g_pszMinTraceTitle DD FLAT:??_C@_0O@JKENFCBN@MinTrace?52003?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0BE@MNEJIGLM@__MinTrace?5Window__?$AA@
CONST	SEGMENT
??_C@_0BE@MNEJIGLM@__MinTrace?5Window__?$AA@ DB '__MinTrace Window__', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_g_pszMinTraceClassName DD FLAT:??_C@_0BE@MNEJIGLM@__MinTrace?5Window__?$AA@
_DATA	ENDS
PUBLIC	?getData@Datagram@@QAEPADXZ			; Datagram::getData
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\packet\datagram.h
;	COMDAT ?getData@Datagram@@QAEPADXZ
_TEXT	SEGMENT
?getData@Datagram@@QAEPADXZ PROC NEAR			; Datagram::getData, COMDAT
; _this$ = ecx

; 75   : 	char * getData () throw () { return m_Data; }

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?getData@Datagram@@QAEPADXZ ENDP			; Datagram::getData
_TEXT	ENDS
PUBLIC	?getLength@Datagram@@QBEIXZ			; Datagram::getLength
; Function compile flags: /Ogsy
;	COMDAT ?getLength@Datagram@@QBEIXZ
_TEXT	SEGMENT
?getLength@Datagram@@QBEIXZ PROC NEAR			; Datagram::getLength, COMDAT
; _this$ = ecx

; 82   : 	uint getLength () const throw () { return m_Length; }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
?getLength@Datagram@@QBEIXZ ENDP			; Datagram::getLength
_TEXT	ENDS
PUBLIC	?getAddress@Datagram@@QAEPAUsockaddr@@XZ	; Datagram::getAddress
; Function compile flags: /Ogsy
;	COMDAT ?getAddress@Datagram@@QAEPAUsockaddr@@XZ
_TEXT	SEGMENT
?getAddress@Datagram@@QAEPAUsockaddr@@XZ PROC NEAR	; Datagram::getAddress, COMDAT
; _this$ = ecx

; 85   : 	SOCKADDR * getAddress () throw () { return (SOCKADDR*)&m_SockAddr; }

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00003	c3		 ret	 0
?getAddress@Datagram@@QAEPAUsockaddr@@XZ ENDP		; Datagram::getAddress
_TEXT	ENDS
PUBLIC	?__stl_delete@_STL@@YAXPAX@Z			; _STL::__stl_delete
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_new.h
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT
___p$ = 8						; size = 4
?__stl_delete@_STL@@YAXPAX@Z PROC NEAR			; _STL::__stl_delete, COMDAT

; 87   : inline void   _STLP_CALL __stl_delete(void* __p) { ::operator delete(__p); }

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?__stl_delete@_STL@@YAXPAX@Z ENDP			; _STL::__stl_delete
_TEXT	ENDS
PUBLIC	?_Destroy@_STL@@YAXPAD0@Z			; _STL::_Destroy
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_construct.h
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Destroy@_STL@@YAXPAD0@Z PROC NEAR			; _STL::_Destroy, COMDAT

; 142  : inline void _Destroy(char*, char*) {}

  00000	c3		 ret	 0
?_Destroy@_STL@@YAXPAD0@Z ENDP				; _STL::_Destroy
_TEXT	ENDS
PUBLIC	?DEBUG_ADD@@YAXPBD@Z				; DEBUG_ADD
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\debuginfo.h
;	COMDAT ?DEBUG_ADD@@YAXPBD@Z
_TEXT	SEGMENT
_message$ = 8						; size = 4
?DEBUG_ADD@@YAXPBD@Z PROC NEAR				; DEBUG_ADD, COMDAT

; 80   : 		inline void	DEBUG_ADD( const char* message )		{}

  00000	c3		 ret	 0
?DEBUG_ADD@@YAXPBD@Z ENDP				; DEBUG_ADD
_TEXT	ENDS
PUBLIC	?DEBUG_ADD_FORMAT@@YAXPBDZZ			; DEBUG_ADD_FORMAT
; Function compile flags: /Ogsy
;	COMDAT ?DEBUG_ADD_FORMAT@@YAXPBDZZ
_TEXT	SEGMENT
_format$ = 8						; size = 4
?DEBUG_ADD_FORMAT@@YAXPBDZZ PROC NEAR			; DEBUG_ADD_FORMAT, COMDAT

; 85   : 		inline void	DEBUG_ADD_FORMAT(const char* format, ...) {}

  00000	c3		 ret	 0
?DEBUG_ADD_FORMAT@@YAXPBDZZ ENDP			; DEBUG_ADD_FORMAT
_TEXT	ENDS
PUBLIC	??0DatagramSocket@@QAE@XZ			; DatagramSocket::DatagramSocket
EXTRN	?socket_ex@SocketAPI@@YAIHHH@Z:NEAR		; SocketAPI::socket_ex
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\packet\datagramsocket.cpp
;	COMDAT ??0DatagramSocket@@QAE@XZ
_TEXT	SEGMENT
??0DatagramSocket@@QAE@XZ PROC NEAR			; DatagramSocket::DatagramSocket, COMDAT
; _this$ = ecx

; 29   : {

  00000	56		 push	 esi

; 30   : 	__BEGIN_TRY 
; 31   : 
; 32   : 	__BEGIN_DEBUG
; 33   : 	m_SocketID = SocketAPI::socket_ex( AF_INET , SOCK_DGRAM , 0 );

  00001	6a 00		 push	 0
  00003	8b f1		 mov	 esi, ecx
  00005	83 0e ff	 or	 DWORD PTR [esi], -1
  00008	6a 02		 push	 2
  0000a	6a 02		 push	 2
  0000c	e8 00 00 00 00	 call	 ?socket_ex@SocketAPI@@YAIHHH@Z ; SocketAPI::socket_ex
  00011	89 06		 mov	 DWORD PTR [esi], eax
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 34   : 	__END_DEBUG
; 35   : 
; 36   : 	__END_CATCH
; 37   : }

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	c3		 ret	 0
??0DatagramSocket@@QAE@XZ ENDP				; DatagramSocket::DatagramSocket
_TEXT	ENDS
PUBLIC	??0DatagramSocket@@QAE@I@Z			; DatagramSocket::DatagramSocket
EXTRN	?bind_ex@SocketAPI@@YAXIPBUsockaddr@@I@Z:NEAR	; SocketAPI::bind_ex
EXTRN	?setsockopt_ex@SocketAPI@@YAXIHHPBXI@Z:NEAR	; SocketAPI::setsockopt_ex
EXTRN	_htonl@4:NEAR
EXTRN	_htons@4:NEAR
EXTRN	_inet_ntoa@4:NEAR
EXTRN	_memset:NEAR
; Function compile flags: /Ogsy
;	COMDAT ??0DatagramSocket@@QAE@I@Z
_TEXT	SEGMENT
_opt$ = -4						; size = 4
_port$ = 8						; size = 4
??0DatagramSocket@@QAE@I@Z PROC NEAR			; DatagramSocket::DatagramSocket, COMDAT
; _this$ = ecx

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 51   : 	__BEGIN_TRY 
; 52   : 
; 53   : 	m_SocketID = SocketAPI::socket_ex( AF_INET , SOCK_DGRAM , 0 );

  00006	6a 00		 push	 0
  00008	8b f1		 mov	 esi, ecx
  0000a	83 0e ff	 or	 DWORD PTR [esi], -1
  0000d	6a 02		 push	 2
  0000f	6a 02		 push	 2
  00011	e8 00 00 00 00	 call	 ?socket_ex@SocketAPI@@YAIHHH@Z ; SocketAPI::socket_ex

; 54   : 
; 55   : 	// clear memory
; 56   : 	memset( &m_SockAddr , 0 , szSOCKADDR_IN );

  00016	6a 10		 push	 16			; 00000010H
  00018	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0001b	6a 00		 push	 0
  0001d	57		 push	 edi
  0001e	89 06		 mov	 DWORD PTR [esi], eax
  00020	e8 00 00 00 00	 call	 _memset
  00025	83 c4 18	 add	 esp, 24			; 00000018H

; 57   : 	m_SockAddr.sin_family      = AF_INET;
; 58   : 	m_SockAddr.sin_addr.s_addr = htonl(INADDR_ANY);

  00028	6a 00		 push	 0
  0002a	66 c7 07 02 00	 mov	 WORD PTR [edi], 2
  0002f	e8 00 00 00 00	 call	 _htonl@4

; 59   : 	m_SockAddr.sin_port        = htons(port);

  00034	ff 75 08	 push	 DWORD PTR _port$[ebp]
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	e8 00 00 00 00	 call	 _htons@4

; 60   : 
; 61   : 	int opt = 1;
; 62   : 	SocketAPI::setsockopt_ex( m_SocketID, SOL_SOCKET , SO_REUSEADDR , &opt , sizeof(opt) );

  0003f	6a 04		 push	 4
  00041	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  00045	8d 45 fc	 lea	 eax, DWORD PTR _opt$[ebp]
  00048	50		 push	 eax
  00049	6a 04		 push	 4
  0004b	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00050	ff 36		 push	 DWORD PTR [esi]
  00052	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _opt$[ebp], 1
  00059	e8 00 00 00 00	 call	 ?setsockopt_ex@SocketAPI@@YAXIHHPBXI@Z ; SocketAPI::setsockopt_ex

; 63   : 
; 64   : 	// bind address to socket
; 65   : 	SocketAPI::bind_ex( m_SocketID , (SOCKADDR*)&m_SockAddr , szSOCKADDR_IN );

  0005e	6a 10		 push	 16			; 00000010H
  00060	57		 push	 edi
  00061	ff 36		 push	 DWORD PTR [esi]
  00063	e8 00 00 00 00	 call	 ?bind_ex@SocketAPI@@YAXIPBUsockaddr@@I@Z ; SocketAPI::bind_ex
  00068	83 c4 20	 add	 esp, 32			; 00000020H

; 66   : 
; 67   : 	// set host
; 68   : 	const char* pIP = inet_ntoa( m_SockAddr.sin_addr );

  0006b	ff 76 08	 push	 DWORD PTR [esi+8]
  0006e	e8 00 00 00 00	 call	 _inet_ntoa@4
  00073	5f		 pop	 edi

; 69   : 	int port2 = m_SockAddr.sin_port;
; 70   : 
; 71   : 	__END_CATCH
; 72   : }

  00074	8b c6		 mov	 eax, esi
  00076	5e		 pop	 esi
  00077	c9		 leave
  00078	c2 04 00	 ret	 4
??0DatagramSocket@@QAE@I@Z ENDP				; DatagramSocket::DatagramSocket
_TEXT	ENDS
PUBLIC	?send@DatagramSocket@@QAEIPAVDatagram@@@Z	; DatagramSocket::send
EXTRN	?sendto_ex@SocketAPI@@YAIIPBXHIPBUsockaddr@@H@Z:NEAR ; SocketAPI::sendto_ex
; Function compile flags: /Ogsy
;	COMDAT ?send@DatagramSocket@@QAEIPAVDatagram@@@Z
_TEXT	SEGMENT
_pDatagram$ = 8						; size = 4
?send@DatagramSocket@@QAEIPAVDatagram@@@Z PROC NEAR	; DatagramSocket::send, COMDAT
; _this$ = ecx

; 102  : 	__BEGIN_TRY 
; 103  : 
; 104  : 	Assert( pDatagram != NULL );
; 105  : 
; 106  : 	int nSent = SocketAPI::sendto_ex( m_SocketID , pDatagram->getData() , pDatagram->getLength() , 0 , pDatagram->getAddress() , szSOCKADDR_IN );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pDatagram$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	56		 push	 esi
  00007	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  0000a	6a 10		 push	 16			; 00000010H
  0000c	83 c0 10	 add	 eax, 16			; 00000010H
  0000f	50		 push	 eax
  00010	6a 00		 push	 0
  00012	52		 push	 edx
  00013	56		 push	 esi
  00014	ff 31		 push	 DWORD PTR [ecx]
  00016	e8 00 00 00 00	 call	 ?sendto_ex@SocketAPI@@YAIIPBXHIPBUsockaddr@@H@Z ; SocketAPI::sendto_ex
  0001b	83 c4 18	 add	 esp, 24			; 00000018H
  0001e	5e		 pop	 esi

; 107  : 
; 108  : 	return (uint)nSent;
; 109  : 
; 110  : 	__END_CATCH
; 111  : }

  0001f	c2 04 00	 ret	 4
?send@DatagramSocket@@QAEIPAVDatagram@@@Z ENDP		; DatagramSocket::send
_TEXT	ENDS
PUBLIC	?receive@DatagramSocket@@QAEPAVDatagram@@XZ	; DatagramSocket::receive
EXTRN	?recvfrom_ex@SocketAPI@@YAIIPAXHIPAUsockaddr@@PAI@Z:NEAR ; SocketAPI::recvfrom_ex
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	?availablesocket_ex@SocketAPI@@YAII@Z:NEAR	; SocketAPI::availablesocket_ex
EXTRN	??0Datagram@@QAE@XZ:NEAR			; Datagram::Datagram
EXTRN	?setData@Datagram@@QAEXPADI@Z:NEAR		; Datagram::setData
EXTRN	?setAddress@Datagram@@QAEXPAUsockaddr_in@@@Z:NEAR ; Datagram::setAddress
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?receive@DatagramSocket@@QAEPAVDatagram@@XZ
_TEXT	SEGMENT
__szSOCKADDR_IN$ = -24					; size = 4
_SockAddr$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?receive@DatagramSocket@@QAEPAVDatagram@@XZ PROC NEAR	; DatagramSocket::receive, COMDAT
; _this$ = ecx

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx

; 125  : 	__BEGIN_TRY 
; 126  : 
; 127  : 	Datagram * pDatagram = NULL;
; 128  : 
; 129  : 	SOCKADDR_IN SockAddr;
; 130  : 	uint _szSOCKADDR_IN = szSOCKADDR_IN;
; 131  : 
; 132  : 	// 읽을게 있는지 체크한다.
; 133  : 	ulong available = SocketAPI::availablesocket_ex( m_SocketID );		

  0000f	ff 36		 push	 DWORD PTR [esi]
  00011	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00014	33 db		 xor	 ebx, ebx
  00016	c7 45 e8 10 00
	00 00		 mov	 DWORD PTR __szSOCKADDR_IN$[ebp], 16 ; 00000010H
  0001d	e8 00 00 00 00	 call	 ?availablesocket_ex@SocketAPI@@YAII@Z ; SocketAPI::availablesocket_ex

; 134  : 	
; 135  : 	if (available > 0)

  00022	85 c0		 test	 eax, eax
  00024	59		 pop	 ecx
  00025	76 4d		 jbe	 SHORT $L100617
  00027	57		 push	 edi

; 136  : 	{
; 137  : 		#ifdef __METROTECH_TEST__
; 138  : 			g_UDPTest.UDPPacketAvailable ++;
; 139  : 		#endif
; 140  : 
; 141  : 		DEBUG_ADD_FORMAT("[DatagramSocket] available=%d", available);
; 142  : 
; 143  : 		// 내부 버퍼에다가 복사해둔다.
; 144  : 		int nReceived = SocketAPI::recvfrom_ex( m_SocketID , m_Buffer , DATAGRAM_SOCKET_BUFFER_LEN , 0 , (SOCKADDR*)&SockAddr , &_szSOCKADDR_IN );

  00028	8d 45 e8	 lea	 eax, DWORD PTR __szSOCKADDR_IN$[ebp]
  0002b	50		 push	 eax
  0002c	8d 45 ec	 lea	 eax, DWORD PTR _SockAddr$[ebp]
  0002f	50		 push	 eax
  00030	53		 push	 ebx
  00031	68 00 00 01 00	 push	 65536			; 00010000H
  00036	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  00039	57		 push	 edi
  0003a	ff 36		 push	 DWORD PTR [esi]
  0003c	e8 00 00 00 00	 call	 ?recvfrom_ex@SocketAPI@@YAIIPAXHIPAUsockaddr@@PAI@Z ; SocketAPI::recvfrom_ex
  00041	8b f0		 mov	 esi, eax
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 145  : 
; 146  : 		if ( nReceived > 0 ) 

  00046	3b f3		 cmp	 esi, ebx
  00048	7e 29		 jle	 SHORT $L101291

; 147  : 		{
; 148  : 			#ifdef __METROTECH_TEST__
; 149  : 				g_UDPTest.UDPPacketReceive ++;
; 150  : 			#endif
; 151  : 
; 152  : 			DEBUG_ADD_FORMAT("[DatagramSocket] received=%d", nReceived);
; 153  : 
; 154  : 			pDatagram = new Datagram();

  0004a	6a 20		 push	 32			; 00000020H
  0004c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00051	3b c3		 cmp	 eax, ebx
  00053	59		 pop	 ecx
  00054	74 09		 je	 SHORT $L101288
  00056	8b c8		 mov	 ecx, eax
  00058	e8 00 00 00 00	 call	 ??0Datagram@@QAE@XZ	; Datagram::Datagram
  0005d	8b d8		 mov	 ebx, eax
$L101288:

; 155  : 			pDatagram->setData( m_Buffer , nReceived );

  0005f	56		 push	 esi
  00060	57		 push	 edi
  00061	8b cb		 mov	 ecx, ebx
  00063	e8 00 00 00 00	 call	 ?setData@Datagram@@QAEXPADI@Z ; Datagram::setData

; 156  : 			pDatagram->setAddress( &SockAddr );

  00068	8d 45 ec	 lea	 eax, DWORD PTR _SockAddr$[ebp]
  0006b	50		 push	 eax
  0006c	8b cb		 mov	 ecx, ebx
  0006e	e8 00 00 00 00	 call	 ?setAddress@Datagram@@QAEXPAUsockaddr_in@@@Z ; Datagram::setAddress
$L101291:
  00073	5f		 pop	 edi
$L100617:

; 157  : 		}
; 158  : 	}	
; 159  : 
; 160  : 	return pDatagram;
; 161  : 
; 162  : 	__END_CATCH
; 163  : }

  00074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	5e		 pop	 esi
  00078	8b c3		 mov	 eax, ebx
  0007a	5b		 pop	 ebx
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	c9		 leave
  00081	c3		 ret	 0
?receive@DatagramSocket@@QAEPAVDatagram@@XZ ENDP	; DatagramSocket::receive
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEPBDXZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::c_str
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ?c_str@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEPBDXZ PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1065 :   const _CharT* c_str() const { return this->_M_start; }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
?c_str@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEPBDXZ ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	??1?$allocator@D@_STL@@QAE@XZ			; _STL::allocator<char>::~allocator<char>
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_alloc.h
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT
??1?$allocator@D@_STL@@QAE@XZ PROC NEAR			; _STL::allocator<char>::~allocator<char>, COMDAT
; _this$ = ecx

; 350  :   ~allocator() _STLP_NOTHROW {}

  00000	c3		 ret	 0
??1?$allocator@D@_STL@@QAE@XZ ENDP			; _STL::allocator<char>::~allocator<char>
_TEXT	ENDS
PUBLIC	??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ ; _STL::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >::~_STLP_alloc_proxy<char *,char,_STL::allocator<char> >
; Function compile flags: /Ogsy
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT
??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ PROC NEAR ; _STL::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >::~_STLP_alloc_proxy<char *,char,_STL::allocator<char> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ ENDP ; _STL::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >::~_STLP_alloc_proxy<char *,char,_STL::allocator<char> >
_TEXT	ENDS
PUBLIC	?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z ; _STL::__node_alloc<1,0>::deallocate
EXTRN	?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z:NEAR ; _STL::__node_alloc<1,0>::_M_deallocate
; Function compile flags: /Ogsy
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT
___p$ = 8						; size = 4
___n$ = 12						; size = 4
?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z PROC NEAR ; _STL::__node_alloc<1,0>::deallocate, COMDAT

; 253  :   static void _STLP_CALL deallocate(void *__p, size_t __n) { if (__n > (size_t)_MAX_BYTES) __stl_delete(__p); else _M_deallocate(__p, __n); }

  00000	81 7c 24 08 80
	00 00 00	 cmp	 DWORD PTR ___n$[esp-4], 128 ; 00000080H
  00008	76 0b		 jbe	 SHORT $L98677
  0000a	ff 74 24 04	 push	 DWORD PTR ___p$[esp-4]
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00013	59		 pop	 ecx
  00014	c3		 ret	 0
$L98677:
  00015	e9 00 00 00 00	 jmp	 ?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z ; _STL::__node_alloc<1,0>::_M_deallocate
?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z ENDP	; _STL::__node_alloc<1,0>::deallocate
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@_STL@@QAEXPADI@Z	; _STL::allocator<char>::deallocate
; Function compile flags: /Ogsy
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT
___p$ = 8						; size = 4
___n$ = 12						; size = 4
?deallocate@?$allocator@D@_STL@@QAEXPADI@Z PROC NEAR	; _STL::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 359  :     _STLP_ASSERT( (__p == 0) == (__n == 0) )
; 360  :       if (__p != 0) __sgi_alloc::deallocate((void*)__p, __n * sizeof(value_type));

  00000	83 7c 24 04 00	 cmp	 DWORD PTR ___p$[esp-4], 0
  00005	74 0f		 je	 SHORT $L98663
  00007	ff 74 24 08	 push	 DWORD PTR ___n$[esp-4]
  0000b	ff 74 24 08	 push	 DWORD PTR ___p$[esp]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z ; _STL::__node_alloc<1,0>::deallocate
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx
$L98663:

; 361  :   }

  00016	c2 08 00	 ret	 8
?deallocate@?$allocator@D@_STL@@QAEXPADI@Z ENDP		; _STL::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ ; _STL::_String_base<char,_STL::allocator<char> >::_M_deallocate_block
; Function compile flags: /Ogsy
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT
?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ PROC NEAR ; _STL::_String_base<char,_STL::allocator<char> >::_M_deallocate_block, COMDAT
; _this$ = ecx

; 124  :     { _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start); }

  00000	8b c1		 mov	 eax, ecx
  00002	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00005	8b 00		 mov	 eax, DWORD PTR [eax]
  00007	8b 11		 mov	 edx, DWORD PTR [ecx]
  00009	2b d0		 sub	 edx, eax
  0000b	52		 push	 edx
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z ; _STL::allocator<char>::deallocate
  00012	c3		 ret	 0
?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ ENDP ; _STL::_String_base<char,_STL::allocator<char> >::_M_deallocate_block
_TEXT	ENDS
PUBLIC	??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ ; _STL::_String_base<char,_STL::allocator<char> >::~_String_base<char,_STL::allocator<char> >
; Function compile flags: /Ogsy
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ PROC NEAR ; _STL::_String_base<char,_STL::allocator<char> >::~_String_base<char,_STL::allocator<char> >, COMDAT
; _this$ = ecx

; 135  :   ~_String_base() { _M_deallocate_block(); }

  00000	e9 00 00 00 00	 jmp	 ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ ; _STL::_String_base<char,_STL::allocator<char> >::_M_deallocate_block
??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ ENDP ; _STL::_String_base<char,_STL::allocator<char> >::~_String_base<char,_STL::allocator<char> >
_TEXT	ENDS
PUBLIC	??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
; Function compile flags: /Ogsy
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >, COMDAT
; _this$ = ecx

; 305  :   ~basic_string() { _STLP_STD::_Destroy(this->_M_start, this->_M_finish + 1); }

  00000	e9 00 00 00 00	 jmp	 ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ ; _STL::_String_base<char,_STL::allocator<char> >::_M_deallocate_block
??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
_TEXT	ENDS
PUBLIC	??1DatagramSocket@@QAE@XZ			; DatagramSocket::~DatagramSocket
PUBLIC	??_R0?AVThrowable@@@8				; Throwable `RTTI Type Descriptor'
EXTRN	__EH_prolog:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?closesocket_ex@SocketAPI@@YAXI@Z:NEAR		; SocketAPI::closesocket_ex
;	COMDAT xdata$x
; File c:\stlport-4.6.1\stlport\stl\_alloc.h
xdata$x	SEGMENT
$T101400 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T101402 DD	08H
	DD	FLAT:??_R0?AVThrowable@@@8
	DD	0ffffffecH
	DD	FLAT:$L101346
$T101401 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T101402
$T101396 DD	019930520H
	DD	02H
	DD	FLAT:$T101400
	DD	01H
	DD	FLAT:$T101401
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0?AVThrowable@@@8
_DATA	SEGMENT
??_R0?AVThrowable@@@8 DD FLAT:??_7type_info@@6B@	; Throwable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVThrowable@@', 00H
	ORG $-24
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVThrowable@@', 00H
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\packet\datagramsocket.cpp
_DATA	ENDS
;	COMDAT ??1DatagramSocket@@QAE@XZ
_TEXT	SEGMENT
$T101344 = -32						; size = 12
_t$100593 = -20						; size = 4
__$EHRec$ = -16						; size = 16
??1DatagramSocket@@QAE@XZ PROC NEAR			; DatagramSocket::~DatagramSocket, COMDAT
; _this$ = ecx

; 80   : {

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$??1DatagramSocket@@QAE@XZ
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 14	 sub	 esp, 20			; 00000014H

; 81   : 	__BEGIN_TRY
; 82   : 	
; 83   : 	if ( m_SocketID != INVALID_SOCKET )

  0000d	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00016	74 0c		 je	 SHORT $L100592

; 84   : 	{
; 85   : 		try {
; 86   : 			SocketAPI::closesocket_ex( m_SocketID );

  00018	ff 31		 push	 DWORD PTR [ecx]
  0001a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  0001e	e8 00 00 00 00	 call	 ?closesocket_ex@SocketAPI@@YAXI@Z ; SocketAPI::closesocket_ex
  00023	59		 pop	 ecx
$L100592:

; 90   : 	}
; 91   : 
; 92   : 	__END_CATCH
; 93   : }

  00024	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00030	5b		 pop	 ebx
  00031	c9		 leave
  00032	c3		 ret	 0
$L101346:

; 87   : 		} catch (Throwable& t) {
; 88   : 			DEBUG_ADD( t.toString().c_str() );

  00033	8b 4d ec	 mov	 ecx, DWORD PTR _t$100593[ebp]
  00036	8b 01		 mov	 eax, DWORD PTR [ecx]
  00038	8d 55 e0	 lea	 edx, DWORD PTR $T101344[ebp]
  0003b	52		 push	 edx
  0003c	ff 50 08	 call	 DWORD PTR [eax+8]
  0003f	8b 45 e8	 mov	 eax, DWORD PTR $T101344[ebp+8]
  00042	2b 45 e0	 sub	 eax, DWORD PTR $T101344[ebp]
  00045	8d 4d e8	 lea	 ecx, DWORD PTR $T101344[ebp+8]
  00048	50		 push	 eax
  00049	ff 75 e0	 push	 DWORD PTR $T101344[ebp]
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z ; _STL::allocator<char>::deallocate

; 89   : 		}

  00051	b8 00 00 00 00	 mov	 eax, $L100592
  00056	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1DatagramSocket@@QAE@XZ:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T101396
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1DatagramSocket@@QAE@XZ ENDP				; DatagramSocket::~DatagramSocket
END
