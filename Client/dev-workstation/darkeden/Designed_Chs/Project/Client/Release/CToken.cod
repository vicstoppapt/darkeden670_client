; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\CToken.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??0CToken@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CToken@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CToken@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@CToken@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToken@CToken@@QAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnd@CToken@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SkipSpace@CToken@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Release@CToken@@AAEXXZ				; CToken::Release
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\ctoken.cpp
;	COMDAT ?Release@CToken@@AAEXXZ
_TEXT	SEGMENT
?Release@CToken@@AAEXXZ PROC NEAR			; CToken::Release, COMDAT
; _this$ = ecx

; 39   :    if (m_pString!=NULL)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	74 07		 je	 SHORT $L99413

; 40   :       delete [] m_pString;

  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000c	59		 pop	 ecx
$L99413:

; 41   : }

  0000d	c3		 ret	 0
?Release@CToken@@AAEXXZ ENDP				; CToken::Release
_TEXT	ENDS
PUBLIC	?SetString@CToken@@QAEXPBD@Z			; CToken::SetString
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	_strcpy:NEAR
EXTRN	_strlen:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?SetString@CToken@@QAEXPBD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?SetString@CToken@@QAEXPBD@Z PROC NEAR			; CToken::SetString, COMDAT
; _this$ = ecx

; 48   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 49   : 	Release();

  00004	e8 00 00 00 00	 call	 ?Release@CToken@@AAEXXZ	; CToken::Release

; 50   : 	  
; 51   :    if (str!=NULL)

  00009	8b 7c 24 0c	 mov	 edi, DWORD PTR _str$[esp+4]
  0000d	85 ff		 test	 edi, edi
  0000f	74 21		 je	 SHORT $L99419

; 52   :    {
; 53   : 	   m_nStringLenght	= strlen(str);

  00011	57		 push	 edi
  00012	e8 00 00 00 00	 call	 _strlen
  00017	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 54   : 
; 55   :       // 메모리 잡기
; 56   :       m_pString = new char [m_nStringLenght + 1];

  0001a	40		 inc	 eax
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 57   : 
; 58   :       strcpy(m_pString, str);

  00021	57		 push	 edi
  00022	50		 push	 eax
  00023	89 06		 mov	 DWORD PTR [esi], eax
  00025	e8 00 00 00 00	 call	 _strcpy

; 59   : 
; 60   :       m_pCurrent = m_pString;

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	89 46 04	 mov	 DWORD PTR [esi+4], eax
$L99419:
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi

; 61   :    }
; 62   : }

  00034	c2 04 00	 ret	 4
?SetString@CToken@@QAEXPBD@Z ENDP			; CToken::SetString
_TEXT	ENDS
PUBLIC	?SkipSpace@CToken@@QAEXXZ			; CToken::SkipSpace
; Function compile flags: /Ogsy
;	COMDAT ?SkipSpace@CToken@@QAEXXZ
_TEXT	SEGMENT
?SkipSpace@CToken@@QAEXXZ PROC NEAR			; CToken::SkipSpace, COMDAT
; _this$ = ecx

; 121  :     {
; 122  :         m_pCurrent += 1;

  00000	eb 10		 jmp	 SHORT $L100053
$L99440:

; 120  : 	while (m_pCurrent!=NULL && m_pCurrent!='\0' && *m_pCurrent == ' ')

  00002	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $L99441
  00009	80 38 20	 cmp	 BYTE PTR [eax], 32	; 00000020H
  0000c	75 0a		 jne	 SHORT $L99441

; 121  :     {
; 122  :         m_pCurrent += 1;

  0000e	40		 inc	 eax
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L100053:

; 120  : 	while (m_pCurrent!=NULL && m_pCurrent!='\0' && *m_pCurrent == ' ')

  00012	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00016	75 ea		 jne	 SHORT $L99440
$L99441:

; 123  :     }
; 124  : }

  00018	c3		 ret	 0
?SkipSpace@CToken@@QAEXXZ ENDP				; CToken::SkipSpace
_TEXT	ENDS
PUBLIC	??0CToken@@QAE@PBD@Z				; CToken::CToken
; Function compile flags: /Ogsy
;	COMDAT ??0CToken@@QAE@PBD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
??0CToken@@QAE@PBD@Z PROC NEAR				; CToken::CToken, COMDAT
; _this$ = ecx

; 14   : {

  00000	56		 push	 esi

; 15   :    m_pString = NULL;
; 16   :    m_pCurrent = NULL;
; 17   : 
; 18   :    SetString(str);

  00001	ff 74 24 08	 push	 DWORD PTR _str$[esp]
  00005	8b f1		 mov	 esi, ecx
  00007	83 26 00	 and	 DWORD PTR [esi], 0
  0000a	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  0000e	e8 00 00 00 00	 call	 ?SetString@CToken@@QAEXPBD@Z ; CToken::SetString

; 19   : }

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0CToken@@QAE@PBD@Z ENDP				; CToken::CToken
_TEXT	ENDS
PUBLIC	??1CToken@@QAE@XZ				; CToken::~CToken
; Function compile flags: /Ogsy
;	COMDAT ??1CToken@@QAE@XZ
_TEXT	SEGMENT
??1CToken@@QAE@XZ PROC NEAR				; CToken::~CToken, COMDAT
; _this$ = ecx

; 23   :    Release();

  00000	e9 00 00 00 00	 jmp	 ?Release@CToken@@AAEXXZ	; CToken::Release
??1CToken@@QAE@XZ ENDP					; CToken::~CToken
_TEXT	ENDS
PUBLIC	?GetToken@CToken@@QAEPBDPBD@Z			; CToken::GetToken
EXTRN	_strpbrk:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?GetToken@CToken@@QAEPBDPBD@Z
_TEXT	SEGMENT
_delimiter$ = 8						; size = 4
?GetToken@CToken@@QAEPBDPBD@Z PROC NEAR			; CToken::GetToken, COMDAT
; _this$ = ecx

; 69   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 70   : 	if (m_pCurrent==NULL ||
; 71   : 		m_pCurrent > m_pString + m_nStringLenght - 1)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 39		 je	 SHORT $L99427
  0000a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000d	8b 16		 mov	 edx, DWORD PTR [esi]
  0000f	8d 4c 11 ff	 lea	 ecx, DWORD PTR [ecx+edx-1]
  00013	3b c1		 cmp	 eax, ecx
  00015	77 2c		 ja	 SHORT $L99427
  00017	57		 push	 edi

; 74   : 	}
; 75   : 	
; 76   : 	SkipSpace();

  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?SkipSpace@CToken@@QAEXXZ ; CToken::SkipSpace

; 77   : 
; 78   : 	char* pTemp = m_pCurrent;

  0001f	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 79   : 	
; 80   : 	// delimiter가 최초로 나타나는 pointer를 구한다.
; 81   : 	char* pFound = strpbrk(m_pCurrent, delimiter);

  00022	ff 74 24 0c	 push	 DWORD PTR _delimiter$[esp+4]
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _strpbrk

; 82   : 	
; 83   : 	// last token
; 84   : 	if (pFound==NULL)

  0002c	85 c0		 test	 eax, eax
  0002e	59		 pop	 ecx
  0002f	59		 pop	 ecx
  00030	75 05		 jne	 SHORT $L99430

; 85   : 	{
; 86   : 		m_pCurrent = NULL;

  00032	21 46 04	 and	 DWORD PTR [esi+4], eax

; 87   : 	}
; 88   : 	// else
; 89   : 	else

  00035	eb 07		 jmp	 SHORT $L99431
$L99430:

; 90   : 	{
; 91   : 		*pFound = '\0';

  00037	c6 00 00	 mov	 BYTE PTR [eax], 0

; 92   : 		
; 93   : 		m_pCurrent = pFound+1;

  0003a	40		 inc	 eax
  0003b	89 46 04	 mov	 DWORD PTR [esi+4], eax
$L99431:

; 94   : 	}
; 95   : 	
; 96   : 	return pTemp;

  0003e	8b c7		 mov	 eax, edi
  00040	5f		 pop	 edi
  00041	eb 02		 jmp	 SHORT $L99425
$L99427:

; 72   : 	{
; 73   : 		return NULL;

  00043	33 c0		 xor	 eax, eax
$L99425:
  00045	5e		 pop	 esi

; 97   : }

  00046	c2 04 00	 ret	 4
?GetToken@CToken@@QAEPBDPBD@Z ENDP			; CToken::GetToken
_TEXT	ENDS
PUBLIC	?GetEnd@CToken@@QAEPBDXZ			; CToken::GetEnd
; Function compile flags: /Ogsy
;	COMDAT ?GetEnd@CToken@@QAEPBDXZ
_TEXT	SEGMENT
?GetEnd@CToken@@QAEPBDXZ PROC NEAR			; CToken::GetEnd, COMDAT
; _this$ = ecx

; 105  :    SkipSpace();

  00000	e8 00 00 00 00	 call	 ?SkipSpace@CToken@@QAEXXZ ; CToken::SkipSpace

; 106  : 
; 107  :    char* pTemp = m_pCurrent;

  00005	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 108  : 
; 109  :    m_pCurrent = NULL;

  00008	83 61 04 00	 and	 DWORD PTR [ecx+4], 0

; 110  : 
; 111  :    return pTemp;
; 112  : }

  0000c	c3		 ret	 0
?GetEnd@CToken@@QAEPBDXZ ENDP				; CToken::GetEnd
_TEXT	ENDS
END
