; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\MItemOptionTable.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BN@ODLNCKCA@Data?2?2Info?2?2ClientConfig?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@DFPLPGPC@Data?2?2Info?2?2GuildMapper?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@LHODHNBK@Data?2?2Info?2?2GuildVersion?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@DDPLNCOL@Data?2?2Info?2?2Player?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@ILLNAPHB@Data?2?2Info?2?2Resolution?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@HEIGFDLG@Data?2?2Info?2?2SelectedChannel?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?start@CNFS@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@CNFS@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@VirtualFileHeader@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1IFileIO@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIFileIO@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iovfs_base@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Giovfs_base@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1iovfs_base@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@iovfs_base@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Givfstream@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ivfstream@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?open@ivfstream@@UAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?read@ivfstream@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Govfstream@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ovfstream@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?open@ovfstream@@UAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ITEMOPTION_INFO@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ITEMOPTION_INFO@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFile@ITEMOPTION_INFO@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveToFile@ITEMOPTION_INFO@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFile@ITEMOPTION_TABLE@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFromFile@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EITEMOPTION_INFO@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVIFileIO@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVovfstream@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVivfstream@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AViovfs_base@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4IFileIO@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ovfstream@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ivfstream@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4iovfs_base@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@_STL@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ovfstream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ivfstream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7iovfs_base@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IFileIO@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pItemOptionTable@@3PAVITEMOPTION_TABLE@@A	; g_pItemOptionTable
_BSS	SEGMENT
?g_pItemOptionTable@@3PAVITEMOPTION_TABLE@@A DD 01H DUP (?) ; g_pItemOptionTable
_BSS	ENDS
PUBLIC	?read@ivfstream@@QAEXPADI@Z			; ivfstream::read
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\virtualfilesystem\vfstream.inl
;	COMDAT ?read@ivfstream@@QAEXPADI@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
?read@ivfstream@@QAEXPADI@Z PROC NEAR			; ivfstream::read, COMDAT
; _this$ = ecx

; 81   : 	if(m_pFileIO) m_pFileIO->read(buf, len);

  00000	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00004	74 08		 je	 SHORT $L100361
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 60 10	 jmp	 DWORD PTR [eax+16]
$L100361:

; 82   : }

  0000e	c2 08 00	 ret	 8
?read@ivfstream@@QAEXPADI@Z ENDP			; ivfstream::read
_TEXT	ENDS
PUBLIC	??0ITEMOPTION_INFO@@QAE@XZ			; ITEMOPTION_INFO::ITEMOPTION_INFO
EXTRN	??0MString@@QAE@XZ:NEAR				; MString::MString
EXTRN	??1MString@@UAE@XZ:NEAR				; MString::~MString
EXTRN	__EH_prolog:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\darkeden\designed_common\project\client\mitemoptiontable.cpp
xdata$x	SEGMENT
$T101830 DD	0ffffffffH
	DD	FLAT:$L101821
$T101826 DD	019930520H
	DD	01H
	DD	FLAT:$T101830
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ??0ITEMOPTION_INFO@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ITEMOPTION_INFO@@QAE@XZ PROC NEAR			; ITEMOPTION_INFO::ITEMOPTION_INFO, COMDAT
; _this$ = ecx

; 74   : {

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$??0ITEMOPTION_INFO@@QAE@XZ
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	51		 push	 ecx
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	e8 00 00 00 00	 call	 ??0MString@@QAE@XZ	; MString::MString
  00016	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001a	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0001d	e8 00 00 00 00	 call	 ??0MString@@QAE@XZ	; MString::MString

; 75   : }

  00022	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0002f	c9		 leave
  00030	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L101821:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1MString@@UAE@XZ	; MString::~MString
__ehhandler$??0ITEMOPTION_INFO@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T101826
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0ITEMOPTION_INFO@@QAE@XZ ENDP				; ITEMOPTION_INFO::ITEMOPTION_INFO
PUBLIC	??1ITEMOPTION_INFO@@QAE@XZ			; ITEMOPTION_INFO::~ITEMOPTION_INFO
;	COMDAT xdata$x
xdata$x	SEGMENT
$T101841 DD	0ffffffffH
	DD	FLAT:$L101836
$T101839 DD	019930520H
	DD	01H
	DD	FLAT:$T101841
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ??1ITEMOPTION_INFO@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ITEMOPTION_INFO@@QAE@XZ PROC NEAR			; ITEMOPTION_INFO::~ITEMOPTION_INFO, COMDAT
; _this$ = ecx

; 78   : {

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$??1ITEMOPTION_INFO@@QAE@XZ
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	51		 push	 ecx
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 79   : }

  00015	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00018	e8 00 00 00 00	 call	 ??1MString@@UAE@XZ	; MString::~MString
  0001d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ??1MString@@UAE@XZ	; MString::~MString
  00028	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0002b	5e		 pop	 esi
  0002c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00033	c9		 leave
  00034	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L101836:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1MString@@UAE@XZ	; MString::~MString
__ehhandler$??1ITEMOPTION_INFO@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T101839
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1ITEMOPTION_INFO@@QAE@XZ ENDP				; ITEMOPTION_INFO::~ITEMOPTION_INFO
PUBLIC	?LoadFromFile@ITEMOPTION_INFO@@QAEXAAVivfstream@@@Z ; ITEMOPTION_INFO::LoadFromFile
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFile@ITEMOPTION_INFO@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
?LoadFromFile@ITEMOPTION_INFO@@QAEXAAVivfstream@@@Z PROC NEAR ; ITEMOPTION_INFO::LoadFromFile, COMDAT
; _this$ = ecx

; 122  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 123  : 	EName.LoadFromFile(file);							// ItemOption 이름	

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _file$[esp+8]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 07		 mov	 eax, DWORD PTR [edi]
  0000c	56		 push	 esi
  0000d	ff 50 08	 call	 DWORD PTR [eax+8]

; 124  : 	Name.LoadFromFile(file);							// ItemOption 이름

  00010	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	56		 push	 esi
  00016	ff 50 08	 call	 DWORD PTR [eax+8]

; 125  : 	file.read((char*)&Part, 4);				// ItemOption Part	

  00019	33 ed		 xor	 ebp, ebp
  0001b	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  0001e	6a 04		 push	 4
  00020	5b		 pop	 ebx
  00021	0f 84 cd 00 00
	00		 je	 $L101898
  00027	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002c	53		 push	 ebx
  0002d	8d 57 18	 lea	 edx, DWORD PTR [edi+24]
  00030	52		 push	 edx
  00031	ff 50 10	 call	 DWORD PTR [eax+16]

; 126  : 	file.read((char*)&PlusPoint, 4);			// 증가치

  00034	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  00037	0f 84 b7 00 00
	00		 je	 $L101898
  0003d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	53		 push	 ebx
  00043	8d 57 1c	 lea	 edx, DWORD PTR [edi+28]
  00046	52		 push	 edx
  00047	ff 50 10	 call	 DWORD PTR [eax+16]

; 127  : 	file.read((char*)&PriceMultiplier, 4);				// 가치

  0004a	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  0004d	0f 84 a1 00 00
	00		 je	 $L101898
  00053	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00056	8b 01		 mov	 eax, DWORD PTR [ecx]
  00058	53		 push	 ebx
  00059	8d 57 20	 lea	 edx, DWORD PTR [edi+32]
  0005c	52		 push	 edx
  0005d	ff 50 10	 call	 DWORD PTR [eax+16]

; 128  : 	//file.read((char*)&PlusRequireAbility, 4);	// 필요 능력	
; 129  : 	
; 130  : 	file.read((char*)&RequireSTR, 4);

  00060	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  00063	0f 84 8b 00 00
	00		 je	 $L101898
  00069	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006e	53		 push	 ebx
  0006f	8d 57 24	 lea	 edx, DWORD PTR [edi+36]
  00072	52		 push	 edx
  00073	ff 50 10	 call	 DWORD PTR [eax+16]

; 131  : 	file.read((char*)&RequireDEX, 4);

  00076	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  00079	74 79		 je	 SHORT $L101898
  0007b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0007e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00080	53		 push	 ebx
  00081	8d 57 28	 lea	 edx, DWORD PTR [edi+40]
  00084	52		 push	 edx
  00085	ff 50 10	 call	 DWORD PTR [eax+16]

; 132  : 	file.read((char*)&RequireINT, 4);		

  00088	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  0008b	74 67		 je	 SHORT $L101898
  0008d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00090	8b 01		 mov	 eax, DWORD PTR [ecx]
  00092	53		 push	 ebx
  00093	8d 57 2c	 lea	 edx, DWORD PTR [edi+44]
  00096	52		 push	 edx
  00097	ff 50 10	 call	 DWORD PTR [eax+16]

; 133  : 	file.read((char*)&RequireSUM, 4);

  0009a	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  0009d	74 55		 je	 SHORT $L101898
  0009f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000a2	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a4	53		 push	 ebx
  000a5	8d 57 30	 lea	 edx, DWORD PTR [edi+48]
  000a8	52		 push	 edx
  000a9	ff 50 10	 call	 DWORD PTR [eax+16]

; 134  : 	file.read((char*)&RequireLevel, 4);

  000ac	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  000af	74 43		 je	 SHORT $L101898
  000b1	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b6	53		 push	 ebx
  000b7	8d 57 34	 lea	 edx, DWORD PTR [edi+52]
  000ba	52		 push	 edx
  000bb	ff 50 10	 call	 DWORD PTR [eax+16]

; 135  : 
; 136  : 	
; 137  : 	file.read((char*)&ColorSet, 4);			// ColorSet번호

  000be	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  000c1	74 31		 je	 SHORT $L101898
  000c3	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000c6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c8	53		 push	 ebx
  000c9	8d 57 38	 lea	 edx, DWORD PTR [edi+56]
  000cc	52		 push	 edx
  000cd	ff 50 10	 call	 DWORD PTR [eax+16]

; 138  : 	file.read((char*)&UpgradeOptionType, 4);

  000d0	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  000d3	74 1f		 je	 SHORT $L101898
  000d5	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000d8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000da	53		 push	 ebx
  000db	8d 57 3c	 lea	 edx, DWORD PTR [edi+60]
  000de	52		 push	 edx
  000df	ff 50 10	 call	 DWORD PTR [eax+16]

; 139  : 	file.read((char*)&PreviousOptionType, 4);

  000e2	39 6e 04	 cmp	 DWORD PTR [esi+4], ebp
  000e5	74 0d		 je	 SHORT $L101898
  000e7	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000ea	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ec	53		 push	 ebx
  000ed	83 c7 40	 add	 edi, 64			; 00000040H
  000f0	57		 push	 edi
  000f1	ff 50 10	 call	 DWORD PTR [eax+16]
$L101898:
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5d		 pop	 ebp
  000f7	5b		 pop	 ebx

; 140  : }

  000f8	c2 04 00	 ret	 4
?LoadFromFile@ITEMOPTION_INFO@@QAEXAAVivfstream@@@Z ENDP ; ITEMOPTION_INFO::LoadFromFile
_TEXT	ENDS
PUBLIC	?SaveToFile@ITEMOPTION_INFO@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ; ITEMOPTION_INFO::SaveToFile
; Function compile flags: /Ogsy
;	COMDAT ?SaveToFile@ITEMOPTION_INFO@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
?SaveToFile@ITEMOPTION_INFO@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z PROC NEAR ; ITEMOPTION_INFO::SaveToFile, COMDAT
; _this$ = ecx

; 148  : }

  00000	c2 04 00	 ret	 4
?SaveToFile@ITEMOPTION_INFO@@QAEXAAV?$basic_ofstream@DV?$char_traits@D@_STL@@@_STL@@@Z ENDP ; ITEMOPTION_INFO::SaveToFile
_TEXT	ENDS
PUBLIC	??_EITEMOPTION_INFO@@QAEPAXI@Z			; ITEMOPTION_INFO::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Ogsy
;	COMDAT ??_EITEMOPTION_INFO@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_EITEMOPTION_INFO@@QAEPAXI@Z PROC NEAR		; ITEMOPTION_INFO::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 24		 je	 SHORT $L101405
  0000d	57		 push	 edi
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??1ITEMOPTION_INFO@@QAE@XZ ; ITEMOPTION_INFO::~ITEMOPTION_INFO
  00013	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00016	ff 37		 push	 DWORD PTR [edi]
  00018	6a 44		 push	 68			; 00000044H
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00020	f6 c3 01	 test	 bl, 1
  00023	74 07		 je	 SHORT $L101406
  00025	57		 push	 edi
  00026	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002b	59		 pop	 ecx
$L101406:
  0002c	8b c7		 mov	 eax, edi
  0002e	5f		 pop	 edi
  0002f	eb 15		 jmp	 SHORT $L101404
$L101405:
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ??1ITEMOPTION_INFO@@QAE@XZ ; ITEMOPTION_INFO::~ITEMOPTION_INFO
  00038	f6 c3 01	 test	 bl, 1
  0003b	74 07		 je	 SHORT $L101408
  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00043	59		 pop	 ecx
$L101408:
  00044	8b c6		 mov	 eax, esi
$L101404:
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	c2 04 00	 ret	 4
??_EITEMOPTION_INFO@@QAEPAXI@Z ENDP			; ITEMOPTION_INFO::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?Release@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXXZ ; CTypeTable<ITEMOPTION_INFO>::Release
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\ctypetable.h
;	COMDAT ?Release@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXXZ
_TEXT	SEGMENT
?Release@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXXZ PROC NEAR ; CTypeTable<ITEMOPTION_INFO>::Release, COMDAT
; _this$ = ecx

; 108  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 109  : 	if (m_pTypeInfo != NULL)

  00003	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0e		 je	 SHORT $L101386

; 110  : 	{
; 111  : 		// 모든 CSprite를 지운다.
; 112  : 		delete [] m_pTypeInfo;

  0000a	6a 03		 push	 3
  0000c	e8 00 00 00 00	 call	 ??_EITEMOPTION_INFO@@QAEPAXI@Z

; 113  : 		m_pTypeInfo = NULL;

  00011	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 114  : 		
; 115  : 		m_Size = 0;

  00015	83 26 00	 and	 DWORD PTR [esi], 0
$L101386:
  00018	5e		 pop	 esi

; 116  : 	}
; 117  : }

  00019	c3		 ret	 0
?Release@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXXZ ENDP	; CTypeTable<ITEMOPTION_INFO>::Release
_TEXT	ENDS
PUBLIC	?Init@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXH@Z	; CTypeTable<ITEMOPTION_INFO>::Init
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:NEAR			; `eh vector constructor iterator'
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
;	COMDAT xdata$x
xdata$x	SEGMENT
$T101936 DD	0ffffffffH
	DD	FLAT:$L101932
$T101934 DD	019930520H
	DD	01H
	DD	FLAT:$T101936
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?Init@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T101929 = 8						; size = 4
_size$ = 8						; size = 4
?Init@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXH@Z PROC NEAR ; CTypeTable<ITEMOPTION_INFO>::Init, COMDAT
; _this$ = ecx

; 87   : {

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?Init@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXH@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	53		 push	 ebx
  0000b	56		 push	 esi

; 88   : 	// 개수가 없을 경우 
; 89   : 	if (size==0) 

  0000c	8b 75 08	 mov	 esi, DWORD PTR _size$[ebp]
  0000f	57		 push	 edi
  00010	33 ff		 xor	 edi, edi
  00012	3b f7		 cmp	 esi, edi
  00014	8b d9		 mov	 ebx, ecx
  00016	74 3b		 je	 SHORT $L101373

; 90   : 		return;
; 91   : 
; 92   : 	// 일단 해제
; 93   : 	Release();

  00018	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXXZ ; CTypeTable<ITEMOPTION_INFO>::Release

; 94   : 
; 95   : 	// 메모리 잡기
; 96   : 	m_Size = size;
; 97   : 	
; 98   : 	m_pTypeInfo = new Type [m_Size];	

  0001d	8b c6		 mov	 eax, esi
  0001f	6b c0 44	 imul	 eax, 68			; 00000044H
  00022	83 c0 04	 add	 eax, 4
  00025	50		 push	 eax
  00026	89 33		 mov	 DWORD PTR [ebx], esi
  00028	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002d	59		 pop	 ecx
  0002e	89 45 08	 mov	 DWORD PTR $T101929[ebp], eax
  00031	3b c7		 cmp	 eax, edi
  00033	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00036	74 18		 je	 SHORT $L101931
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??1ITEMOPTION_INFO@@QAE@XZ ; ITEMOPTION_INFO::~ITEMOPTION_INFO
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??0ITEMOPTION_INFO@@QAE@XZ ; ITEMOPTION_INFO::ITEMOPTION_INFO
  00042	56		 push	 esi
  00043	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00046	6a 44		 push	 68			; 00000044H
  00048	57		 push	 edi
  00049	89 30		 mov	 DWORD PTR [eax], esi
  0004b	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
$L101931:
  00050	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
$L101373:

; 99   : }

  00053	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00060	c9		 leave
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L101932:
  00000	ff 75 08	 push	 DWORD PTR $T101929[ebp]
  00003	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?Init@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXH@Z:
  0000a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T101934
  0000f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Init@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXH@Z ENDP	; CTypeTable<ITEMOPTION_INFO>::Init
PUBLIC	?LoadFromFile@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXAAVivfstream@@@Z ; CTypeTable<ITEMOPTION_INFO>::LoadFromFile
; Function compile flags: /Ogsy
;	COMDAT ?LoadFromFile@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_numSize$ = -4						; size = 4
tv191 = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFile@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXAAVivfstream@@@Z PROC NEAR ; CTypeTable<ITEMOPTION_INFO>::LoadFromFile, COMDAT
; _this$ = ecx

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 147  : 	int numSize;
; 148  : 	
; 149  : 	// size 읽어오기
; 150  : 	file.read((char*)&numSize, 4);

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _file$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	33 ff		 xor	 edi, edi
  0000c	39 7b 04	 cmp	 DWORD PTR [ebx+4], edi
  0000f	8b f1		 mov	 esi, ecx
  00011	74 0e		 je	 SHORT $L101943
  00013	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 04		 push	 4
  0001a	8d 55 fc	 lea	 edx, DWORD PTR _numSize$[ebp]
  0001d	52		 push	 edx
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
$L101943:

; 151  : 
; 152  : 	// 현재 잡혀있는 메모리와 다르면 다시 메모리를 잡는다.
; 153  : 	if (m_Size != numSize)

  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR _numSize$[ebp]
  00026	74 11		 je	 SHORT $L101261

; 154  : 	{
; 155  : 		// 메모리 해제
; 156  : 		Release();

  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?Release@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXXZ ; CTypeTable<ITEMOPTION_INFO>::Release

; 157  : 
; 158  : 		// 메모리 잡기
; 159  : 		Init( numSize );

  0002f	ff 75 fc	 push	 DWORD PTR _numSize$[ebp]
  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?Init@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXH@Z ; CTypeTable<ITEMOPTION_INFO>::Init
$L101261:

; 160  : 	}
; 161  : 
; 162  : 	// file에서 각각의 정보를 읽어들인다.
; 163  : 	for (int i=0; i<m_Size; i++)

  00039	39 3e		 cmp	 DWORD PTR [esi], edi
  0003b	7e 18		 jle	 SHORT $L101265
  0003d	89 7d 08	 mov	 DWORD PTR tv191[ebp], edi
$L101948:

; 164  : 	{
; 165  :  		m_pTypeInfo[i].LoadFromFile( file );

  00040	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00043	03 4d 08	 add	 ecx, DWORD PTR tv191[ebp]
  00046	53		 push	 ebx
  00047	e8 00 00 00 00	 call	 ?LoadFromFile@ITEMOPTION_INFO@@QAEXAAVivfstream@@@Z ; ITEMOPTION_INFO::LoadFromFile
  0004c	83 45 08 44	 add	 DWORD PTR tv191[ebp], 68 ; 00000044H
  00050	47		 inc	 edi
  00051	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00053	7c eb		 jl	 SHORT $L101948
$L101265:
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx

; 166  : 	}
; 167  : }

  00058	c9		 leave
  00059	c2 04 00	 ret	 4
?LoadFromFile@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXAAVivfstream@@@Z ENDP ; CTypeTable<ITEMOPTION_INFO>::LoadFromFile
_TEXT	ENDS
PUBLIC	?LoadFromFile@ITEMOPTION_TABLE@@QAEXAAVivfstream@@@Z ; ITEMOPTION_TABLE::LoadFromFile
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\mitemoptiontable.cpp
;	COMDAT ?LoadFromFile@ITEMOPTION_TABLE@@QAEXAAVivfstream@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
_file$ = 8						; size = 4
?LoadFromFile@ITEMOPTION_TABLE@@QAEXAAVivfstream@@@Z PROC NEAR ; ITEMOPTION_TABLE::LoadFromFile, COMDAT
; _this$ = ecx

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 156  : 	int size;
; 157  : 
; 158  : 	file.read((char *)&size, 4);

  00007	8b 7d 08	 mov	 edi, DWORD PTR _file$[ebp]
  0000a	33 db		 xor	 ebx, ebx
  0000c	39 5f 04	 cmp	 DWORD PTR [edi+4], ebx
  0000f	8b f1		 mov	 esi, ecx
  00011	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00014	74 0e		 je	 SHORT $L101953
  00016	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00019	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001b	6a 04		 push	 4
  0001d	8d 55 08	 lea	 edx, DWORD PTR _size$[ebp]
  00020	52		 push	 edx
  00021	ff 50 10	 call	 DWORD PTR [eax+16]
$L101953:

; 159  : 	for(int i = 0; i < size; i++)

  00024	39 5d 08	 cmp	 DWORD PTR _size$[ebp], ebx
  00027	7e 20		 jle	 SHORT $L101023
  00029	83 c6 08	 add	 esi, 8
$L101021:

; 160  : 	{
; 161  : 		ITEMOPTION_PARTENAME[i].LoadFromFile(file);

  0002c	8d 8e c8 01 00
	00		 lea	 ecx, DWORD PTR [esi+456]
  00032	8b 01		 mov	 eax, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 50 08	 call	 DWORD PTR [eax+8]

; 162  : 		ITEMOPTION_PARTNAME[i].LoadFromFile(file);

  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	57		 push	 edi
  0003b	8b ce		 mov	 ecx, esi
  0003d	ff 50 08	 call	 DWORD PTR [eax+8]
  00040	43		 inc	 ebx
  00041	83 c6 0c	 add	 esi, 12			; 0000000cH
  00044	3b 5d 08	 cmp	 ebx, DWORD PTR _size$[ebp]
  00047	7c e3		 jl	 SHORT $L101021
$L101023:

; 163  : 	}
; 164  : 
; 165  : 	CTypeTable<ITEMOPTION_INFO>::LoadFromFile(file);

  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	57		 push	 edi
  0004d	e8 00 00 00 00	 call	 ?LoadFromFile@?$CTypeTable@VITEMOPTION_INFO@@@@QAEXAAVivfstream@@@Z ; CTypeTable<ITEMOPTION_INFO>::LoadFromFile
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx

; 166  : }

  00055	c9		 leave
  00056	c2 04 00	 ret	 4
?LoadFromFile@ITEMOPTION_TABLE@@QAEXAAVivfstream@@@Z ENDP ; ITEMOPTION_TABLE::LoadFromFile
_TEXT	ENDS
END
