; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\Packet\Crypt.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??0CCryptManager@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCryptManager@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRandKey@CCryptManager@@IAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadTable@CCryptManager@@IAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadTable2@CCryptManager@@IAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Encrypt@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetKey@CCryptManager@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EncryptHeader@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecryptHeader@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CryptBuf@CCryptManager@@QAEXPADHT_KEY_TYPE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrypt@CCryptManager@@QAEHPAU_PACKETDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Encrypt1@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrypt1@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Encrypt2@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrypt2@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Encrypt3@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrypt3@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitCryptManager@CCryptManager@@QAEH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeRandomKeyTable@CCryptManager@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopManager@CCryptManager@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rand@CRNGRand@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?srand@CRNGRand@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRandom@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRandom@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SeedMT@CRandom@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReloadMT@CRandom@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RandomMT@CRandom@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@@_STL@@YAXPAV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_assign_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pCryptManager@@3PAVCCryptManager@@A		; g_pCryptManager
PUBLIC	?CryptTable@@3PAGA				; CryptTable
_BSS	SEGMENT
?g_pCryptManager@@3PAVCCryptManager@@A DD 01H DUP (?)	; g_pCryptManager
_BSS	ENDS
_DATA	SEGMENT
?CryptTable@@3PAGA DW 01d23H				; CryptTable
	DW	0261bH
	DW	01b1eH
	DW	02028H
	DW	03e2fH
	DW	04136H
	DW	04752H
	DW	04938H
	DW	0293eH
	DW	02f3aH
	DW	02e1eH
	DW	02523H
	DW	02833H
	DW	03e33H
	DW	03734H
	DW	03a42H
	DW	04c41H
	DW	02e44H
	DW	03238H
	DW	03125H
	DW	0282bH
	DW	03033H
	DW	03d2fH
	DW	02b39H
	DW	03539H
	DW	03527H
	DW	02931H
	DW	03337H
	DW	03224H
	DW	01c2cH
	DW	0242aH
	DW	02517H
	DW	0141fH
	DW	01a20H
	DW	03326H
	DW	0242bH
	DW	02a30H
	DW	0281cH
	DW	01222H
	DW	0181eH
	DW	02618H
	DW	01c20H
	DW	02228H
	DW	02317H
	DW	0d1dH
	DW	01319H
	DW	0d01H
	DW	0907H
	DW	01219H
	DW	02818H
	DW	02521H
	DW	02e35H
	DW	05847H
	DW	02b4fH
	DW	0333cH
	DW	03e2dH
	DW	02e35H
	DW	03841H
	DW	04835H
	DW	02c3fH
	DW	0363fH
	DW	0412cH
	DW	02e38H
	DW	03a43H
	DW	04530H
	DW	0633cH
	DW	06d79H
	DW	07e66H
	DW	04e72H
	DW	05a66H
	DW	0533dH
	DW	03e47H
	DW	04652H
	DW	03827H
	DW	0222dH
	DW	02732H
	DW	03b2bH
	DW	02130H
	DW	02631H
	DW	02818H
	DW	0201dH
	DW	02530H
	DW	03021H
	DW	01e28H
	DW	0252dH
	DW	02c1dH
	DW	01924H
	DW	02229H
	DW	03323H
	DW	0402cH
	DW	04950H
	DW	03827H
	DW	02fH
	DW	07H
	DW	04735H
	DW	04940H
	DW	0585dH
	DW	06c57H
	DW	02f69H
	DW	03e43H
	DW	0543eH
	DW	0504fH
	DW	05f64H
	DW	0614dH
	DW	04a5cH
	DW	0595eH
	DW	04d38H
	DW	03345H
	DW	04247H
	DW	04e3aH
	DW	02d49H
	DW	03c41H
	DW	01e0aH
	DW	019H
	DW	01013H
	DW	0230eH
	DW	04220H
	DW	05457H
	DW	03d29H
	DW	01938H
	DW	0232cH
	DW	02a17H
	DW	06121H
	DW	06b74H
	DW	05f4dH
	DW	04758H
	DW	0575aH
	DW	04a37H
	DW	02e47H
	DW	03f40H
	DW	03a28H
	DW	03b39H
	DW	0494cH
	DW	03122H
	DW	04e2dH
	DW	05159H
	DW	07068H
	DW	06365H
	DW	05968H
	DW	07a78H
	DW	04067H
	DW	02b3fH
	DW	0353aH
	DW	03d20H
	DW	02034H
	DW	03947H
	DW	04326H
	DW	02036H
	DW	03643H
	DW	03e20H
	DW	01c34H
	DW	03640H
	DW	03e1eH
	DW	01a35H
	DW	0363fH
	DW	0401bH
	DW	01c37H
	DW	0333cH
	DW	03f18H
	DW	01934H
	DW	0343fH
	DW	03e19H
	DW	01a32H
	DW	03642H
	DW	0441eH
	DW	02137H
	DW	0313dH
	DW	04219H
	DW	01c37H
	DW	03740H
	DW	03e1cH
	DW	01a35H
	DW	03841H
	DW	03d1dH
	DW	01934H
	DW	0343dH
	DW	03a19H
	DW	01631H
	DW	0323bH
	DW	03c17H
	DW	01a32H
	DW	0303aH
	DW	03718H
	DW	0182fH
	DW	03038H
	DW	03b19H
	DW	01c33H
	DW	0343cH
	DW	03b1dH
	DW	01e32H
	DW	0323aH
	DW	03c1bH
	DW	01d34H
	DW	0333aH
	DW	0391aH
	DW	01932H
	DW	0343bH
	DW	03c1bH
	DW	01c35H
	DW	0343bH
	DW	03b1bH
	DW	01b34H
	DW	0353cH
	DW	03c1cH
	DW	01c35H
	DW	0363dH
	DW	03a1dH
	DW	01a33H
	DW	0343bH
	DW	03d1bH
	DW	01d36H
	DW	03138H
	DW	03f18H
	DW	01f38H
	DW	0353cH
	DW	0391cH
	DW	01c33H
	DW	0353bH
	DW	03b1eH
	DW	01d36H
	DW	0363bH
	DW	03c1dH
	DW	01e37H
	DW	0393dH
	DW	03e1dH
	DW	01e3aH
	DW	0393dH
	DW	03f1dH
	DW	01d38H
	DW	0383fH
	DW	03f1dH
	DW	01d38H
	DW	0383fH
	DW	03e1dH
	DW	01e37H
	DW	0383fH
	DW	0401fH
	DW	02138H
	DW	03840H
	DW	03f21H
	DW	02037H
	DW	03c44H
	DW	04125H
	DW	02239H
	DW	0373fH
	DW	04320H
	DW	0243bH
	DW	03941H
	DW	03e22H
	DW	01f36H
	DW	03b43H
	DW	04024H
	DW	02138H
	DW	0373fH
	DW	04020H
	DW	02138H
	DW	03a42H
	DW	04223H
	DW	0233aH
	DW	03a41H
	DW	04021H
	DW	02039H
	DW	03b42H
	DW	04122H
	DW	0233cH
	DW	03a3fH
	DW	03721H
	DW	01932H
	DW	03d42H
	DW	04224H
	DW	0243dH
	DW	03b40H
	DW	04222H
	DW	0243dH
	DW	03d42H
	DW	04024H
	DW	0223bH
	DW	03c41H
	DW	04023H
	DW	0223bH
	DW	0393eH
	DW	03f20H
	DW	0213aH
	DW	03b41H
	DW	04224H
	DW	0253cH
	DW	03b41H
	DW	03e24H
	DW	0213aH
	DW	03a3eH
	DW	04021H
	DW	0233cH
	DW	03d41H
	DW	04024H
	DW	0233cH
	DW	03b3fH
	DW	03f22H
	DW	0213aH
	DW	03a3eH
	DW	03d21H
	DW	01f38H
	DW	03a3eH
	DW	04021H
	DW	0223bH
	DW	03b3fH
	DW	03d22H
	DW	02039H
	DW	03a3eH
	DW	03f22H
	DW	0233bH
	DW	03339H
	DW	0401cH
	DW	02039H
	DW	0383fH
	DW	03f1fH
	DW	01f38H
	DW	03940H
	DW	04020H
	DW	02039H
	DW	0383fH
	DW	0401fH
	DW	02039H
	DW	03a41H
	DW	04321H
	DW	0233cH
	DW	03b42H
	DW	04122H
	DW	0213aH
	DW	03940H
	DW	03f20H
	DW	01f38H
	DW	0383fH
	DW	0411fH
	DW	0213aH
	DW	03b42H
	DW	04022H
	DW	02039H
	DW	03940H
	DW	04020H
	DW	02138H
	DW	03a41H
	DW	04121H
	DW	02239H
	DW	03a41H
	DW	04021H
	DW	02138H
	DW	03940H
	DW	03f20H
	DW	02037H
	DW	03940H
	DW	03e20H
	DW	01e37H
	DW	0383fH
	DW	0401fH
	DW	02039H
	DW	0383fH
	DW	0401fH
	DW	02039H
	DW	0383fH
	DW	03f1fH
	DW	0213aH
	DW	03a3eH
	DW	03e21H
	DW	02138H
	DW	0363aH
	DW	0391dH
	DW	01c33H
	DW	0373cH
	DW	03f1eH
	DW	02239H
	DW	0383dH
	DW	0421fH
	DW	0243dH
	DW	0393eH
	DW	03b20H
	DW	01d36H
	DW	0373cH
	DW	03f1eH
	DW	01f38H
	DW	0383fH
	DW	0401fH
	DW	02039H
	DW	03a41H
	DW	04121H
	DW	02239H
	DW	0363fH
	DW	03f22H
	DW	02037H
	DW	03840H
	DW	04121H
	DW	02239H
	DW	03a42H
	DW	04123H
	DW	0213aH
	DW	0373eH
	DW	03f1eH
	DW	01f38H
	DW	0373eH
	DW	0411eH
	DW	01f3aH
	DW	0383fH
	DW	0401dH
	DW	01e39H
	DW	0363dH
	DW	0401bH
	DW	01e39H
	DW	0383fH
	DW	03d1dH
	DW	01d39H
	DW	0393dH
	DW	03e1dH
	DW	01c37H
	DW	0373dH
	DW	03e1aH
	DW	01c37H
	DW	03a40H
	DW	0411dH
	DW	01d38H
	DW	0363fH
	DW	0481bH
	DW	0263eH
	DW	03943H
	DW	04221H
	DW	02137H
	DW	03944H
	DW	04023H
	DW	02138H
	DW	0373fH
	DW	03f20H
	DW	02239H
	DW	0383fH
	DW	0431fH
	DW	02139H
	DW	03b45H
	DW	04023H
	DW	01e36H
	DW	03943H
	DW	04221H
	DW	02038H
	DW	0343eH
	DW	0421cH
	DW	02038H
	DW	03640H
	DW	0431eH
	DW	02139H
	DW	03842H
	DW	04220H
	DW	01e39H
	DW	03a43H
	DW	0421fH
	DW	01d3aH
	DW	03a42H
	DW	0431dH
	DW	01d3bH
	DW	03c44H
	DW	0421eH
	DW	01c3aH
	DW	03840H
	DW	0411aH
	DW	01b39H
	DW	03c44H
	DW	0431eH
	DW	01f3eH
	DW	03d43H
	DW	04220H
	DW	01f3cH
	DW	03c43H
	DW	04721H
	DW	0233eH
	DW	03c43H
	DW	04421H
	DW	0203bH
	DW	03d46H
	DW	04722H
	DW	0233eH
	DW	03e47H
	DW	04523H
	DW	0213cH
	DW	03b43H
	DW	0471eH
	DW	0223fH
	DW	03f47H
	DW	04621H
	DW	0203eH
	DW	03e46H
	DW	04820H
	DW	02240H
	DW	03e46H
	DW	04520H
	DW	01f3dH
	DW	03f47H
	DW	04521H
	DW	01f3dH
	DW	03e46H
	DW	04520H
	DW	01f3dH
	DW	03b43H
	DW	0451dH
	DW	01f3dH
	DW	04149H
	DW	04923H
	DW	02341H
	DW	03f47H
	DW	04821H
	DW	0213dH
	DW	03a45H
	DW	0441eH
	DW	01d39H
	DW	03a45H
	DW	0451eH
	DW	01e3aH
	DW	03843H
	DW	0441cH
	DW	01d39H
	DW	03c47H
	DW	04820H
	DW	0213dH
	DW	03d48H
	DW	04a21H
	DW	0233fH
	DW	03a45H
	DW	0431eH
	DW	01c38H
	DW	03a45H
	DW	0441eH
	DW	01e39H
	DW	03944H
	DW	0471dH
	DW	01f40H
	DW	03d43H
	DW	0421aH
	DW	0193cH
	DW	03e44H
	DW	04419H
	DW	01b3eH
	DW	03c42H
	DW	04319H
	DW	01a3dH
	DW	04046H
	DW	0441dH
	DW	01b3eH
	DW	03c42H
	DW	03f19H
	DW	01639H
	DW	0393fH
	DW	04216H
	DW	01a3bH
	DW	03d44H
	DW	0441cH
	DW	01a3bH
	DW	03740H
	DW	04616H
	DW	01c3dH
	DW	03841H
	DW	04117H
	DW	01738H
	DW	03841H
	DW	03f17H
	DW	01536H
	DW	03841H
	DW	04417H
	DW	01c3aH
	DW	03842H
	DW	0401aH
	DW	01836H
	DW	03842H
	DW	0421aH
	DW	01a38H
	DW	0343eH
	DW	03c16H
	DW	01233H
	DW	0353eH
	DW	04114H
	DW	01638H
	DW	03942H
	DW	03e18H
	DW	01836H
	DW	0363eH
	DW	03f18H
	DW	01735H
	DW	0333eH
	DW	03e17H
	DW	01733H
	DW	03742H
	DW	0421bH
	DW	01b37H
	DW	0333eH
	DW	04317H
	DW	01c38H
	DW	0333eH
	DW	03d17H
	DW	01632H
	DW	0323dH
	DW	03f16H
	DW	01834H
	DW	03540H
	DW	03b19H
	DW	01633H
	DW	0333bH
	DW	03e16H
	DW	01936H
	DW	0353dH
	DW	03d18H
	DW	01835H
	DW	0353dH
	DW	03b18H
	DW	01732H
	DW	0313aH
	DW	03c16H
	DW	01833H
	DW	0363fH
	DW	03c1bH
	DW	01631H
	DW	0333eH
	DW	03e18H
	DW	01833H
	DW	0313cH
	DW	03a16H
	DW	0142fH
	DW	0333eH
	DW	04218H
	DW	01c37H
	DW	03540H
	DW	03e19H
	DW	01733H
	DW	0323cH
	DW	03b14H
	DW	01331H
	DW	0333dH
	DW	03d15H
	DW	01334H
	DW	0323bH
	DW	03b11H
	DW	01132H
	DW	0343dH
	DW	03d13H
	DW	01334H
	DW	0333cH
	DW	03f12H
	DW	01735H
	DW	0333dH
	DW	04015H
	DW	01935H
	DW	0313cH
	DW	03c15H
	DW	01531H
	DW	02f3aH
	DW	03813H
	DW	01230H
	DW	03038H
	DW	03912H
	DW	01331H
	DW	0323aH
	DW	03a14H
	DW	01532H
	DW	03139H
	DW	03a14H
	DW	0132fH
	DW	0303bH
	DW	03a14H
	DW	0132fH
	DW	02f37H
	DW	03612H
	DW	0f2bH
	DW	03038H
	DW	03413H
	DW	0e29H
	DW	0333eH
	DW	03918H
	DW	0132eH
	DW	02b36H
	DW	03910H
	DW	0132eH
	DW	02d38H
	DW	03912H
	DW	0132eH
	DW	02f3aH
	DW	03a14H
	DW	0142fH
	DW	02d38H
	DW	03812H
	DW	0112dH
	DW	02d38H
	DW	03611H
	DW	0f2bH
	DW	0323dH
	DW	03916H
	DW	0122eH
	DW	0313cH
	DW	03515H
	DW	0e2aH
	DW	02d38H
	DW	03511H
	DW	0e2aH
	DW	02833H
	DW	0350cH
	DW	0102dH
	DW	02d35H
	DW	03510H
	DW	0102dH
	DW	02f37H
	DW	03a12H
	DW	0132fH
	DW	02e39H
	DW	03512H
	DW	0e2aH
	DW	02833H
	DW	0330cH
	DW	0c28H
	DW	02833H
	DW	0330cH
	DW	0c28H
	DW	02a35H
	DW	0350eH
	DW	0e2aH
	DW	02732H
	DW	03009H
	DW	0824H
	DW	02632H
	DW	0340aH
	DW	0c28H
	DW	02833H
	DW	0320cH
	DW	0b27H
	DW	0242fH
	DW	02f08H
	DW	0824H
	DW	02631H
	DW	0320aH
	DW	0c27H
	DW	02631H
	DW	0300bH
	DW	0a25H
	DW	02833H
	DW	02a0dH
	DW	0621H
	DW	0252eH
	DW	0280aH
	DW	041fH
	DW	0252eH
	DW	02d0aH
	DW	0924H
	DW	0242dH
	DW	02c09H
	DW	0823H
	DW	0222bH
	DW	02b07H
	DW	0722H
	DW	0232cH
	DW	02d08H
	DW	0924H
	DW	0252eH
	DW	02a0aH
	DW	0a23H
	DW	02128H
	DW	02a06H
	DW	0823H
	DW	02027H
	DW	02905H
	DW	0922H
	DW	0252cH
	DW	0280cH
	DW	0a23H
	DW	01f24H
	DW	02306H
	DW	051eH
	DW	02025H
	DW	02a07H
	DW	0b22H
	DW	01e26H
	DW	02407H
	DW	071bH
	DW	01d25H
	DW	02506H
	DW	081cH
	DW	01b24H
	DW	07H
	DW	03022H
	DW	0232cH
	DW	0292cH
	DW	02d24H
	DW	0182aH
	DW	02023H
	DW	02418H
	DW	01f1eH
	DW	0252bH
	DW	04b3eH
	DW	04a43H
	DW	04f5aH
	DW	03d2dH
	DW	01732H
	DW	01b28H
	DW	02918H
	DW	0211cH
	DW	02532H
	DW	03827H
	DW	02d2bH
	DW	0323dH
	DW	04131H
	DW	01d36H
	DW	0242cH
	DW	03526H
	DW	02c2dH
	DW	03238H
	DW	03a2cH
	DW	03c36H
	DW	04749H
	DW	0493bH
	DW	02947H
	DW	0373aH
	DW	03824H
	DW	01b33H
	DW	0262dH
	DW	02e1eH
	DW	01d27H
	DW	0242cH
	DW	04d3fH
	DW	03942H
	DW	03c44H
	DW	02316H
	DW	0121bH
	DW	01921H
	DW	01908H
	DW	01c10H
	DW	0242aH
	DW	02a1cH
	DW	01524H
	DW	01b1eH
	DW	0372bH
	DW	01b31H
	DW	0242bH
	DW	03e2bH
	DW	02135H
	DW	02932H
	DW	01302H
	DW	08H
	DW	0611H
	DW	02c1bH
	DW	01421H
	DW	01a25H
	DW	03f2eH
	DW	03534H
	DW	03b46H
	DW	05541H
	DW	04549H
	DW	04f58H
	DW	04530H
	DW	03d3cH
	DW	04952H
	DW	04530H
	DW	0613cH
	DW	06f79H
	DW	0826bH
	DW	0587aH
	DW	0656dH
	DW	04937H
	DW	03142H
	DW	03a41H
	DW	03827H
	DW	0292fH
	DW	03038H
	DW	02718H
	DW	0131fH
	DW	01a22H
	DW	02b1dH
	DW	02325H
	DW	02e32H
	DW	03223H
	DW	0202eH
	DW	02d31H
	DW	03524H
	DW	03231H
	DW	04146H
	DW	02b16H
	DW	02523H
	DW	0313aH
	DW	06651H
	DW	0415eH
	DW	05055H
	DW	04c38H
	DW	0647H
	DW	01317H
	DW	04b37H
	DW	03246H
	DW	03f43H
	DW	04130H
	DW	02f3dH
	DW	03c40H
	DW	06d5cH
	DW	04969H
	DW	0575aH
	DW	05e4bH
	DW	0605bH
	DW	07073H
	DW	07b66H
	DW	05278H
	DW	06567H
	DW	0240eH
	DW	022H
	DW	01214H
	DW	0462fH
	DW	02642H
	DW	0333bH
	DW	04735H
	DW	05740H
	DW	06468H
	DW	06857H
	DW	04165H
	DW	04f52H
	DW	03f2fH
	DW	03c3eH
	DW	04b4cH
	DW	03e30H
	DW	0323cH
	DW	03d41H
	DW	06051H
	DW	06d58H
	DW	06b77H
	DW	0736bH
	DW	06462H
	DW	05167H
	DW	0504fH
	DW	03736H
	DW	01735H
	DW	0353bH
	DW	03f18H
	DW	01e34H
	DW	0343fH
	DW	03e20H
	DW	01d33H
	DW	03742H
	DW	04621H
	DW	0243cH
	DW	03842H
	DW	04020H
	DW	01c37H
	DW	04049H
	DW	04025H
	DW	01c37H
	DW	03841H
	DW	0411dH
	DW	01d38H
	DW	0353eH
	DW	03e1aH
	DW	01a35H
	DW	03740H
	DW	0401cH
	DW	01e36H
	DW	0343eH
	DW	03d1cH
	DW	01934H
	DW	0363fH
	DW	0401bH
	DW	01c37H
	DW	0363fH
	DW	03e1bH
	DW	01a35H
	DW	0363fH
	DW	03f1bH
	DW	01d35H
	DW	0333dH
	DW	03d1bH
	DW	01b33H
	DW	0343eH
	DW	03f1cH
	DW	01e34H
	DW	02f3aH
	DW	03d19H
	DW	01c32H
	DW	0343fH
	DW	03d1eH
	DW	02034H
	DW	02f37H
	DW	03d18H
	DW	01c32H
	DW	0353fH
	DW	0391dH
	DW	0172fH
	DW	0343eH
	DW	03d1cH
	DW	01b33H
	DW	02e38H
	DW	03f16H
	DW	01d35H
	DW	0333dH
	DW	0391bH
	DW	01932H
	DW	03239H
	DW	03e19H
	DW	01e37H
	DW	03239H
	DW	03c19H
	DW	01f36H
	DW	0353bH
	DW	0391eH
	DW	01c33H
	DW	0373dH
	DW	03e20H
	DW	01f36H
	DW	03941H
	DW	03c22H
	DW	01d34H
	DW	03940H
	DW	03f20H
	DW	01f38H
	DW	0333aH
	DW	03e1aH
	DW	01e37H
	DW	0353cH
	DW	03d1cH
	DW	01d36H
	DW	0363dH
	DW	03e1dH
	DW	01e37H
	DW	03a41H
	DW	04121H
	DW	02239H
	DW	0373fH
	DW	03e20H
	DW	01f36H
	DW	0373fH
	DW	03e20H
	DW	02039H
	DW	03b40H
	DW	04022H
	DW	0223bH
	DW	0393eH
	DW	03f20H
	DW	02239H
	DW	0393fH
	DW	03f22H
	DW	02239H
	DW	03a40H
	DW	03f23H
	DW	0213aH
	DW	03b40H
	DW	04122H
	DW	0213aH
	DW	03c43H
	DW	04223H
	DW	0223bH
	DW	03f46H
	DW	04424H
	DW	0223dH
	DW	03d44H
	DW	03f22H
	DW	0213aH
	DW	04044H
	DW	04228H
	DW	0253eH
	DW	04145H
	DW	04228H
	DW	0243dH
	DW	03b40H
	DW	04222H
	DW	0223bH
	DW	03b42H
	DW	04122H
	DW	0213aH
	DW	03d44H
	DW	04124H
	DW	0243bH
	DW	03a40H
	DW	03d23H
	DW	02037H
	DW	0383fH
	DW	03e24H
	DW	02337H
	DW	0363dH
	DW	04122H
	DW	0243bH
	DW	03b41H
	DW	03d24H
	DW	02037H
	DW	03b41H
	DW	04324H
	DW	0253eH
	DW	03e43H
	DW	04025H
	DW	01e39H
	DW	03f43H
	DW	04423H
	DW	0243dH
	DW	0393eH
	DW	04220H
	DW	0233aH
	DW	03c42H
	DW	03f25H
	DW	02239H
	DW	0373eH
	DW	04023H
	DW	02539H
	DW	03940H
	DW	04025H
	DW	02138H
	DW	0343cH
	DW	0401dH
	DW	02138H
	DW	03941H
	DW	04322H
	DW	0243bH
	DW	03a42H
	DW	04323H
	DW	0233cH
	DW	0373eH
	DW	0441eH
	DW	0243dH
	DW	03a41H
	DW	04221H
	DW	0233aH
	DW	0363eH
	DW	0401fH
	DW	02138H
	DW	03d45H
	DW	04226H
	DW	0233aH
	DW	03a42H
	DW	04123H
	DW	02239H
	DW	03941H
	DW	04122H
	DW	02438H
	DW	03941H
	DW	04022H
	DW	02337H
	DW	0373fH
	DW	04120H
	DW	02438H
	DW	03b43H
	DW	04224H
	DW	02539H
	DW	03e46H
	DW	04227H
	DW	0233aH
	DW	03f47H
	DW	04028H
	DW	02138H
	DW	03941H
	DW	03f22H
	DW	01e34H
	DW	03b43H
	DW	04024H
	DW	02138H
	DW	0373dH
	DW	03f20H
	DW	02236H
	DW	0383eH
	DW	03e21H
	DW	02135H
	DW	0373fH
	DW	04120H
	DW	02438H
	DW	03941H
	DW	04222H
	DW	0233aH
	DW	03840H
	DW	03e21H
	DW	01f36H
	DW	0373fH
	DW	03f20H
	DW	02037H
	DW	03840H
	DW	03f21H
	DW	01f38H
	DW	03940H
	DW	04120H
	DW	02239H
	DW	03840H
	DW	04221H
	DW	0233aH
	DW	03840H
	DW	04321H
	DW	0243bH
	DW	03840H
	DW	04121H
	DW	02239H
	DW	03840H
	DW	03f21H
	DW	01f38H
	DW	03b42H
	DW	04122H
	DW	0213aH
	DW	0373eH
	DW	03e1eH
	DW	01e37H
	DW	03940H
	DW	04220H
	DW	0223bH
	DW	03940H
	DW	03e20H
	DW	02039H
	DW	03a3fH
	DW	04021H
	DW	0223bH
	DW	03a3eH
	DW	0401eH
	DW	0223bH
	DW	04044H
	DW	04024H
	DW	02039H
	DW	0333aH
	DW	0401aH
	DW	02039H
	DW	03b42H
	DW	03e22H
	DW	01e37H
	DW	03b42H
	DW	04022H
	DW	02138H
	DW	03a42H
	DW	04023H
	DW	02138H
	DW	0363eH
	DW	0411fH
	DW	02036H
	DW	03842H
	DW	03f20H
	DW	01f38H
	DW	0383fH
	DW	0421fH
	DW	0223bH
	DW	0363dH
	DW	0421dH
	DW	0223bH
	DW	0373eH
	DW	0401eH
	DW	01e39H
	DW	03b42H
	DW	04120H
	DW	01f3aH
	DW	03940H
	DW	0441eH
	DW	0203bH
	DW	03c45H
	DW	04321H
	DW	01f3aH
	DW	03942H
	DW	0431eH
	DW	01e3bH
	DW	03b43H
	DW	0471eH
	DW	0223fH
	DW	03d45H
	DW	04620H
	DW	0213eH
	DW	03e47H
	DW	04423H
	DW	0203bH
	DW	0414bH
	DW	04929H
	DW	0253dH
	DW	03b45H
	DW	04623H
	DW	0203bH
	DW	03c47H
	DW	04a21H
	DW	0243fH
	DW	0404bH
	DW	04725H
	DW	0223fH
	DW	03e46H
	DW	04f21H
	DW	02844H
	DW	03e49H
	DW	04822H
	DW	0213dH
	DW	0414cH
	DW	04a25H
	DW	0233fH
	DW	03c47H
	DW	04620H
	DW	0213eH
	DW	0424aH
	DW	04725H
	DW	0223fH
	DW	03d45H
	DW	04520H
	DW	0203dH
	DW	04048H
	DW	04b23H
	DW	02643H
	DW	0424aH
	DW	04725H
	DW	0223fH
	DW	03c44H
	DW	0431fH
	DW	01e3bH
	DW	03f47H
	DW	04722H
	DW	0223fH
	DW	03c44H
	DW	04a1fH
	DW	02542H
	DW	03e46H
	DW	04521H
	DW	0213cH
	DW	03f48H
	DW	04524H
	DW	0213cH
	DW	03b44H
	DW	04620H
	DW	0223dH
	DW	03c45H
	DW	04621H
	DW	0223dH
	DW	03942H
	DW	0431eH
	DW	02139H
	DW	03b44H
	DW	04420H
	DW	01e3cH
	DW	03d44H
	DW	0461cH
	DW	01e3fH
	DW	03e44H
	DW	0451bH
	DW	01b3cH
	DW	03942H
	DW	04918H
	DW	01f40H
	DW	03d46H
	DW	0431cH
	DW	0193aH
	DW	03c45H
	DW	0461bH
	DW	01c3dH
	DW	03c45H
	DW	0441bH
	DW	01a3bH
	DW	03b44H
	DW	0461aH
	DW	01b3bH
	DW	03c45H
	DW	0431bH
	DW	01c38H
	DW	03a42H
	DW	0421dH
	DW	01d3aH
	DW	03840H
	DW	0401aH
	DW	01839H
	DW	03b42H
	DW	0411aH
	DW	0193aH
	DW	0363eH
	DW	04218H
	DW	01a38H
	DW	03742H
	DW	0401bH
	DW	01935H
	DW	0333eH
	DW	03e17H
	DW	01634H
	DW	03740H
	DW	03f16H
	DW	01436H
	DW	0353eH
	DW	03f13H
	DW	01738H
	DW	0363dH
	DW	03e15H
	DW	01637H
	DW	0363eH
	DW	03c18H
	DW	01734H
	DW	03a42H
	DW	03e1dH
	DW	01a35H
	DW	03740H
	DW	03f1cH
	DW	01b36H
	DW	03841H
	DW	03c1dH
	DW	01833H
	DW	03941H
	DW	03f1cH
	DW	01834H
	DW	0333dH
	DW	03e15H
	DW	01634H
	DW	0353fH
	DW	04117H
	DW	01937H
	DW	0303aH
	DW	03e12H
	DW	01836H
	DW	0353dH
	DW	03b17H
	DW	01633H
	DW	0353dH
	DW	03818H
	DW	01532H
	DW	0353bH
	DW	03918H
	DW	01431H
	DW	0373fH
	DW	03d1aH
	DW	01835H
	DW	0363eH
	DW	04019H
	DW	01935H
	DW	0313cH
	DW	03e15H
	DW	01733H
	DW	0323dH
	DW	03b16H
	DW	01533H
	DW	0363dH
	DW	04015H
	DW	01839H
	DW	0343bH
	DW	03a13H
	DW	01233H
	DW	0333aH
	DW	03c12H
	DW	01435H
	DW	03138H
	DW	03d10H
	DW	01334H
	DW	02f38H
	DW	03a0eH
	DW	01230H
	DW	0323cH
	DW	03914H
	DW	0112fH
	DW	0333dH
	DW	03815H
	DW	0102eH
	DW	0353fH
	DW	03f17H
	DW	01735H
	DW	0313bH
	DW	03b13H
	DW	01331H
	DW	02f39H
	DW	03811H
	DW	01330H
	DW	0353dH
	DW	03b18H
	DW	01633H
	DW	03139H
	DW	03914H
	DW	01431H
	DW	03137H
	DW	03614H
	DW	0112eH
	DW	02b31H
	DW	0340eH
	DW	0f2cH
	DW	03038H
	DW	03913H
	DW	01431H
	DW	03038H
	DW	03713H
	DW	0122fH
	DW	02d35H
	DW	03910H
	DW	01431H
	DW	02b33H
	DW	0340eH
	DW	0f2cH
	DW	02b33H
	DW	0350eH
	DW	0102dH
	DW	02f37H
	DW	03512H
	DW	0f2dH
	DW	02c34H
	DW	0360eH
	DW	0102eH
	DW	02e36H
	DW	03310H
	DW	0d2bH
	DW	02b33H
	DW	0340dH
	DW	0e2cH
	DW	02a32H
	DW	0340cH
	DW	0d29H
	DW	02a35H
	DW	02c0eH
	DW	0724H
	DW	02c34H
	DW	0330fH
	DW	0e2bH
	DW	02c34H
	DW	02d0fH
	DW	0825H
	DW	02c34H
	DW	0340fH
	DW	0f2cH
	DW	02a32H
	DW	02f0dH
	DW	0927H
	DW	02931H
	DW	02e0bH
	DW	0826H
	DW	02a33H
	DW	03309H
	DW	0b29H
	DW	02a34H
	DW	0300cH
	DW	0925H
	DW	02831H
	DW	0300dH
	DW	0b28H
	DW	0262eH
	DW	02f09H
	DW	0a27H
	DW	0262eH
	DW	02f09H
	DW	0824H
	DW	02631H
	DW	0330aH
	DW	0d28H
	DW	02530H
	DW	02e0aH
	DW	0c24H
	DW	0242eH
	DW	02c0cH
	DW	0823H
	DW	0232cH
	DW	02d08H
	DW	0825H
	DW	0232bH
	DW	02c06H
	DW	0926H
	DW	02229H
	DW	02707H
	DW	0520H
	DW	02229H
	DW	02a09H
	DW	0a23H
	DW	02229H
	DW	02809H
	DW	0920H
	DW	02229H
	DW	02c09H
	DW	0c25H
	DW	0232aH
	DW	0280aH
	DW	0621H
	DW	02229H
	DW	02607H
	DW	0622H
	DW	02024H
	DW	02404H
	DW	061fH
	DW	02126H
	DW	02508H
	DW	0720H
	DW	01f24H
	DW	02606H
	DW	071eH
	DW	01e25H
	DW	02205H
	DW	051cH
	DW	01e24H
	DW	07H
	DW	03126H
	DW	02a2eH
	DW	03033H
	DW	02c23H
	DW	01829H
	DW	02023H
	DW	02416H
	DW	01a1eH
	DW	02026H
	DW	02c1fH
	DW	02324H
	DW	02631H
	DW	03123H
	DW	0e26H
	DW	0121fH
	DW	02918H
	DW	0171cH
	DW	01c29H
	DW	03321H
	DW	01026H
	DW	01824H
	DW	03723H
	DW	0212bH
	DW	02932H
	DW	03c2dH
	DW	03834H
	DW	03e44H
	DW	03a2cH
	DW	02436H
	DW	03032H
	DW	04838H
	DW	03547H
	DW	0474aH
	DW	04732H
	DW	03444H
	DW	04348H
	DW	02f1dH
	DW	01728H
	DW	01e26H
	DW	02416H
	DW	01219H
	DW	0151dH
	DW	02215H
	DW	01f1aH
	DW	0262eH
	DW	01e0eH
	DW	0117H
	DW	0a11H
	DW	01b0dH
	DW	0517H
	DW	0d10H
	DW	0261bH
	DW	02a23H
	DW	0333aH
	DW	0725fH
	DW	04a69H
	DW	0505bH
	DW	02a19H
	DW	0591fH
	DW	05f6aH
	DW	03a29H
	DW	0252fH
	DW	02b36H
	DW	04231H
	DW	04537H
	DW	04b56H
	DW	06756H
	DW	02c5cH
	DW	0363fH
	DW	04f3cH
	DW	04d46H
	DW	05760H
	DW	03520H
	DW	0392cH
	DW	0464eH
	DW	0523dH
	DW	0114aH
	DW	01e26H
	DW	05f4aH
	DW	01657H
	DW	02128H
	DW	01a0aH
	DW	01713H
	DW	02027H
	DW	02818H
	DW	01d21H
	DW	0262dH
	DW	03829H
	DW	02c34H
	DW	0373bH
	DW	03829H
	DW	01934H
	DW	0272aH
	DW	02c18H
	DW	0b27H
	DW	01a1fH
	DW	03923H
	DW	03434H
	DW	0434bH
	DW	04f3aH
	DW	02447H
	DW	02f36H
	DW	04432H
	DW	0123dH
	DW	01f23H
	DW	04938H
	DW	04945H
	DW	0565aH
	DW	04b3aH
	DW	02147H
	DW	02e32H
	DW	03d2cH
	DW	04839H
	DW	05659H
	DW	08675H
	DW	07c83H
	DW	08c8fH
	DW	08e79H
	DW	0758bH
	DW	0878aH
	DW	08570H
	DW	05a82H
	DW	06d71H
	DW	0846fH
	DW	05a81H
	DW	0696eH
	DW	03420H
	DW	0292fH
	DW	0393cH
	DW	06b5aH
	DW	04368H
	DW	05154H
	DW	02110H
	DW	0481dH
	DW	05357H
	DW	07668H
	DW	04f70H
	DW	0525aH
	DW	06e66H
	DW	04063H
	DW	03546H
	DW	02624H
	DW	02e12H
	DW	0162eH
	DW	03c3fH
	DW	03a20H
	DW	01635H
	DW	03941H
	DW	03f1cH
	DW	01d35H
	DW	03742H
	DW	03e21H
	DW	01d33H
	DW	03540H
	DW	0411fH
	DW	01f37H
	DW	03640H
	DW	03c1eH
	DW	01833H
	DW	03942H
	DW	0401eH
	DW	01c37H
	DW	03841H
	DW	0401dH
	DW	01c37H
	DW	0353eH
	DW	03d1aH
	DW	01934H
	DW	0353eH
	DW	03f1aH
	DW	01d35H
	DW	0343eH
	DW	0391cH
	DW	01732H
	DW	0363dH
	DW	0411bH
	DW	01d38H
	DW	03740H
	DW	03e1cH
	DW	01a35H
	DW	0353eH
	DW	03f1aH
	DW	01d35H
	DW	03640H
	DW	03f1eH
	DW	01d35H
	DW	0353fH
	DW	0401dH
	DW	01f35H
	DW	0303bH
	DW	03e1aH
	DW	01d33H
	DW	0343fH
	DW	03e1eH
	DW	01f36H
	DW	0323aH
	DW	03b1bH
	DW	01931H
	DW	0313bH
	DW	03619H
	DW	0142cH
	DW	02f39H
	DW	03c17H
	DW	01a32H
	DW	0303aH
	DW	03d18H
	DW	01b33H
	DW	0303aH
	DW	03a18H
	DW	01a33H
	DW	0343bH
	DW	03f1bH
	DW	01f38H
	DW	0373eH
	DW	03e1eH
	DW	02138H
	DW	0363cH
	DW	03a1fH
	DW	01d34H
	DW	0353bH
	DW	03c1eH
	DW	01d34H
	DW	0363eH
	DW	03c1fH
	DW	01d34H
	DW	03840H
	DW	04021H
	DW	02039H
	DW	0363dH
	DW	0411dH
	DW	0213aH
	DW	03a41H
	DW	03f21H
	DW	01f38H
	DW	03940H
	DW	04020H
	DW	02039H
	DW	03a41H
	DW	04121H
	DW	02239H
	DW	03a42H
	DW	04123H
	DW	02239H
	DW	03941H
	DW	03c22H
	DW	01e37H
	DW	03a3fH
	DW	04021H
	DW	0223bH
	DW	03a3fH
	DW	04021H
	DW	0233aH
	DW	03a40H
	DW	04023H
	DW	0233aH
	DW	03c42H
	DW	04125H
	DW	0233cH
	DW	03e43H
	DW	04325H
	DW	0233cH
	DW	03c43H
	DW	04223H
	DW	0203bH
	DW	03d44H
	DW	04222H
	DW	0203bH
	DW	03a41H
	DW	03d1fH
	DW	01f38H
	DW	03c40H
	DW	03e24H
	DW	0213aH
	DW	03a3eH
	DW	04121H
	DW	0233cH
	DW	03c41H
	DW	04523H
	DW	0253eH
	DW	03d44H
	DW	04024H
	DW	02039H
	DW	03d44H
	DW	04224H
	DW	0253cH
	DW	03b41H
	DW	03d24H
	DW	02236H
	DW	03940H
	DW	03f25H
	DW	02538H
	DW	03940H
	DW	03d25H
	DW	02037H
	DW	03a40H
	DW	04123H
	DW	0243bH
	DW	03b41H
	DW	04424H
	DW	0243dH
	DW	03a41H
	DW	04121H
	DW	01f3aH
	DW	03f46H
	DW	04424H
	DW	0243dH
	DW	03a41H
	DW	04321H
	DW	0243bH
	DW	03d45H
	DW	04026H
	DW	02539H
	DW	0373eH
	DW	03f23H
	DW	02538H
	DW	0383fH
	DW	04124H
	DW	02239H
	DW	0373fH
	DW	03e20H
	DW	01f36H
	DW	03c44H
	DW	04225H
	DW	0233aH
	DW	03d45H
	DW	04126H
	DW	0213aH
	DW	0353cH
	DW	0401cH
	DW	02039H
	DW	03940H
	DW	04120H
	DW	02239H
	DW	03840H
	DW	04121H
	DW	02239H
	DW	03c44H
	DW	04325H
	DW	0243bH
	DW	03b43H
	DW	04124H
	DW	02438H
	DW	0363fH
	DW	03e22H
	DW	02135H
	DW	0353eH
	DW	03d21H
	DW	02034H
	DW	0343dH
	DW	03e20H
	DW	02135H
	DW	0363fH
	DW	03f22H
	DW	02236H
	DW	0363fH
	DW	03d22H
	DW	01e35H
	DW	03941H
	DW	04122H
	DW	02239H
	DW	03941H
	DW	04122H
	DW	02036H
	DW	03843H
	DW	03e22H
	DW	01f36H
	DW	0373fH
	DW	04120H
	DW	02438H
	DW	03a43H
	DW	04126H
	DW	02438H
	DW	03740H
	DW	03f23H
	DW	02236H
	DW	0353eH
	DW	04121H
	DW	02239H
	DW	0373fH
	DW	03e20H
	DW	01f36H
	DW	0373fH
	DW	04120H
	DW	02239H
	DW	03840H
	DW	04021H
	DW	02039H
	DW	03a41H
	DW	04021H
	DW	02138H
	DW	03840H
	DW	04121H
	DW	02239H
	DW	03840H
	DW	04021H
	DW	02138H
	DW	0373fH
	DW	03f20H
	DW	02037H
	DW	0373fH
	DW	04220H
	DW	0223bH
	DW	03b42H
	DW	04122H
	DW	0213aH
	DW	0373eH
	DW	03e1eH
	DW	01e37H
	DW	0383fH
	DW	03f1fH
	DW	01f38H
	DW	0363dH
	DW	0401dH
	DW	0233aH
	DW	03b41H
	DW	04024H
	DW	0223bH
	DW	03b40H
	DW	03f22H
	DW	0213aH
	DW	03a3fH
	DW	03f21H
	DW	0213aH
	DW	03a3fH
	DW	03e21H
	DW	01e37H
	DW	03a41H
	DW	03f21H
	DW	01f38H
	DW	03940H
	DW	04020H
	DW	02138H
	DW	03840H
	DW	04221H
	DW	02539H
	DW	03941H
	DW	04322H
	DW	02238H
	DW	03742H
	DW	04021H
	DW	02039H
	DW	0373eH
	DW	0421eH
	DW	0223bH
	DW	03940H
	DW	04120H
	DW	0233cH
	DW	03b40H
	DW	03e22H
	DW	01c37H
	DW	03940H
	DW	0401eH
	DW	01e39H
	DW	03940H
	DW	0451eH
	DW	0233bH
	DW	03a44H
	DW	04122H
	DW	01f37H
	DW	0353eH
	DW	0431aH
	DW	01e3bH
	DW	03c44H
	DW	0441fH
	DW	01f3cH
	DW	03d45H
	DW	04720H
	DW	0233eH
	DW	03d46H
	DW	04822H
	DW	0243cH
	DW	03e4aH
	DW	04826H
	DW	0243cH
	DW	03c48H
	DW	04924H
	DW	0233eH
	DW	03e49H
	DW	04923H
	DW	0233eH
	DW	03e49H
	DW	04723H
	DW	0223fH
	DW	03f47H
	DW	04a22H
	DW	0233fH
	DW	03b46H
	DW	0471fH
	DW	0203cH
_DATA	ENDS
PUBLIC	??0CCryptManager@@QAE@XZ			; CCryptManager::CCryptManager
; Function compile flags: /Ogsy
; File c:\darkeden\designed_common\project\client\packet\crypt.cpp
;	COMDAT ??0CCryptManager@@QAE@XZ
_TEXT	SEGMENT
??0CCryptManager@@QAE@XZ PROC NEAR			; CCryptManager::CCryptManager, COMDAT
; _this$ = ecx

; 236  : {

  00000	8b c1		 mov	 eax, ecx

; 237  : 	m_pCryptTable = NULL;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 238  : 	m_nTableSize = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 239  : 	m_nTotalSize = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 240  : 	m_dwMakeRandKey = 0;		

  0000c	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 241  : 	m_pRandomTable = NULL;

  0000f	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 242  : }

  00012	c3		 ret	 0
??0CCryptManager@@QAE@XZ ENDP				; CCryptManager::CCryptManager
_TEXT	ENDS
PUBLIC	??1CCryptManager@@QAE@XZ			; CCryptManager::~CCryptManager
; Function compile flags: /Ogsy
;	COMDAT ??1CCryptManager@@QAE@XZ
_TEXT	SEGMENT
??1CCryptManager@@QAE@XZ PROC NEAR			; CCryptManager::~CCryptManager, COMDAT
; _this$ = ecx

; 246  : }

  00000	c3		 ret	 0
??1CCryptManager@@QAE@XZ ENDP				; CCryptManager::~CCryptManager
_TEXT	ENDS
PUBLIC	?GetRandKey@CCryptManager@@IAEHXZ		; CCryptManager::GetRandKey
EXTRN	_rand:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?GetRandKey@CCryptManager@@IAEHXZ
_TEXT	SEGMENT
?GetRandKey@CCryptManager@@IAEHXZ PROC NEAR		; CCryptManager::GetRandKey, COMDAT
; _this$ = ecx

; 253  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 254  : 	return (rand() % m_nTableSize);

  00003	e8 00 00 00 00	 call	 _rand
  00008	99		 cdq
  00009	f7 7e 04	 idiv	 DWORD PTR [esi+4]
  0000c	5e		 pop	 esi
  0000d	8b c2		 mov	 eax, edx

; 255  : }

  0000f	c3		 ret	 0
?GetRandKey@CCryptManager@@IAEHXZ ENDP			; CCryptManager::GetRandKey
_TEXT	ENDS
PUBLIC	?LoadTable@CCryptManager@@IAEHXZ		; CCryptManager::LoadTable
; Function compile flags: /Ogsy
;	COMDAT ?LoadTable@CCryptManager@@IAEHXZ
_TEXT	SEGMENT
?LoadTable@CCryptManager@@IAEHXZ PROC NEAR		; CCryptManager::LoadTable, COMDAT
; _this$ = ecx

; 259  : 	m_nTotalSize = 4096;
; 260  : 	if(m_nTotalSize == 0)
; 261  : 		return false;
; 262  : 
; 263  : 	m_nTableSize = m_nTotalSize / MAX_TABLE_DATA_SIZE;
; 264  : 	if(m_nTableSize > MAX_CRYPT_TABLE_SIZE)
; 265  : 		return false;
; 266  : 
; 267  : 	m_pCryptTable = (BYTE*) CryptTable;
; 268  : 	if(m_pCryptTable == NULL)
; 269  : 		return false;
; 270  : 
; 271  : 	return TRUE;

  00000	33 c0		 xor	 eax, eax
  00002	c7 41 08 00 10
	00 00		 mov	 DWORD PTR [ecx+8], 4096	; 00001000H
  00009	c7 41 04 10 00
	00 00		 mov	 DWORD PTR [ecx+4], 16	; 00000010H
  00010	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:?CryptTable@@3PAGA ; CryptTable
  00016	40		 inc	 eax

; 272  : }

  00017	c3		 ret	 0
?LoadTable@CCryptManager@@IAEHXZ ENDP			; CCryptManager::LoadTable
_TEXT	ENDS
PUBLIC	?GetKey@CCryptManager@@QAEKXZ			; CCryptManager::GetKey
; Function compile flags: /Ogsy
;	COMDAT ?GetKey@CCryptManager@@QAEKXZ
_TEXT	SEGMENT
tv91 = -8						; size = 4
tv89 = -8						; size = 4
tv86 = -4						; size = 4
?GetKey@CCryptManager@@QAEKXZ PROC NEAR			; CCryptManager::GetKey, COMDAT
; _this$ = ecx

; 322  : {

  00000	51		 push	 ecx
  00001	51		 push	 ecx
  00002	53		 push	 ebx
  00003	55		 push	 ebp
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b e9		 mov	 ebp, ecx

; 323  : 	//// 罚待虐 积己
; 324  : 	KEY_TYPE key;
; 325  : 	key.KeyValue.key1 = GetRandKey();

  00008	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey

; 326  : 	key.KeyValue.key2 = GetRandKey();

  0000d	8b cd		 mov	 ecx, ebp
  0000f	8b f0		 mov	 esi, eax
  00011	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey

; 327  : 	key.KeyValue.key3 = GetRandKey();

  00016	8b cd		 mov	 ecx, ebp
  00018	8b f8		 mov	 edi, eax
  0001a	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey

; 328  : 	key.KeyValue.key4 = GetRandKey();

  0001f	8b cd		 mov	 ecx, ebp
  00021	8b d8		 mov	 ebx, eax
  00023	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey
  00028	89 44 24 14	 mov	 DWORD PTR tv86[esp+24], eax

; 329  : 	key.KeyValue.index = rand() % MAX_TABLE_DATA_SIZE;

  0002c	e8 00 00 00 00	 call	 _rand
  00031	8b e8		 mov	 ebp, eax

; 330  : 	key.KeyValue.type = rand() % CRYPT_TYPE3;

  00033	e8 00 00 00 00	 call	 _rand
  00038	99		 cdq
  00039	6a 08		 push	 8
  0003b	59		 pop	 ecx
  0003c	f7 f9		 idiv	 ecx
  0003e	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H

; 331  : 	return key.dwKey;

  00043	6a 1f		 push	 31			; 0000001fH
  00045	8b c2		 mov	 eax, edx
  00047	c1 e0 08	 shl	 eax, 8
  0004a	89 44 24 14	 mov	 DWORD PTR tv91[esp+28], eax
  0004e	8b c5		 mov	 eax, ebp
  00050	99		 cdq
  00051	f7 f9		 idiv	 ecx
  00053	8b 44 24 14	 mov	 eax, DWORD PTR tv91[esp+28]
  00057	59		 pop	 ecx
  00058	23 d9		 and	 ebx, ecx
  0005a	23 f9		 and	 edi, ecx
  0005c	23 f1		 and	 esi, ecx
  0005e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00064	0b c2		 or	 eax, edx
  00066	c1 e0 05	 shl	 eax, 5
  00069	8b d0		 mov	 edx, eax
  0006b	8b 44 24 14	 mov	 eax, DWORD PTR tv86[esp+24]
  0006f	23 c1		 and	 eax, ecx
  00071	0b d0		 or	 edx, eax
  00073	c1 e2 05	 shl	 edx, 5
  00076	0b d3		 or	 edx, ebx
  00078	c1 e2 05	 shl	 edx, 5
  0007b	0b d7		 or	 edx, edi
  0007d	5f		 pop	 edi
  0007e	c1 e2 05	 shl	 edx, 5
  00081	0b d6		 or	 edx, esi
  00083	5e		 pop	 esi
  00084	5d		 pop	 ebp
  00085	8b c2		 mov	 eax, edx
  00087	5b		 pop	 ebx

; 332  : }

  00088	59		 pop	 ecx
  00089	59		 pop	 ecx
  0008a	c3		 ret	 0
?GetKey@CCryptManager@@QAEKXZ ENDP			; CCryptManager::GetKey
_TEXT	ENDS
PUBLIC	?EncryptHeader@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ; CCryptManager::EncryptHeader
; Function compile flags: /Ogsy
;	COMDAT ?EncryptHeader@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?EncryptHeader@CCryptManager@@QAEXPAU_PACKETDATA@@@Z PROC NEAR ; CCryptManager::EncryptHeader, COMDAT
; _this$ = ecx

; 335  : {

  00000	56		 push	 esi

; 336  : 	data->m_Key.dwKey = GetKey();

  00001	e8 00 00 00 00	 call	 ?GetKey@CCryptManager@@QAEKXZ ; CCryptManager::GetKey
  00006	8b 4c 24 08	 mov	 ecx, DWORD PTR _data$[esp]

; 337  : 	data->m_wMsgType = (WORD)(data->m_wMsgType ^ data->m_Key.dwKey ^ CRYPTION_KEY);
; 338  : 	data->m_wMsgSize = (DWORD)(data->m_wMsgSize ^ data->m_Key.dwKey ^ CRYPTION_KEY);

  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	33 d2		 xor	 edx, edx
  0000e	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00012	66 33 d0	 xor	 dx, ax
  00015	33 f0		 xor	 esi, eax
  00017	89 41 06	 mov	 DWORD PTR [ecx+6], eax
  0001a	81 f2 61 73 00
	00		 xor	 edx, 29537		; 00007361H
  00020	66 89 51 04	 mov	 WORD PTR [ecx+4], dx
  00024	ba 61 73 86 35	 mov	 edx, 898003809		; 35867361H
  00029	33 f2		 xor	 esi, edx

; 339  : 	data->m_Key.dwKey = (DWORD)(data->m_Key.dwKey ^ CRYPTION_KEY);

  0002b	33 c2		 xor	 eax, edx
  0002d	89 31		 mov	 DWORD PTR [ecx], esi
  0002f	89 41 06	 mov	 DWORD PTR [ecx+6], eax
  00032	5e		 pop	 esi

; 340  : 
; 341  : //	m_Rand1->srand(data->m_Key.dwKey);
; 342  : }

  00033	c2 04 00	 ret	 4
?EncryptHeader@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ENDP ; CCryptManager::EncryptHeader
_TEXT	ENDS
PUBLIC	?DecryptHeader@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ; CCryptManager::DecryptHeader
; Function compile flags: /Ogsy
;	COMDAT ?DecryptHeader@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?DecryptHeader@CCryptManager@@QAEXPAU_PACKETDATA@@@Z PROC NEAR ; CCryptManager::DecryptHeader, COMDAT
; _this$ = ecx

; 347  : 	data->m_Key.dwKey = (DWORD)(data->m_Key.dwKey ^ CRYPTION_KEY);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _data$[esp-4]
  00004	56		 push	 esi

; 348  : 	data->m_wMsgType = (WORD)(data->m_wMsgType ^ data->m_Key.dwKey ^ CRYPTION_KEY);

  00005	33 f6		 xor	 esi, esi
  00007	b9 61 73 86 35	 mov	 ecx, 898003809		; 35867361H
  0000c	31 48 06	 xor	 DWORD PTR [eax+6], ecx
  0000f	8b 50 06	 mov	 edx, DWORD PTR [eax+6]
  00012	66 8b f2	 mov	 si, dx
  00015	66 33 70 04	 xor	 si, WORD PTR [eax+4]
  00019	81 f6 61 73 00
	00		 xor	 esi, 29537		; 00007361H
  0001f	66 89 70 04	 mov	 WORD PTR [eax+4], si

; 349  : 	data->m_wMsgSize = (DWORD)(data->m_wMsgSize ^ data->m_Key.dwKey ^ CRYPTION_KEY);

  00023	8b 30		 mov	 esi, DWORD PTR [eax]
  00025	33 f2		 xor	 esi, edx
  00027	33 f1		 xor	 esi, ecx
  00029	89 30		 mov	 DWORD PTR [eax], esi
  0002b	5e		 pop	 esi

; 350  : //	m_Rand1->srand(data->m_Key.dwKey);
; 351  : }

  0002c	c2 04 00	 ret	 4
?DecryptHeader@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ENDP ; CCryptManager::DecryptHeader
_TEXT	ENDS
PUBLIC	?Encrypt1@CCryptManager@@QAEXPAU_PACKETDATA@@@Z	; CCryptManager::Encrypt1
; Function compile flags: /Ogsy
;	COMDAT ?Encrypt1@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT
tv345 = -28						; size = 4
tv335 = -24						; size = 4
tv325 = -20						; size = 4
tv247 = -16						; size = 4
tv86 = -16						; size = 4
_this$ = -12						; size = 4
_iPtr$ = -8						; size = 4
_index$ = -1						; size = 1
_data$ = 8						; size = 4
?Encrypt1@CCryptManager@@QAEXPAU_PACKETDATA@@@Z PROC NEAR ; CCryptManager::Encrypt1, COMDAT
; _this$ = ecx

; 467  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 468  : 	KEY_TYPE key;
; 469  : 	int iEncryptSize = 0;
; 470  : 	int iPtr = 0;

  00006	83 65 f8 00	 and	 DWORD PTR _iPtr$[ebp], 0
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	8b d9		 mov	 ebx, ecx
  0000e	57		 push	 edi
  0000f	89 5d f4	 mov	 DWORD PTR _this$[ebp], ebx

; 471  : 	BYTE index = 0;
; 472  : 	TABLE_VALUE vt;
; 473  : 
; 474  : 	// 罚待虐 积己
; 475  : 	key.KeyValue.key1 = GetRandKey();

  00012	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey

; 476  : 	key.KeyValue.key2 = GetRandKey();

  00017	8b cb		 mov	 ecx, ebx
  00019	8b f0		 mov	 esi, eax
  0001b	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey

; 477  : 	key.KeyValue.key3 = GetRandKey();

  00020	8b cb		 mov	 ecx, ebx
  00022	8b f8		 mov	 edi, eax
  00024	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey

; 478  : 	key.KeyValue.key4 = GetRandKey();

  00029	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b d8		 mov	 ebx, eax
  0002e	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey
  00033	89 45 f0	 mov	 DWORD PTR tv86[ebp], eax

; 479  : 	key.KeyValue.index = rand() % MAX_TABLE_DATA_SIZE;

  00036	e8 00 00 00 00	 call	 _rand
  0003b	99		 cdq
  0003c	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00041	f7 f9		 idiv	 ecx

; 480  : 	key.KeyValue.type = CRYPT_TYPE1;

  00043	6a 1f		 push	 31			; 0000001fH
  00045	58		 pop	 eax
  00046	23 d8		 and	 ebx, eax
  00048	23 f8		 and	 edi, eax

; 521  : //#ifdef __LINUX__
; 522  : 	data->m_Key.dwKey = key.dwKey;// ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;

  0004a	23 f0		 and	 esi, eax
  0004c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00052	0b d1		 or	 edx, ecx
  00054	8b 4d f0	 mov	 ecx, DWORD PTR tv86[ebp]
  00057	c1 e2 05	 shl	 edx, 5
  0005a	23 c8		 and	 ecx, eax
  0005c	0b d1		 or	 edx, ecx
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00061	c1 e2 05	 shl	 edx, 5
  00064	0b d3		 or	 edx, ebx
  00066	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00068	c1 e2 05	 shl	 edx, 5
  0006b	0b d7		 or	 edx, edi
  0006d	c1 e2 05	 shl	 edx, 5
  00070	0b d6		 or	 edx, esi
  00072	f6 c3 03	 test	 bl, 3
  00075	74 05		 je	 SHORT $L99697
  00077	83 c3 04	 add	 ebx, 4
  0007a	89 19		 mov	 DWORD PTR [ecx], ebx
$L99697:
  0007c	8b 31		 mov	 esi, DWORD PTR [ecx]
  0007e	8b da		 mov	 ebx, edx
  00080	c1 ee 02	 shr	 esi, 2
  00083	c1 eb 14	 shr	 ebx, 20			; 00000014H
  00086	85 f6		 test	 esi, esi
  00088	88 5d ff	 mov	 BYTE PTR _index$[ebp], bl
  0008b	0f 8e 8d 00 00
	00		 jle	 $L99703
  00091	8b ca		 mov	 ecx, edx
  00093	c1 e9 05	 shr	 ecx, 5
  00096	23 c8		 and	 ecx, eax
  00098	c1 e1 08	 shl	 ecx, 8
  0009b	89 4d ec	 mov	 DWORD PTR tv325[ebp], ecx
  0009e	8b ca		 mov	 ecx, edx
  000a0	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  000a3	23 c8		 and	 ecx, eax
  000a5	c1 e1 08	 shl	 ecx, 8
  000a8	8b fa		 mov	 edi, edx
  000aa	c1 ef 0a	 shr	 edi, 10			; 0000000aH
  000ad	89 4d e8	 mov	 DWORD PTR tv335[ebp], ecx
  000b0	23 f8		 and	 edi, eax
  000b2	8b ca		 mov	 ecx, edx
  000b4	23 c8		 and	 ecx, eax
  000b6	c1 e7 08	 shl	 edi, 8
  000b9	c1 e1 08	 shl	 ecx, 8
  000bc	89 4d e4	 mov	 DWORD PTR tv345[ebp], ecx
  000bf	89 75 f0	 mov	 DWORD PTR tv247[ebp], esi
$L100540:
  000c2	0f b6 75 ff	 movzx	 esi, BYTE PTR _index$[ebp]
  000c6	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	8b 00		 mov	 eax, DWORD PTR [eax]
  000cb	33 db		 xor	 ebx, ebx
  000cd	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  000d0	8a 3c 39	 mov	 bh, BYTE PTR [ecx+edi]
  000d3	8b 4d ec	 mov	 ecx, DWORD PTR tv325[ebp]
  000d6	03 ce		 add	 ecx, esi
  000d8	8a 1c 01	 mov	 bl, BYTE PTR [ecx+eax]
  000db	8b 4d e8	 mov	 ecx, DWORD PTR tv335[ebp]
  000de	03 ce		 add	 ecx, esi
  000e0	0f b6 0c 01	 movzx	 ecx, BYTE PTR [ecx+eax]
  000e4	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000e7	81 e3 ff ff 00
	00		 and	 ebx, 65535		; 0000ffffH
  000ed	0b d9		 or	 ebx, ecx
  000ef	8b 4d e4	 mov	 ecx, DWORD PTR tv345[ebp]
  000f2	03 ce		 add	 ecx, esi
  000f4	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  000f8	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000fb	c1 e3 08	 shl	 ebx, 8
  000fe	0b d8		 or	 ebx, eax
  00100	8b 41 0a	 mov	 eax, DWORD PTR [ecx+10]
  00103	8b f3		 mov	 esi, ebx
  00105	8b 5d f8	 mov	 ebx, DWORD PTR _iPtr$[ebp]
  00108	83 45 f8 04	 add	 DWORD PTR _iPtr$[ebp], 4
  0010c	03 c3		 add	 eax, ebx
  0010e	8b 18		 mov	 ebx, DWORD PTR [eax]
  00110	33 de		 xor	 ebx, esi
  00112	33 da		 xor	 ebx, edx
  00114	fe 45 ff	 inc	 BYTE PTR _index$[ebp]
  00117	ff 4d f0	 dec	 DWORD PTR tv247[ebp]
  0011a	89 18		 mov	 DWORD PTR [eax], ebx
  0011c	75 a4		 jne	 SHORT $L100540
$L99703:

; 481  : 
; 482  : 	// 4官捞飘肺 单捞鸥甫 嘎冕促.
; 483  : 	int iMod = data->m_wMsgSize % sizeof(DWORD);
; 484  : 	if(iMod)
; 485  : 		data->m_wMsgSize = (data->m_wMsgSize + sizeof(DWORD)); 
; 486  : 
; 487  : 	// 鞠龋拳且 辨捞甫 备茄促.
; 488  : 	iEncryptSize = data->m_wMsgSize / sizeof(DWORD);
; 489  : 
; 490  : 	index = key.KeyValue.index;
; 491  : 
; 492  : 	for(int i = 0; i < iEncryptSize; i++)
; 493  : 	{
; 494  : 		// 摹券且 蔼阑 抛捞喉俊辑 父电促.
; 495  : 		vt.Value.value1 = *(m_pCryptTable + index + (key.KeyValue.key1 * MAX_TABLE_DATA_SIZE));
; 496  : 		vt.Value.value2 = *(m_pCryptTable + index + (key.KeyValue.key2 * MAX_TABLE_DATA_SIZE));
; 497  : 		vt.Value.value3 = *(m_pCryptTable + index + (key.KeyValue.key3 * MAX_TABLE_DATA_SIZE));
; 498  : 		vt.Value.value4 = *(m_pCryptTable + index + (key.KeyValue.key4 * MAX_TABLE_DATA_SIZE));
; 499  : 
; 500  : 	//CString str;
; 501  : 	//str.Format("%d %d %d %d", key.KeyValue.key1
; 502  : 	//	,key.KeyValue.key2
; 503  : 	//	,key.KeyValue.key3
; 504  : 	//	,key.KeyValue.key4);
; 505  : 	//MessageBox(NULL, str, "", MB_OK);
; 506  : 	//str.Format("%d %d %d %d", vt.Value.value1
; 507  : 	//	,vt.Value.value2
; 508  : 	//	,vt.Value.value3
; 509  : 	//	,vt.Value.value4);
; 510  : 	//MessageBox(NULL, str, "", MB_OK);
; 511  : 	//str.Format("%d", vt.dwValue);
; 512  : 	//MessageBox(NULL, str, "", MB_OK);
; 513  : 		*((DWORD*)(data->m_Buffer + iPtr)) = *((DWORD*)(data->m_Buffer + iPtr)) ^ key.dwKey ^ vt.dwValue;
; 514  : 
; 515  : 		index++;
; 516  : 		iPtr += 4;
; 517  : 	}
; 518  : 
; 519  : //	data->m_wMsgType = data->m_wMsgType ^ key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 520  : 	data->m_wMsgType = (WORD)(data->m_wMsgType ^ key.dwKey ^ CRYPTION_KEY);

  0011e	33 c0		 xor	 eax, eax
  00120	66 8b 41 04	 mov	 ax, WORD PTR [ecx+4]
  00124	66 33 c2	 xor	 ax, dx
  00127	5f		 pop	 edi
  00128	5e		 pop	 esi

; 521  : //#ifdef __LINUX__
; 522  : 	data->m_Key.dwKey = key.dwKey;// ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;

  00129	89 51 06	 mov	 DWORD PTR [ecx+6], edx
  0012c	5b		 pop	 ebx
  0012d	35 61 73 00 00	 xor	 eax, 29537		; 00007361H
  00132	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 523  : //#else
; 524  : //	data->m_Key.dwKey = _lrotl(key.dwKey, *(data->m_Buffer)%32) ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 525  : //#endif
; 526  : }

  00136	c9		 leave
  00137	c2 04 00	 ret	 4
?Encrypt1@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ENDP	; CCryptManager::Encrypt1
_TEXT	ENDS
PUBLIC	?Decrypt1@CCryptManager@@QAEXPAU_PACKETDATA@@@Z	; CCryptManager::Decrypt1
; Function compile flags: /Ogsy
;	COMDAT ?Decrypt1@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT
_key$ = -28						; size = 4
tv266 = -24						; size = 4
tv256 = -20						; size = 4
_this$ = -16						; size = 4
tv191 = -12						; size = 4
_iPtr$ = -8						; size = 4
_index$ = -1						; size = 1
_data$ = 8						; size = 4
?Decrypt1@CCryptManager@@QAEXPAU_PACKETDATA@@@Z PROC NEAR ; CCryptManager::Decrypt1, COMDAT
; _this$ = ecx

; 529  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 530  : 	KEY_TYPE key;
; 531  : 	int iEncryptSize = 0;
; 532  : 	int iPtr = 0;

  00006	83 65 f8 00	 and	 DWORD PTR _iPtr$[ebp], 0
  0000a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 533  : 	BYTE index = 0;
; 534  : 	TABLE_VALUE vt;
; 535  : 	vt.dwValue = 0;
; 536  : 
; 537  : 	// Decrypt 窃荐肺 颗辫.
; 538  : 	//data->m_Key.dwKey = data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 539  : 	//data->m_Key.dwKey = _lrotr(data->m_Key.dwKey, *(data->m_Buffer)%32);
; 540  : 	key.dwKey = data->m_Key.dwKey;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00010	8b 51 06	 mov	 edx, DWORD PTR [ecx+6]

; 541  : //	data->m_wMsgType = data->m_wMsgType ^ key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 542  : 
; 543  : 
; 544  : 	// 鞠龋秦力 且 辨捞甫 备茄促.
; 545  : 	iEncryptSize = (data->m_wMsgSize) / sizeof(DWORD);

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	53		 push	 ebx

; 546  : 
; 547  : 	index = key.KeyValue.index;

  00016	8b da		 mov	 ebx, edx
  00018	c1 e8 02	 shr	 eax, 2
  0001b	c1 eb 14	 shr	 ebx, 20			; 00000014H

; 548  : 
; 549  : 	for(int i = 0; i < iEncryptSize; i++)

  0001e	85 c0		 test	 eax, eax
  00020	89 55 e4	 mov	 DWORD PTR _key$[ebp], edx
  00023	88 5d ff	 mov	 BYTE PTR _index$[ebp], bl
  00026	0f 8e 8e 00 00
	00		 jle	 $L99720
  0002c	56		 push	 esi
  0002d	57		 push	 edi
  0002e	6a 1f		 push	 31			; 0000001fH
  00030	5b		 pop	 ebx
  00031	8b ca		 mov	 ecx, edx
  00033	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00036	23 cb		 and	 ecx, ebx
  00038	c1 e1 08	 shl	 ecx, 8
  0003b	8b f2		 mov	 esi, edx
  0003d	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  00040	8b fa		 mov	 edi, edx
  00042	c1 ef 05	 shr	 edi, 5
  00045	89 4d ec	 mov	 DWORD PTR tv256[ebp], ecx
  00048	23 f3		 and	 esi, ebx
  0004a	23 fb		 and	 edi, ebx
  0004c	8b ca		 mov	 ecx, edx
  0004e	23 cb		 and	 ecx, ebx
  00050	c1 e6 08	 shl	 esi, 8
  00053	c1 e7 08	 shl	 edi, 8
  00056	c1 e1 08	 shl	 ecx, 8
  00059	89 4d e8	 mov	 DWORD PTR tv266[ebp], ecx
  0005c	89 45 f4	 mov	 DWORD PTR tv191[ebp], eax
$L100545:

; 550  : 	{
; 551  : 		vt.Value.value1 = *(m_pCryptTable + index + (key.KeyValue.key1 * MAX_TABLE_DATA_SIZE));
; 552  : 		vt.Value.value2 = *(m_pCryptTable + index + (key.KeyValue.key2 * MAX_TABLE_DATA_SIZE));
; 553  : 		vt.Value.value3 = *(m_pCryptTable + index + (key.KeyValue.key3 * MAX_TABLE_DATA_SIZE));
; 554  : 		vt.Value.value4 = *(m_pCryptTable + index + (key.KeyValue.key4 * MAX_TABLE_DATA_SIZE));
; 555  : 
; 556  : 	//CString str;
; 557  : 	//str.Format("%d %d %d %d", key.KeyValue.key1
; 558  : 	//	,key.KeyValue.key2
; 559  : 	//	,key.KeyValue.key3
; 560  : 	//	,key.KeyValue.key4);
; 561  : 	//MessageBox(NULL, str, "", MB_OK);
; 562  : 	//str.Format("%d %d %d %d", vt.Value.value1
; 563  : 	//	,vt.Value.value2
; 564  : 	//	,vt.Value.value3
; 565  : 	//	,vt.Value.value4);
; 566  : 	//MessageBox(NULL, str, "", MB_OK);
; 567  : 	//str.Format("%d", htonl(vt.dwValue));
; 568  : 	//MessageBox(NULL, str, "", MB_OK);
; 569  : 		*((DWORD*)(data->m_Buffer + iPtr)) = *((DWORD*)(data->m_Buffer + iPtr)) ^ key.dwKey ^ vt.dwValue;
; 570  : 
; 571  : 		index++;
; 572  : 		iPtr += 4;
; 573  : 	}
; 574  : 
; 575  : 	int iMod = data->m_wMsgSize % sizeof(DWORD);
; 576  : 	if(iMod)
; 577  : 		data->m_wMsgSize = data->m_wMsgSize - sizeof(DWORD);

  0005f	0f b6 55 ff	 movzx	 edx, BYTE PTR _index$[ebp]
  00063	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 00		 mov	 eax, DWORD PTR [eax]
  00068	33 db		 xor	 ebx, ebx
  0006a	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  0006d	8a 3c 31	 mov	 bh, BYTE PTR [ecx+esi]
  00070	8d 0c 17	 lea	 ecx, DWORD PTR [edi+edx]
  00073	8a 1c 01	 mov	 bl, BYTE PTR [ecx+eax]
  00076	8b 4d ec	 mov	 ecx, DWORD PTR tv256[ebp]
  00079	03 ca		 add	 ecx, edx
  0007b	0f b6 0c 01	 movzx	 ecx, BYTE PTR [ecx+eax]
  0007f	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00082	81 e3 ff ff 00
	00		 and	 ebx, 65535		; 0000ffffH
  00088	0b d9		 or	 ebx, ecx
  0008a	8b 4d e8	 mov	 ecx, DWORD PTR tv266[ebp]
  0008d	03 ca		 add	 ecx, edx
  0008f	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00093	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00096	c1 e3 08	 shl	 ebx, 8
  00099	0b d8		 or	 ebx, eax
  0009b	8b 41 0a	 mov	 eax, DWORD PTR [ecx+10]
  0009e	8b d3		 mov	 edx, ebx
  000a0	8b 5d f8	 mov	 ebx, DWORD PTR _iPtr$[ebp]
  000a3	83 45 f8 04	 add	 DWORD PTR _iPtr$[ebp], 4
  000a7	03 c3		 add	 eax, ebx
  000a9	8b 5d e4	 mov	 ebx, DWORD PTR _key$[ebp]
  000ac	33 da		 xor	 ebx, edx
  000ae	31 18		 xor	 DWORD PTR [eax], ebx
  000b0	fe 45 ff	 inc	 BYTE PTR _index$[ebp]
  000b3	ff 4d f4	 dec	 DWORD PTR tv191[ebp]
  000b6	75 a7		 jne	 SHORT $L100545
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
$L99720:
  000ba	8b 01		 mov	 eax, DWORD PTR [ecx]
  000bc	a8 03		 test	 al, 3
  000be	5b		 pop	 ebx
  000bf	74 05		 je	 SHORT $L99725
  000c1	83 c0 fc	 add	 eax, -4			; fffffffcH
  000c4	89 01		 mov	 DWORD PTR [ecx], eax
$L99725:

; 578  : 
; 579  : }

  000c6	c9		 leave
  000c7	c2 04 00	 ret	 4
?Decrypt1@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ENDP	; CCryptManager::Decrypt1
_TEXT	ENDS
PUBLIC	?StopManager@CCryptManager@@QAEXXZ		; CCryptManager::StopManager
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Ogsy
;	COMDAT ?StopManager@CCryptManager@@QAEXXZ
_TEXT	SEGMENT
?StopManager@CCryptManager@@QAEXXZ PROC NEAR		; CCryptManager::StopManager, COMDAT
; _this$ = ecx

; 807  : 	if(m_pRandomTable)

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $L99839

; 808  : 		delete [] m_pRandomTable;

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000d	59		 pop	 ecx
$L99839:

; 809  : }

  0000e	c3		 ret	 0
?StopManager@CCryptManager@@QAEXXZ ENDP			; CCryptManager::StopManager
_TEXT	ENDS
PUBLIC	?rand@CRNGRand@@QAEKXZ				; CRNGRand::rand
EXTRN	__allrem:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?rand@CRNGRand@@QAEKXZ
_TEXT	SEGMENT
?rand@CRNGRand@@QAEKXZ PROC NEAR			; CRNGRand::rand, COMDAT
; _this$ = ecx

; 812  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 813  : 	LONGLONG n;
; 814  : 	n = (1103515245 * m_dwRandom + 12345);

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH

; 815  : 	m_dwRandom = (DWORD)(n % 2147483648);     // 2^32

  0000b	6a 00		 push	 0
  0000d	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00012	05 39 30 00 00	 add	 eax, 12345		; 00003039H
  00017	6a 00		 push	 0
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 __allrem
  0001f	89 06		 mov	 DWORD PTR [esi], eax
  00021	5e		 pop	 esi

; 816  : 	return m_dwRandom;
; 817  : }

  00022	c3		 ret	 0
?rand@CRNGRand@@QAEKXZ ENDP				; CRNGRand::rand
_TEXT	ENDS
PUBLIC	?srand@CRNGRand@@QAEXK@Z			; CRNGRand::srand
; Function compile flags: /Ogsy
;	COMDAT ?srand@CRNGRand@@QAEXK@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
?srand@CRNGRand@@QAEXK@Z PROC NEAR			; CRNGRand::srand, COMDAT
; _this$ = ecx

; 821  : 	m_dwRandom = seed;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _seed$[esp-4]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 822  : }

  00006	c2 04 00	 ret	 4
?srand@CRNGRand@@QAEXK@Z ENDP				; CRNGRand::srand
_TEXT	ENDS
PUBLIC	??0CRandom@@QAE@XZ				; CRandom::CRandom
EXTRN	_memset:NEAR
; Function compile flags: /Ogsy
;	COMDAT ??0CRandom@@QAE@XZ
_TEXT	SEGMENT
??0CRandom@@QAE@XZ PROC NEAR				; CRandom::CRandom, COMDAT
; _this$ = ecx

; 825  : {

  00000	56		 push	 esi

; 826  : 	memset( &m_state , 0 , sizeof(m_state) );

  00001	68 c4 09 00 00	 push	 2500			; 000009c4H
  00006	8b f1		 mov	 esi, ecx
  00008	6a 00		 push	 0
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 _memset

; 827  : 	m_pNext = NULL;

  00010	83 a6 c4 09 00
	00 00		 and	 DWORD PTR [esi+2500], 0

; 828  : 	m_left	=	-1;	

  00017	83 8e c8 09 00
	00 ff		 or	 DWORD PTR [esi+2504], -1
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 829  : }

  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	c3		 ret	 0
??0CRandom@@QAE@XZ ENDP					; CRandom::CRandom
_TEXT	ENDS
PUBLIC	??1CRandom@@QAE@XZ				; CRandom::~CRandom
; Function compile flags: /Ogsy
;	COMDAT ??1CRandom@@QAE@XZ
_TEXT	SEGMENT
??1CRandom@@QAE@XZ PROC NEAR				; CRandom::~CRandom, COMDAT
; _this$ = ecx

; 833  : 
; 834  : }

  00000	c3		 ret	 0
??1CRandom@@QAE@XZ ENDP					; CRandom::~CRandom
_TEXT	ENDS
PUBLIC	?SeedMT@CRandom@@QAEXK@Z			; CRandom::SeedMT
; Function compile flags: /Ogsy
;	COMDAT ?SeedMT@CRandom@@QAEXK@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
?SeedMT@CRandom@@QAEXK@Z PROC NEAR			; CRandom::SeedMT, COMDAT
; _this$ = ecx

; 844  : 	DWORD x = (seed | 1U) & 0xFFFFFFFFU, *s = m_state;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _seed$[esp-4]

; 845  : 	int    j = 0 ;
; 846  : 
; 847  : 	for(m_left=0, *s++=x, j=LENTH_OF_STATE_VECTOR; --j;

  00004	83 a1 c8 09 00
	00 00		 and	 DWORD PTR [ecx+2504], 0
  0000b	83 c8 01	 or	 eax, 1
  0000e	89 01		 mov	 DWORD PTR [ecx], eax
  00010	83 c1 04	 add	 ecx, 4
  00013	ba 6f 02 00 00	 mov	 edx, 623		; 0000026fH
$L99863:

; 848  : 		*s++ = (x*=69069U) & 0xFFFFFFFFU);

  00018	69 c0 cd 0d 01
	00		 imul	 eax, 69069		; 00010dcdH
  0001e	89 01		 mov	 DWORD PTR [ecx], eax
  00020	83 c1 04	 add	 ecx, 4
  00023	4a		 dec	 edx
  00024	75 f2		 jne	 SHORT $L99863

; 849  : }

  00026	c2 04 00	 ret	 4
?SeedMT@CRandom@@QAEXK@Z ENDP				; CRandom::SeedMT
_TEXT	ENDS
PUBLIC	?ReloadMT@CRandom@@QAEKXZ			; CRandom::ReloadMT
; Function compile flags: /Ogsy
;	COMDAT ?ReloadMT@CRandom@@QAEKXZ
_TEXT	SEGMENT
tv301 = -12						; size = 4
tv64 = -12						; size = 4
tv266 = -8						; size = 4
_pM$ = -8						; size = 4
_p0$ = -4						; size = 4
?ReloadMT@CRandom@@QAEKXZ PROC NEAR			; CRandom::ReloadMT, COMDAT
; _this$ = ecx

; 859  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 860  : 	DWORD *p0=m_state, *p2=m_state+2, *pM=m_state+M, s0, s1;
; 861  : 	int    j = 0 ;
; 862  : 
; 863  : 	if(m_left < -1)

  0000a	8d 9e c8 09 00
	00		 lea	 ebx, DWORD PTR [esi+2504]
  00010	83 3b ff	 cmp	 DWORD PTR [ebx], -1
  00013	57		 push	 edi
  00014	89 75 fc	 mov	 DWORD PTR _p0$[ebp], esi
  00017	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  0001a	7d 0a		 jge	 SHORT $L99876

; 864  : 		SeedMT(4357U);

  0001c	68 05 11 00 00	 push	 4357			; 00001105H
  00021	e8 00 00 00 00	 call	 ?SeedMT@CRandom@@QAEXK@Z ; CRandom::SeedMT
$L99876:

; 865  : 
; 866  : 	m_left=LENTH_OF_STATE_VECTOR-1, m_pNext=m_state+1;
; 867  : 
; 868  : 	for(s0=m_state[0], s1=m_state[1], j=LENTH_OF_STATE_VECTOR-M+1; --j; s0=s1, s1=*p2++)

  00026	8b 16		 mov	 edx, DWORD PTR [esi]
  00028	8d 8e 34 06 00
	00		 lea	 ecx, DWORD PTR [esi+1588]
  0002e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00031	89 4d f8	 mov	 DWORD PTR tv266[ebp], ecx
  00034	29 7d f8	 sub	 DWORD PTR tv266[ebp], edi
  00037	89 86 c4 09 00
	00		 mov	 DWORD PTR [esi+2500], eax
  0003d	8b 00		 mov	 eax, DWORD PTR [eax]
  0003f	c7 03 6f 02 00
	00		 mov	 DWORD PTR [ebx], 623	; 0000026fH
  00045	c7 45 f4 e3 00
	00 00		 mov	 DWORD PTR tv64[ebp], 227 ; 000000e3H
  0004c	b9 df b0 08 99	 mov	 ecx, -1727483681	; 9908b0dfH
$L99877:

; 869  : 		*p0++ = *pM++ ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);

  00051	8b d8		 mov	 ebx, eax
  00053	33 da		 xor	 ebx, edx
  00055	81 e3 fe ff ff
	7f		 and	 ebx, 2147483646		; 7ffffffeH
  0005b	33 da		 xor	 ebx, edx
  0005d	8b d0		 mov	 edx, eax
  0005f	80 e2 01	 and	 dl, 1
  00062	d1 eb		 shr	 ebx, 1
  00064	f6 da		 neg	 dl
  00066	1b d2		 sbb	 edx, edx
  00068	23 d1		 and	 edx, ecx
  0006a	33 da		 xor	 ebx, edx
  0006c	8b 55 f8	 mov	 edx, DWORD PTR tv266[ebp]
  0006f	33 1c 3a	 xor	 ebx, DWORD PTR [edx+edi]
  00072	8b 55 fc	 mov	 edx, DWORD PTR _p0$[ebp]
  00075	83 45 fc 04	 add	 DWORD PTR _p0$[ebp], 4
  00079	89 1a		 mov	 DWORD PTR [edx], ebx
  0007b	8b d0		 mov	 edx, eax
  0007d	8b 07		 mov	 eax, DWORD PTR [edi]
  0007f	83 c7 04	 add	 edi, 4
  00082	ff 4d f4	 dec	 DWORD PTR tv64[ebp]
  00085	75 ca		 jne	 SHORT $L99877

; 870  : 
; 871  : 	for(pM=m_state, j=M; --j; s0=s1, s1=*p2++)

  00087	89 75 f8	 mov	 DWORD PTR _pM$[ebp], esi
  0008a	c7 45 f4 8c 01
	00 00		 mov	 DWORD PTR tv301[ebp], 396 ; 0000018cH
$L99880:

; 872  : 		*p0++ = *pM++ ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);

  00091	8b d8		 mov	 ebx, eax
  00093	33 da		 xor	 ebx, edx
  00095	81 e3 fe ff ff
	7f		 and	 ebx, 2147483646		; 7ffffffeH
  0009b	33 da		 xor	 ebx, edx
  0009d	8b d0		 mov	 edx, eax
  0009f	80 e2 01	 and	 dl, 1
  000a2	d1 eb		 shr	 ebx, 1
  000a4	f6 da		 neg	 dl
  000a6	1b d2		 sbb	 edx, edx
  000a8	23 d1		 and	 edx, ecx
  000aa	33 da		 xor	 ebx, edx
  000ac	8b 55 f8	 mov	 edx, DWORD PTR _pM$[ebp]
  000af	33 1a		 xor	 ebx, DWORD PTR [edx]
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _p0$[ebp]
  000b4	83 45 fc 04	 add	 DWORD PTR _p0$[ebp], 4
  000b8	83 45 f8 04	 add	 DWORD PTR _pM$[ebp], 4
  000bc	89 1a		 mov	 DWORD PTR [edx], ebx
  000be	8b d0		 mov	 edx, eax
  000c0	8b 07		 mov	 eax, DWORD PTR [edi]
  000c2	83 c7 04	 add	 edi, 4
  000c5	ff 4d f4	 dec	 DWORD PTR tv301[ebp]
  000c8	75 c7		 jne	 SHORT $L99880

; 873  : 
; 874  : 	s1=m_state[0], *p0 = *pM ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);

  000ca	8b 36		 mov	 esi, DWORD PTR [esi]
  000cc	8b c6		 mov	 eax, esi
  000ce	33 c2		 xor	 eax, edx
  000d0	25 fe ff ff 7f	 and	 eax, 2147483646		; 7ffffffeH
  000d5	33 c2		 xor	 eax, edx
  000d7	d1 e8		 shr	 eax, 1
  000d9	8b d6		 mov	 edx, esi
  000db	80 e2 01	 and	 dl, 1
  000de	f6 da		 neg	 dl
  000e0	5f		 pop	 edi
  000e1	1b d2		 sbb	 edx, edx
  000e3	23 d1		 and	 edx, ecx
  000e5	8b 4d f8	 mov	 ecx, DWORD PTR _pM$[ebp]
  000e8	33 c2		 xor	 eax, edx
  000ea	33 01		 xor	 eax, DWORD PTR [ecx]
  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _p0$[ebp]
  000ef	89 01		 mov	 DWORD PTR [ecx], eax

; 875  : 	s1 ^= (s1 >> 11);

  000f1	8b c6		 mov	 eax, esi
  000f3	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  000f6	33 f0		 xor	 esi, eax

; 876  : 	s1 ^= (s1 <<  7) & 0x9D2C5680U;

  000f8	8b c6		 mov	 eax, esi
  000fa	25 ad 58 3a ff	 and	 eax, -12953427		; ff3a58adH
  000ff	c1 e0 07	 shl	 eax, 7
  00102	33 f0		 xor	 esi, eax

; 877  : 	s1 ^= (s1 << 15) & 0xEFC60000U;

  00104	8b c6		 mov	 eax, esi
  00106	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  0010b	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  0010e	33 f0		 xor	 esi, eax

; 878  : 
; 879  : 	return(s1 ^ (s1 >> 18));

  00110	8b c6		 mov	 eax, esi
  00112	c1 e8 12	 shr	 eax, 18			; 00000012H
  00115	33 c6		 xor	 eax, esi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx

; 880  : }

  00119	c9		 leave
  0011a	c3		 ret	 0
?ReloadMT@CRandom@@QAEKXZ ENDP				; CRandom::ReloadMT
_TEXT	ENDS
PUBLIC	?RandomMT@CRandom@@QAEKXZ			; CRandom::RandomMT
; Function compile flags: /Ogsy
;	COMDAT ?RandomMT@CRandom@@QAEKXZ
_TEXT	SEGMENT
?RandomMT@CRandom@@QAEKXZ PROC NEAR			; CRandom::RandomMT, COMDAT
; _this$ = ecx

; 888  : 	DWORD y;
; 889  : 
; 890  : 	if(--m_left < 0)

  00000	ff 89 c8 09 00
	00		 dec	 DWORD PTR [ecx+2504]
  00006	79 05		 jns	 SHORT $L99888

; 891  : 		return( ReloadMT() );

  00008	e9 00 00 00 00	 jmp	 ?ReloadMT@CRandom@@QAEKXZ ; CRandom::ReloadMT
$L99888:

; 892  : 
; 893  : 	y  = *m_pNext++;

  0000d	8d 81 c4 09 00
	00		 lea	 eax, DWORD PTR [ecx+2500]
  00013	8b 10		 mov	 edx, DWORD PTR [eax]
  00015	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00017	83 c2 04	 add	 edx, 4
  0001a	89 10		 mov	 DWORD PTR [eax], edx

; 894  : 	y ^= (y >> 11);

  0001c	8b c1		 mov	 eax, ecx
  0001e	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00021	33 c8		 xor	 ecx, eax

; 895  : 	y ^= (y <<  7) & 0x9D2C5680U;

  00023	8b c1		 mov	 eax, ecx
  00025	25 ad 58 3a ff	 and	 eax, -12953427		; ff3a58adH
  0002a	c1 e0 07	 shl	 eax, 7
  0002d	33 c8		 xor	 ecx, eax

; 896  : 	y ^= (y << 15) & 0xEFC60000U;

  0002f	8b c1		 mov	 eax, ecx
  00031	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  00036	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  00039	33 c8		 xor	 ecx, eax

; 897  : 	return(y ^ (y >> 18));

  0003b	8b c1		 mov	 eax, ecx
  0003d	c1 e8 12	 shr	 eax, 18			; 00000012H
  00040	33 c1		 xor	 eax, ecx

; 898  : 	// This change made so the value returned is in the same range as what rand() returns
; 899  : 	// return(y ^ (y >> 18)) % 32767;
; 900  : }

  00042	c3		 ret	 0
?RandomMT@CRandom@@QAEKXZ ENDP				; CRandom::RandomMT
_TEXT	ENDS
PUBLIC	?LoadTable2@CCryptManager@@IAEXK@Z		; CCryptManager::LoadTable2
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
; Function compile flags: /Ogsy
;	COMDAT ?LoadTable2@CCryptManager@@IAEXK@Z
_TEXT	SEGMENT
_random$ = 8						; size = 4
_seed$ = 8						; size = 4
?LoadTable2@CCryptManager@@IAEXK@Z PROC NEAR		; CCryptManager::LoadTable2, COMDAT
; _this$ = ecx

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 276  : 	m_pCryptTable = new BYTE[4096];

  00006	be 00 10 00 00	 mov	 esi, 4096		; 00001000H
  0000b	56		 push	 esi
  0000c	8b f9		 mov	 edi, ecx
  0000e	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00013	89 07		 mov	 DWORD PTR [edi], eax

; 277  : 	CRNGRand random;
; 278  : 	random.srand(seed);

  00015	8b 45 08	 mov	 eax, DWORD PTR _seed$[ebp]
  00018	59		 pop	 ecx
  00019	89 45 08	 mov	 DWORD PTR _random$[ebp], eax
  0001c	33 db		 xor	 ebx, ebx
$L99599:

; 279  : 	int temp = 4096/4;
; 280  : 	for(int i = 0; i < temp; i++)
; 281  : 	{
; 282  : 		*((DWORD*)(m_pCryptTable + i*sizeof(DWORD))) = random.rand();

  0001e	8d 4d 08	 lea	 ecx, DWORD PTR _random$[ebp]
  00021	e8 00 00 00 00	 call	 ?rand@CRNGRand@@QAEKXZ	; CRNGRand::rand
  00026	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00028	89 04 0b	 mov	 DWORD PTR [ebx+ecx], eax
  0002b	83 c3 04	 add	 ebx, 4
  0002e	3b de		 cmp	 ebx, esi
  00030	7c ec		 jl	 SHORT $L99599
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx

; 283  : 	}
; 284  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?LoadTable2@CCryptManager@@IAEXK@Z ENDP			; CCryptManager::LoadTable2
_TEXT	ENDS
PUBLIC	?CryptBuf@CCryptManager@@QAEXPADHT_KEY_TYPE@@@Z	; CCryptManager::CryptBuf
; Function compile flags: /Ogsy
;	COMDAT ?CryptBuf@CCryptManager@@QAEXPADHT_KEY_TYPE@@@Z
_TEXT	SEGMENT
_iPtr$ = -4						; size = 4
_data$ = 8						; size = 4
_len$ = 12						; size = 4
tv253 = 16						; size = 4
_key$ = 16						; size = 4
?CryptBuf@CCryptManager@@QAEXPADHT_KEY_TYPE@@@Z PROC NEAR ; CCryptManager::CryptBuf, COMDAT
; _this$ = ecx

; 354  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 355  : //	KEY_TYPE key;
; 356  : 	int iEncryptSize = 0;
; 357  : 	int iPtr = 0;

  00004	83 65 fc 00	 and	 DWORD PTR _iPtr$[ebp], 0
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 358  : 	BYTE index = 0;
; 359  : 
; 360  : 	//// 罚待虐 积己
; 361  : 	//key.KeyValue.key1 = GetRandKey();
; 362  : 	//key.KeyValue.key2 = GetRandKey();
; 363  : 	//key.KeyValue.key3 = GetRandKey();
; 364  : 	//key.KeyValue.key4 = GetRandKey();
; 365  : 	//key.KeyValue.index = rand() % MAX_TABLE_DATA_SIZE;
; 366  : 	//key.KeyValue.type = CRYPT_TYPE2;
; 367  : 
; 368  : //	random.srand(key.dwKey);
; 369  : 
; 370  : 	int iMod = len % sizeof(DWORD);

  0000b	8b 7d 0c	 mov	 edi, DWORD PTR _len$[ebp]
  0000e	8b c7		 mov	 eax, edi
  00010	83 e0 03	 and	 eax, 3
  00013	8b d9		 mov	 ebx, ecx

; 371  : 
; 372  : 	// 鞠龋拳且 辨捞甫 备茄促.
; 373  : 	if(iMod == 0)

  00015	75 21		 jne	 SHORT $L99646

; 374  : 	{
; 375  : 		iEncryptSize = len / sizeof(DWORD);

  00017	c1 ef 02	 shr	 edi, 2

; 376  : 		index = key.KeyValue.index;
; 377  : 
; 378  : 		for(int i = 0; i < iEncryptSize; i++)

  0001a	85 ff		 test	 edi, edi
  0001c	7e 6d		 jle	 SHORT $L99670

; 374  : 	{
; 375  : 		iEncryptSize = len / sizeof(DWORD);

  0001e	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]
$L99649:

; 379  : 		{
; 380  : 			// 摹券且 蔼阑 rand 窃荐俊辑 父电促.
; 381  : 
; 382  : 			*((DWORD*)(data + iPtr)) = *((DWORD*)(data + iPtr)) ^ key.dwKey ^ m_Rand1->rand();

  00021	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00024	e8 00 00 00 00	 call	 ?rand@CRNGRand@@QAEKXZ	; CRNGRand::rand
  00029	33 06		 xor	 eax, DWORD PTR [esi]
  0002b	33 45 10	 xor	 eax, DWORD PTR _key$[ebp]
  0002e	89 06		 mov	 DWORD PTR [esi], eax

; 383  : 
; 384  : 			index++;
; 385  : 			iPtr += sizeof(DWORD);

  00030	83 c6 04	 add	 esi, 4
  00033	4f		 dec	 edi
  00034	75 eb		 jne	 SHORT $L99649

; 386  : 		}
; 387  : 	}
; 388  : 	else if(iMod == 2)

  00036	eb 53		 jmp	 SHORT $L99670
$L99646:
  00038	83 f8 02	 cmp	 eax, 2
  0003b	75 21		 jne	 SHORT $L99656

; 389  : 	{
; 390  : 		iEncryptSize = len / sizeof(WORD);

  0003d	d1 ef		 shr	 edi, 1

; 391  : 		index = key.KeyValue.index;
; 392  : 
; 393  : 		for(int i = 0; i < iEncryptSize; i++)

  0003f	85 ff		 test	 edi, edi
  00041	7e 48		 jle	 SHORT $L99670

; 389  : 	{
; 390  : 		iEncryptSize = len / sizeof(WORD);

  00043	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]
$L99659:

; 394  : 		{
; 395  : 			// 摹券且 蔼阑 rand 窃荐俊辑 父电促.
; 396  : 
; 397  : 			*((WORD*)(data + iPtr)) = *((WORD*)(data + iPtr)) ^ key.wKeyValue.wKey1 ^ (WORD)m_Rand1->rand();

  00046	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00049	e8 00 00 00 00	 call	 ?rand@CRNGRand@@QAEKXZ	; CRNGRand::rand
  0004e	66 33 06	 xor	 ax, WORD PTR [esi]
  00051	33 45 10	 xor	 eax, DWORD PTR _key$[ebp]
  00054	66 89 06	 mov	 WORD PTR [esi], ax

; 398  : 
; 399  : 			index++;
; 400  : 			iPtr += sizeof(WORD);

  00057	46		 inc	 esi
  00058	46		 inc	 esi
  00059	4f		 dec	 edi
  0005a	75 ea		 jne	 SHORT $L99659

; 401  : 		}
; 402  : 	}
; 403  : 	else

  0005c	eb 2d		 jmp	 SHORT $L99670
$L99656:

; 404  : 	{
; 405  : 		iEncryptSize = len;
; 406  : 		index = key.KeyValue.index;
; 407  : 
; 408  : 		for(int i = 0; i < iEncryptSize; i++)

  0005e	85 ff		 test	 edi, edi
  00060	7e 29		 jle	 SHORT $L99670
  00062	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00065	c1 e8 14	 shr	 eax, 20			; 00000014H
  00068	89 45 10	 mov	 DWORD PTR tv253[ebp], eax
$L100593:
  0006b	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _iPtr$[ebp]
  00071	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]

; 409  : 		{
; 410  : 			// 摹券且 蔼阑 rand 窃荐俊辑 父电促.
; 411  : 
; 412  : 			*(data + iPtr) = *(data + iPtr) ^ key.KeyValue.index ^ (BYTE)m_Rand1->rand();

  00074	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00077	e8 00 00 00 00	 call	 ?rand@CRNGRand@@QAEKXZ	; CRNGRand::rand
  0007c	32 06		 xor	 al, BYTE PTR [esi]
  0007e	32 45 10	 xor	 al, BYTE PTR tv253[ebp]

; 413  : 
; 414  : 			index++;
; 415  : 			iPtr += sizeof(BYTE);

  00081	ff 45 fc	 inc	 DWORD PTR _iPtr$[ebp]
  00084	39 7d fc	 cmp	 DWORD PTR _iPtr$[ebp], edi
  00087	88 06		 mov	 BYTE PTR [esi], al
  00089	7c e0		 jl	 SHORT $L100593
$L99670:
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx

; 416  : 		}
; 417  : 	}
; 418  : 
; 419  : }

  0008e	c9		 leave
  0008f	c2 0c 00	 ret	 12			; 0000000cH
?CryptBuf@CCryptManager@@QAEXPADHT_KEY_TYPE@@@Z ENDP	; CCryptManager::CryptBuf
_TEXT	ENDS
PUBLIC	?Encrypt2@CCryptManager@@QAEXPAU_PACKETDATA@@@Z	; CCryptManager::Encrypt2
; Function compile flags: /Ogsy
;	COMDAT ?Encrypt2@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT
tv79 = -12						; size = 4
_random$ = -12						; size = 4
tv86 = -8						; size = 4
_iPtr$ = -4						; size = 4
tv147 = 8						; size = 4
_data$ = 8						; size = 4
?Encrypt2@CCryptManager@@QAEXPAU_PACKETDATA@@@Z PROC NEAR ; CCryptManager::Encrypt2, COMDAT
; _this$ = ecx

; 582  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 583  : 	KEY_TYPE key;
; 584  : 	int iEncryptSize = 0;
; 585  : 	int iPtr = 0;

  00006	83 65 fc 00	 and	 DWORD PTR _iPtr$[ebp], 0
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b f1		 mov	 esi, ecx

; 586  : 	BYTE index = 0;
; 587  : 	CRNGRand random;
; 588  : 
; 589  : 	// 罚待虐 积己
; 590  : 	key.KeyValue.key1 = GetRandKey();

  0000f	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey

; 591  : 	key.KeyValue.key2 = GetRandKey();

  00014	8b ce		 mov	 ecx, esi
  00016	8b f8		 mov	 edi, eax
  00018	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey

; 592  : 	key.KeyValue.key3 = GetRandKey();

  0001d	8b ce		 mov	 ecx, esi
  0001f	8b d8		 mov	 ebx, eax
  00021	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey

; 593  : 	key.KeyValue.key4 = GetRandKey();

  00026	8b ce		 mov	 ecx, esi
  00028	89 45 f4	 mov	 DWORD PTR tv79[ebp], eax
  0002b	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey
  00030	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax

; 594  : 	key.KeyValue.index = rand() % MAX_TABLE_DATA_SIZE;

  00033	e8 00 00 00 00	 call	 _rand
  00038	99		 cdq
  00039	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0003e	f7 f9		 idiv	 ecx

; 595  : 	key.KeyValue.type = CRYPT_TYPE2;

  00040	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  00043	6a 1f		 push	 31			; 0000001fH
  00045	59		 pop	 ecx
  00046	23 c1		 and	 eax, ecx
  00048	23 d9		 and	 ebx, ecx

; 620  : //#ifdef __LINUX__
; 621  : 	data->m_Key.dwKey = key.dwKey;// ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;

  0004a	23 f9		 and	 edi, ecx
  0004c	8b f2		 mov	 esi, edx
  0004e	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  00054	81 ce 00 03 00
	00		 or	 esi, 768		; 00000300H
  0005a	c1 e6 05	 shl	 esi, 5
  0005d	0b f0		 or	 esi, eax
  0005f	8b 45 f4	 mov	 eax, DWORD PTR tv79[ebp]
  00062	c1 e6 05	 shl	 esi, 5
  00065	23 c1		 and	 eax, ecx
  00067	0b f0		 or	 esi, eax
  00069	c1 e6 05	 shl	 esi, 5
  0006c	0b f3		 or	 esi, ebx
  0006e	c1 e6 05	 shl	 esi, 5
  00071	0b f7		 or	 esi, edi
  00073	8b 7d 08	 mov	 edi, DWORD PTR _data$[ebp]
  00076	8b 07		 mov	 eax, DWORD PTR [edi]
  00078	a8 03		 test	 al, 3
  0007a	89 75 f4	 mov	 DWORD PTR _random$[ebp], esi
  0007d	74 05		 je	 SHORT $L99738
  0007f	83 c0 04	 add	 eax, 4
  00082	89 07		 mov	 DWORD PTR [edi], eax
$L99738:
  00084	8b 07		 mov	 eax, DWORD PTR [edi]
  00086	c1 e8 02	 shr	 eax, 2
  00089	85 c0		 test	 eax, eax
  0008b	7e 23		 jle	 SHORT $L99744

; 596  : 
; 597  : 	random.srand(key.dwKey);
; 598  : 
; 599  : 	int iMod = data->m_wMsgSize % sizeof(DWORD);
; 600  : 	if(iMod)
; 601  : 		data->m_wMsgSize = (data->m_wMsgSize + sizeof(DWORD)); 
; 602  : 
; 603  : 	// 鞠龋拳且 辨捞甫 备茄促.
; 604  : 	iEncryptSize = data->m_wMsgSize / sizeof(DWORD);

  0008d	89 45 08	 mov	 DWORD PTR tv147[ebp], eax
$L99742:

; 605  : 
; 606  : 	index = key.KeyValue.index;
; 607  : 
; 608  : 	for(int i = 0; i < iEncryptSize; i++)
; 609  : 	{
; 610  : 		// 摹券且 蔼阑 rand 窃荐俊辑 父电促.
; 611  : 
; 612  : 		*((DWORD*)(data->m_Buffer + iPtr)) = *((DWORD*)(data->m_Buffer + iPtr)) ^ key.dwKey ^ random.rand();

  00090	8b 47 0a	 mov	 eax, DWORD PTR [edi+10]
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _iPtr$[ebp]
  00096	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]
  00099	8d 4d f4	 lea	 ecx, DWORD PTR _random$[ebp]
  0009c	e8 00 00 00 00	 call	 ?rand@CRNGRand@@QAEKXZ	; CRNGRand::rand
  000a1	33 03		 xor	 eax, DWORD PTR [ebx]

; 613  : 
; 614  : 		index++;
; 615  : 		iPtr += 4;

  000a3	83 45 fc 04	 add	 DWORD PTR _iPtr$[ebp], 4
  000a7	33 c6		 xor	 eax, esi
  000a9	ff 4d 08	 dec	 DWORD PTR tv147[ebp]
  000ac	89 03		 mov	 DWORD PTR [ebx], eax
  000ae	75 e0		 jne	 SHORT $L99742
$L99744:

; 616  : 	}
; 617  : 
; 618  : //	data->m_wMsgType = data->m_wMsgType ^ key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 619  : 	data->m_wMsgType = (WORD)(data->m_wMsgType ^ key.dwKey ^ CRYPTION_KEY);

  000b0	33 c0		 xor	 eax, eax
  000b2	66 8b 47 04	 mov	 ax, WORD PTR [edi+4]
  000b6	66 33 c6	 xor	 ax, si

; 620  : //#ifdef __LINUX__
; 621  : 	data->m_Key.dwKey = key.dwKey;// ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;

  000b9	89 77 06	 mov	 DWORD PTR [edi+6], esi
  000bc	35 61 73 00 00	 xor	 eax, 29537		; 00007361H
  000c1	66 89 47 04	 mov	 WORD PTR [edi+4], ax
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx

; 622  : //#else
; 623  : //	data->m_Key.dwKey = _lrotl(key.dwKey, *(data->m_Buffer)%32) ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 624  : //#endif
; 625  : }

  000c8	c9		 leave
  000c9	c2 04 00	 ret	 4
?Encrypt2@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ENDP	; CCryptManager::Encrypt2
_TEXT	ENDS
PUBLIC	?Decrypt2@CCryptManager@@QAEXPAU_PACKETDATA@@@Z	; CCryptManager::Decrypt2
; Function compile flags: /Ogsy
;	COMDAT ?Decrypt2@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT
_random$ = -8						; size = 4
_iPtr$ = -4						; size = 4
tv76 = 8						; size = 4
_data$ = 8						; size = 4
?Decrypt2@CCryptManager@@QAEXPAU_PACKETDATA@@@Z PROC NEAR ; CCryptManager::Decrypt2, COMDAT
; _this$ = ecx

; 628  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 629  : 	KEY_TYPE key;
; 630  : 	int iEncryptSize = 0;
; 631  : 	int iPtr = 0;

  00005	83 65 fc 00	 and	 DWORD PTR _iPtr$[ebp], 0
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 632  : 	BYTE index = 0;
; 633  : 	CRNGRand random;
; 634  : 
; 635  : 	//data->m_Key.dwKey = data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 636  : 	//data->m_Key.dwKey = _lrotr(data->m_Key.dwKey, *(data->m_Buffer)%32);
; 637  : 
; 638  : 	key.dwKey = data->m_Key.dwKey;

  0000b	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]

; 639  : //	data->m_wMsgType = data->m_wMsgType ^ key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 640  : 
; 641  : 	random.srand(key.dwKey);
; 642  : 
; 643  : 	//key.KeyValue.key1 = data->m_Key.KeyValue.key1;
; 644  : 	//key.KeyValue.key2 = data->m_Key.KeyValue.key2;
; 645  : 	//key.KeyValue.key3 = data->m_Key.KeyValue.key3;
; 646  : 	//key.KeyValue.key4 = data->m_Key.KeyValue.key4;
; 647  : 	//key.KeyValue.index = data->m_Key.KeyValue.index;
; 648  : 
; 649  : 	// 鞠龋秦力 且 辨捞甫 备茄促.
; 650  : 	iEncryptSize = (data->m_wMsgSize) / sizeof(DWORD);

  0000e	8b 06		 mov	 eax, DWORD PTR [esi]
  00010	8b 5e 06	 mov	 ebx, DWORD PTR [esi+6]
  00013	c1 e8 02	 shr	 eax, 2

; 651  : 
; 652  : 	index = key.KeyValue.index;
; 653  : 
; 654  : 	for(int i = 0; i < iEncryptSize; i++)

  00016	85 c0		 test	 eax, eax
  00018	89 5d f8	 mov	 DWORD PTR _random$[ebp], ebx
  0001b	7e 25		 jle	 SHORT $L99761
  0001d	89 45 08	 mov	 DWORD PTR tv76[ebp], eax
  00020	57		 push	 edi
$L100608:

; 655  : 	{
; 656  : 		// 摹券且 蔼阑 rand 窃荐俊辑 父电促.
; 657  : 
; 658  : 		*((DWORD*)(data->m_Buffer + iPtr)) = *((DWORD*)(data->m_Buffer + iPtr)) ^ key.dwKey ^ random.rand();

  00021	8b 46 0a	 mov	 eax, DWORD PTR [esi+10]
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _iPtr$[ebp]
  00027	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  0002a	8d 4d f8	 lea	 ecx, DWORD PTR _random$[ebp]
  0002d	e8 00 00 00 00	 call	 ?rand@CRNGRand@@QAEKXZ	; CRNGRand::rand
  00032	33 07		 xor	 eax, DWORD PTR [edi]

; 659  : 
; 660  : 		index++;
; 661  : 		iPtr += 4;

  00034	83 45 fc 04	 add	 DWORD PTR _iPtr$[ebp], 4
  00038	33 c3		 xor	 eax, ebx
  0003a	ff 4d 08	 dec	 DWORD PTR tv76[ebp]
  0003d	89 07		 mov	 DWORD PTR [edi], eax
  0003f	75 e0		 jne	 SHORT $L100608
  00041	5f		 pop	 edi
$L99761:

; 662  : 	}
; 663  : 
; 664  : 	int iMod = data->m_wMsgSize % sizeof(DWORD);

  00042	8b 06		 mov	 eax, DWORD PTR [esi]
  00044	a8 03		 test	 al, 3

; 665  : 	if(iMod)

  00046	74 05		 je	 SHORT $L99766

; 666  : 		data->m_wMsgSize = data->m_wMsgSize - sizeof(DWORD);

  00048	83 c0 fc	 add	 eax, -4			; fffffffcH
  0004b	89 06		 mov	 DWORD PTR [esi], eax
$L99766:
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx

; 667  : 
; 668  : }

  0004f	c9		 leave
  00050	c2 04 00	 ret	 4
?Decrypt2@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ENDP	; CCryptManager::Decrypt2
_TEXT	ENDS
PUBLIC	?Encrypt3@CCryptManager@@QAEXPAU_PACKETDATA@@@Z	; CCryptManager::Encrypt3
; Function compile flags: /Ogsy
;	COMDAT ?Encrypt3@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT
_random$ = -2520					; size = 2508
tv82 = -12						; size = 4
tv89 = -8						; size = 4
_iPtr$ = -4						; size = 4
tv150 = 8						; size = 4
_data$ = 8						; size = 4
?Encrypt3@CCryptManager@@QAEXPAU_PACKETDATA@@@Z PROC NEAR ; CCryptManager::Encrypt3, COMDAT
; _this$ = ecx

; 671  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 09 00
	00		 sub	 esp, 2520		; 000009d8H

; 672  : 	KEY_TYPE key;
; 673  : 	int iEncryptSize = 0;
; 674  : 	int iPtr = 0;

  00009	83 65 fc 00	 and	 DWORD PTR _iPtr$[ebp], 0
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	57		 push	 edi

; 675  : 	BYTE index = 0;
; 676  : 	CRandom random;

  00012	8d 8d 28 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  00018	e8 00 00 00 00	 call	 ??0CRandom@@QAE@XZ	; CRandom::CRandom

; 677  : 
; 678  : 	// 罚待虐 积己
; 679  : 	key.KeyValue.key1 = GetRandKey();

  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey

; 680  : 	key.KeyValue.key2 = GetRandKey();

  00024	8b ce		 mov	 ecx, esi
  00026	8b f8		 mov	 edi, eax
  00028	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey

; 681  : 	key.KeyValue.key3 = GetRandKey();

  0002d	8b ce		 mov	 ecx, esi
  0002f	8b d8		 mov	 ebx, eax
  00031	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey

; 682  : 	key.KeyValue.key4 = GetRandKey();

  00036	8b ce		 mov	 ecx, esi
  00038	89 45 f4	 mov	 DWORD PTR tv82[ebp], eax
  0003b	e8 00 00 00 00	 call	 ?GetRandKey@CCryptManager@@IAEHXZ ; CCryptManager::GetRandKey
  00040	89 45 f8	 mov	 DWORD PTR tv89[ebp], eax

; 683  : 	key.KeyValue.index = rand() % MAX_TABLE_DATA_SIZE;

  00043	e8 00 00 00 00	 call	 _rand
  00048	99		 cdq
  00049	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0004e	f7 f9		 idiv	 ecx

; 684  : 	key.KeyValue.type = CRYPT_TYPE3;

  00050	8b 45 f8	 mov	 eax, DWORD PTR tv89[ebp]
  00053	6a 1f		 push	 31			; 0000001fH
  00055	59		 pop	 ecx
  00056	23 c1		 and	 eax, ecx
  00058	23 d9		 and	 ebx, ecx

; 709  : //#ifdef __LINUX__
; 710  : 	data->m_Key.dwKey = key.dwKey;// ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;

  0005a	23 f9		 and	 edi, ecx
  0005c	8b f2		 mov	 esi, edx
  0005e	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  00064	81 ce 00 08 00
	00		 or	 esi, 2048		; 00000800H
  0006a	c1 e6 05	 shl	 esi, 5
  0006d	0b f0		 or	 esi, eax
  0006f	8b 45 f4	 mov	 eax, DWORD PTR tv82[ebp]
  00072	c1 e6 05	 shl	 esi, 5
  00075	23 c1		 and	 eax, ecx
  00077	0b f0		 or	 esi, eax
  00079	c1 e6 05	 shl	 esi, 5
  0007c	0b f3		 or	 esi, ebx
  0007e	c1 e6 05	 shl	 esi, 5
  00081	0b f7		 or	 esi, edi
  00083	56		 push	 esi
  00084	8d 8d 28 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  0008a	e8 00 00 00 00	 call	 ?SeedMT@CRandom@@QAEXK@Z ; CRandom::SeedMT
  0008f	8b 7d 08	 mov	 edi, DWORD PTR _data$[ebp]
  00092	8b 07		 mov	 eax, DWORD PTR [edi]
  00094	a8 03		 test	 al, 3
  00096	74 05		 je	 SHORT $L99779
  00098	83 c0 04	 add	 eax, 4
  0009b	89 07		 mov	 DWORD PTR [edi], eax
$L99779:
  0009d	8b 07		 mov	 eax, DWORD PTR [edi]
  0009f	c1 e8 02	 shr	 eax, 2
  000a2	85 c0		 test	 eax, eax
  000a4	7e 26		 jle	 SHORT $L99785

; 685  : 
; 686  : 	random.SeedMT(key.dwKey);
; 687  : 
; 688  : 	int iMod = data->m_wMsgSize % sizeof(DWORD);
; 689  : 	if(iMod)
; 690  : 		data->m_wMsgSize = (data->m_wMsgSize + sizeof(DWORD)); 
; 691  : 
; 692  : 	// 鞠龋拳且 辨捞甫 备茄促.
; 693  : 	iEncryptSize = data->m_wMsgSize / sizeof(DWORD);

  000a6	89 45 08	 mov	 DWORD PTR tv150[ebp], eax
$L99783:

; 694  : 
; 695  : 	index = key.KeyValue.index;
; 696  : 
; 697  : 	for(int i = 0; i < iEncryptSize; i++)
; 698  : 	{
; 699  : 		// 摹券且 蔼阑 rand 窃荐俊辑 父电促.
; 700  : 
; 701  : 		*((DWORD*)(data->m_Buffer + iPtr)) = *((DWORD*)(data->m_Buffer + iPtr)) ^ key.dwKey ^ random.RandomMT();

  000a9	8b 47 0a	 mov	 eax, DWORD PTR [edi+10]
  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _iPtr$[ebp]
  000af	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]
  000b2	8d 8d 28 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  000b8	e8 00 00 00 00	 call	 ?RandomMT@CRandom@@QAEKXZ ; CRandom::RandomMT
  000bd	33 03		 xor	 eax, DWORD PTR [ebx]

; 702  : 
; 703  : 		index++;
; 704  : 		iPtr += 4;

  000bf	83 45 fc 04	 add	 DWORD PTR _iPtr$[ebp], 4
  000c3	33 c6		 xor	 eax, esi
  000c5	ff 4d 08	 dec	 DWORD PTR tv150[ebp]
  000c8	89 03		 mov	 DWORD PTR [ebx], eax
  000ca	75 dd		 jne	 SHORT $L99783
$L99785:

; 705  : 	}
; 706  : 
; 707  : //	data->m_wMsgType = data->m_wMsgType ^ key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 708  : 	data->m_wMsgType = (WORD)(data->m_wMsgType ^ key.dwKey ^ CRYPTION_KEY);

  000cc	33 c0		 xor	 eax, eax
  000ce	66 8b 47 04	 mov	 ax, WORD PTR [edi+4]
  000d2	66 33 c6	 xor	 ax, si

; 709  : //#ifdef __LINUX__
; 710  : 	data->m_Key.dwKey = key.dwKey;// ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;

  000d5	89 77 06	 mov	 DWORD PTR [edi+6], esi
  000d8	35 61 73 00 00	 xor	 eax, 29537		; 00007361H
  000dd	66 89 47 04	 mov	 WORD PTR [edi+4], ax
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx

; 711  : //#else
; 712  : //	data->m_Key.dwKey = _lrotl(key.dwKey, *(data->m_Buffer)%32) ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 713  : //#endif
; 714  : }

  000e4	c9		 leave
  000e5	c2 04 00	 ret	 4
?Encrypt3@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ENDP	; CCryptManager::Encrypt3
_TEXT	ENDS
PUBLIC	?Decrypt3@CCryptManager@@QAEXPAU_PACKETDATA@@@Z	; CCryptManager::Decrypt3
; Function compile flags: /Ogsy
;	COMDAT ?Decrypt3@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT
_random$ = -2512					; size = 2508
_key$ = -4						; size = 4
tv79 = 8						; size = 4
_data$ = 8						; size = 4
?Decrypt3@CCryptManager@@QAEXPAU_PACKETDATA@@@Z PROC NEAR ; CCryptManager::Decrypt3, COMDAT
; _this$ = ecx

; 717  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 09 00
	00		 sub	 esp, 2512		; 000009d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 718  : 	KEY_TYPE key;
; 719  : 	int iEncryptSize = 0;
; 720  : 	int iPtr = 0;
; 721  : 	BYTE index = 0;
; 722  : 	CRandom random;

  0000b	8d 8d 30 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  00011	33 db		 xor	 ebx, ebx
  00013	e8 00 00 00 00	 call	 ??0CRandom@@QAE@XZ	; CRandom::CRandom

; 723  : 
; 724  : 	//data->m_Key.dwKey = data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 725  : 	//data->m_Key.dwKey = _lrotr(data->m_Key.dwKey, *(data->m_Buffer)%32);
; 726  : 
; 727  : 	key.dwKey = data->m_Key.dwKey;

  00018	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]
  0001b	8b 46 06	 mov	 eax, DWORD PTR [esi+6]

; 728  : 	//data->m_wMsgType = data->m_wMsgType ^ key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 729  : 
; 730  : 	random.SeedMT(key.dwKey);

  0001e	50		 push	 eax
  0001f	8d 8d 30 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  00025	89 45 fc	 mov	 DWORD PTR _key$[ebp], eax
  00028	e8 00 00 00 00	 call	 ?SeedMT@CRandom@@QAEXK@Z ; CRandom::SeedMT

; 731  : 
; 732  : 	//key.KeyValue.key1 = data->m_Key.KeyValue.key1;
; 733  : 	//key.KeyValue.key2 = data->m_Key.KeyValue.key2;
; 734  : 	//key.KeyValue.key3 = data->m_Key.KeyValue.key3;
; 735  : 	//key.KeyValue.key4 = data->m_Key.KeyValue.key4;
; 736  : 	//key.KeyValue.index = data->m_Key.KeyValue.index;
; 737  : 
; 738  : 	// 鞠龋秦力 且 辨捞甫 备茄促.
; 739  : 	iEncryptSize = (data->m_wMsgSize) / sizeof(DWORD);

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	c1 e8 02	 shr	 eax, 2

; 740  : 
; 741  : 	index = key.KeyValue.index;
; 742  : 
; 743  : 	for(int i = 0; i < iEncryptSize; i++)

  00032	85 c0		 test	 eax, eax
  00034	7e 25		 jle	 SHORT $L99802
  00036	89 45 08	 mov	 DWORD PTR tv79[ebp], eax
  00039	57		 push	 edi
$L99800:

; 744  : 	{
; 745  : 		// 摹券且 蔼阑 rand 窃荐俊辑 父电促.
; 746  : 
; 747  : 		*((DWORD*)(data->m_Buffer + iPtr)) = *((DWORD*)(data->m_Buffer + iPtr)) ^ key.dwKey ^ random.RandomMT();

  0003a	8b 46 0a	 mov	 eax, DWORD PTR [esi+10]
  0003d	8d 8d 30 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  00043	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  00046	e8 00 00 00 00	 call	 ?RandomMT@CRandom@@QAEKXZ ; CRandom::RandomMT
  0004b	33 07		 xor	 eax, DWORD PTR [edi]

; 748  : 
; 749  : 		index++;
; 750  : 		iPtr += 4;

  0004d	83 c3 04	 add	 ebx, 4
  00050	33 45 fc	 xor	 eax, DWORD PTR _key$[ebp]
  00053	ff 4d 08	 dec	 DWORD PTR tv79[ebp]
  00056	89 07		 mov	 DWORD PTR [edi], eax
  00058	75 e0		 jne	 SHORT $L99800
  0005a	5f		 pop	 edi
$L99802:

; 751  : 	}
; 752  : 
; 753  : 	int iMod = data->m_wMsgSize % sizeof(DWORD);

  0005b	8b 06		 mov	 eax, DWORD PTR [esi]
  0005d	a8 03		 test	 al, 3

; 754  : 	if(iMod)

  0005f	74 05		 je	 SHORT $L99807

; 755  : 		data->m_wMsgSize = data->m_wMsgSize - sizeof(DWORD);

  00061	83 c0 fc	 add	 eax, -4			; fffffffcH
  00064	89 06		 mov	 DWORD PTR [esi], eax
$L99807:
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx

; 756  : 
; 757  : }

  00068	c9		 leave
  00069	c2 04 00	 ret	 4
?Decrypt3@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ENDP	; CCryptManager::Decrypt3
_TEXT	ENDS
PUBLIC	?MakeRandomKeyTable@CCryptManager@@QAEHXZ	; CCryptManager::MakeRandomKeyTable
EXTRN	__imp__GetTickCount@0:NEAR
; Function compile flags: /Ogsy
;	COMDAT ?MakeRandomKeyTable@CCryptManager@@QAEHXZ
_TEXT	SEGMENT
_random$ = -2508					; size = 2508
?MakeRandomKeyTable@CCryptManager@@QAEHXZ PROC NEAR	; CCryptManager::MakeRandomKeyTable, COMDAT
; _this$ = ecx

; 777  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 09 00
	00		 sub	 esp, 2508		; 000009ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 778  : 	m_dwMakeRandKey = GetTickCount();

  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 779  : 	if(m_dwMakeRandKey == 0)

  00013	33 db		 xor	 ebx, ebx
  00015	3b c3		 cmp	 eax, ebx
  00017	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0001a	75 04		 jne	 SHORT $L99818

; 780  : 		return false;

  0001c	33 c0		 xor	 eax, eax
  0001e	eb 65		 jmp	 SHORT $L99817
$L99818:

; 781  : 
; 782  : 	int iTransformSize = m_nTotalSize / sizeof(DWORD);

  00020	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00023	57		 push	 edi
  00024	8b f8		 mov	 edi, eax
  00026	c1 ef 02	 shr	 edi, 2

; 783  : 	if(iTransformSize == 0)

  00029	75 04		 jne	 SHORT $L99821
$L100633:

; 784  : 		return false;

  0002b	33 c0		 xor	 eax, eax
  0002d	eb 55		 jmp	 SHORT $L100632
$L99821:

; 785  : 
; 786  : 	if(m_nTotalSize == 0)

  0002f	3b c3		 cmp	 eax, ebx

; 787  : 		return false;

  00031	74 f8		 je	 SHORT $L100633

; 788  : 
; 789  : 	m_pRandomTable = new BYTE[m_nTotalSize];

  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 790  : #ifdef __LINUX__
; 791  : 	memset(m_pRandomTable, 0, m_nTotalSize);
; 792  : #else
; 793  : 	ZeroMemory(m_pRandomTable, m_nTotalSize);

  00039	ff 76 08	 push	 DWORD PTR [esi+8]
  0003c	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0003f	53		 push	 ebx
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _memset
  00046	83 c4 10	 add	 esp, 16			; 00000010H

; 794  : #endif
; 795  : 	CRandom random;

  00049	8d 8d 34 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  0004f	e8 00 00 00 00	 call	 ??0CRandom@@QAE@XZ	; CRandom::CRandom

; 796  : 
; 797  : 	random.SeedMT(m_dwMakeRandKey);

  00054	ff 76 10	 push	 DWORD PTR [esi+16]
  00057	8d 8d 34 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  0005d	e8 00 00 00 00	 call	 ?SeedMT@CRandom@@QAEXK@Z ; CRandom::SeedMT

; 798  : 
; 799  : 	for(int i = 0; i < iTransformSize; i++)

  00062	3b fb		 cmp	 edi, ebx
  00064	7e 1b		 jle	 SHORT $L99829
$L99827:

; 800  : 		*((DWORD*)(m_pRandomTable + i*sizeof(DWORD))) = *((DWORD*)(m_pCryptTable + i*sizeof(DWORD))) ^ random.RandomMT();

  00066	8d 8d 34 f6 ff
	ff		 lea	 ecx, DWORD PTR _random$[ebp]
  0006c	e8 00 00 00 00	 call	 ?RandomMT@CRandom@@QAEKXZ ; CRandom::RandomMT
  00071	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00073	33 04 99	 xor	 eax, DWORD PTR [ecx+ebx*4]
  00076	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00079	89 04 99	 mov	 DWORD PTR [ecx+ebx*4], eax
  0007c	43		 inc	 ebx
  0007d	3b df		 cmp	 ebx, edi
  0007f	7c e5		 jl	 SHORT $L99827
$L99829:

; 801  : 
; 802  : 	return true;

  00081	33 c0		 xor	 eax, eax
  00083	40		 inc	 eax
$L100632:
  00084	5f		 pop	 edi
$L99817:
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx

; 803  : }

  00087	c9		 leave
  00088	c3		 ret	 0
?MakeRandomKeyTable@CCryptManager@@QAEHXZ ENDP		; CCryptManager::MakeRandomKeyTable
_TEXT	ENDS
PUBLIC	?Encrypt@CCryptManager@@QAEXPAU_PACKETDATA@@@Z	; CCryptManager::Encrypt
; Function compile flags: /Ogsy
;	COMDAT ?Encrypt@CCryptManager@@QAEXPAU_PACKETDATA@@@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?Encrypt@CCryptManager@@QAEXPAU_PACKETDATA@@@Z PROC NEAR ; CCryptManager::Encrypt, COMDAT
; _this$ = ecx

; 287  : {

  00000	56		 push	 esi

; 288  : //	if((data->m_wMsgType == 0x0101) || 
; 289  : //		(data->m_wMsgType == 0x0102) ||
; 290  : //		(data->m_wMsgType == 0x0103))
; 291  : //	{
; 292  : //		data->m_wMsgType = (WORD)(data->m_wMsgType ^ data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY);
; 293  : //#ifdef __LINUX__
; 294  : //		data->m_Key.dwKey = data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 295  : //#else
; 296  : //		data->m_Key.dwKey = _lrotl(data->m_Key.dwKey, *(data->m_Buffer)%32) ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 297  : //#endif
; 298  : //		return;
; 299  : //	}
; 300  : 	if(data->m_wMsgSize == 0)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _data$[esp]
  00005	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	75 19		 jne	 SHORT $L99608

; 301  : 	{
; 302  : 		data->m_Key.dwKey = 0;

  0000d	83 66 06 00	 and	 DWORD PTR [esi+6], 0

; 303  : 		data->m_wMsgType = (WORD)(data->m_wMsgType ^ data->m_Key.dwKey ^ CRYPTION_KEY);

  00011	33 c0		 xor	 eax, eax
  00013	66 8b 46 06	 mov	 ax, WORD PTR [esi+6]
  00017	66 33 46 04	 xor	 ax, WORD PTR [esi+4]
  0001b	35 61 73 00 00	 xor	 eax, 29537		; 00007361H
  00020	66 89 46 04	 mov	 WORD PTR [esi+4], ax

; 304  : 		return;

  00024	eb 32		 jmp	 SHORT $L99611
$L99608:

; 305  : 	}
; 306  : 
; 307  : 	switch(rand()%3)

  00026	e8 00 00 00 00	 call	 _rand
  0002b	6a 03		 push	 3
  0002d	99		 cdq
  0002e	59		 pop	 ecx
  0002f	f7 f9		 idiv	 ecx
  00031	83 ea 00	 sub	 edx, 0
  00034	74 1a		 je	 SHORT $L99614
  00036	4a		 dec	 edx
  00037	74 0d		 je	 SHORT $L99615
  00039	4a		 dec	 edx
  0003a	75 1c		 jne	 SHORT $L99611

; 315  : 	case 2:
; 316  : 		Encrypt3(data);

  0003c	56		 push	 esi
  0003d	8b cf		 mov	 ecx, edi
  0003f	e8 00 00 00 00	 call	 ?Encrypt3@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ; CCryptManager::Encrypt3

; 317  : 		break;

  00044	eb 12		 jmp	 SHORT $L99611
$L99615:

; 311  : 		break;
; 312  : 	case 1:
; 313  : 		Encrypt2(data);

  00046	56		 push	 esi
  00047	8b cf		 mov	 ecx, edi
  00049	e8 00 00 00 00	 call	 ?Encrypt2@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ; CCryptManager::Encrypt2

; 314  : 		break;

  0004e	eb 08		 jmp	 SHORT $L99611
$L99614:

; 308  : 	{
; 309  : 	case 0:
; 310  : 		Encrypt1(data);

  00050	56		 push	 esi
  00051	8b cf		 mov	 ecx, edi
  00053	e8 00 00 00 00	 call	 ?Encrypt1@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ; CCryptManager::Encrypt1
$L99611:
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi

; 318  : 	}
; 319  : }

  0005a	c2 04 00	 ret	 4
?Encrypt@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ENDP	; CCryptManager::Encrypt
_TEXT	ENDS
PUBLIC	?Decrypt@CCryptManager@@QAEHPAU_PACKETDATA@@@Z	; CCryptManager::Decrypt
; Function compile flags: /Ogsy
;	COMDAT ?Decrypt@CCryptManager@@QAEHPAU_PACKETDATA@@@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?Decrypt@CCryptManager@@QAEHPAU_PACKETDATA@@@Z PROC NEAR ; CCryptManager::Decrypt, COMDAT
; _this$ = ecx

; 423  : /*	if(data->m_wMsgSize == 0)
; 424  : 	{
; 425  : 		data->m_Key.dwKey = 0;
; 426  : 		data->m_wMsgType = (WORD)(data->m_wMsgType ^ data->m_Key.dwKey ^ CRYPTION_KEY);
; 427  : 		return true;
; 428  : 	}
; 429  : //	data->m_Key.dwKey = data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 430  : #ifndef __LINUX__
; 431  : 	data->m_Key.dwKey = _lrotr(data->m_Key.dwKey, *(data->m_Buffer)%32);
; 432  : #endif
; 433  : //	data->m_wMsgType = data->m_wMsgType ^ data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY;
; 434  : 	data->m_wMsgType = (WORD)(data->m_wMsgType ^ data->m_Key.dwKey ^ *((DWORD*)(data->m_Buffer)) ^ CRYPTION_KEY);
; 435  : */
; 436  : 	if(data->m_wMsgSize <= 0)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _data$[esp-4]
  00004	83 3a 00	 cmp	 DWORD PTR [edx], 0

; 437  : 		return true;

  00007	76 2c		 jbe	 SHORT $L99679

; 438  : 	//if((data->m_wMsgType == 0x0101) || 
; 439  : 	//	(data->m_wMsgType == 0x0102) ||
; 440  : 	//	(data->m_wMsgType == 0x0103))
; 441  : 	//	return true;
; 442  : 
; 443  : 	switch(data->m_Key.KeyValue.type)

  00009	8b 42 06	 mov	 eax, DWORD PTR [edx+6]
  0000c	c1 e8 1c	 shr	 eax, 28			; 0000001cH
  0000f	48		 dec	 eax
  00010	74 1d		 je	 SHORT $L99682
  00012	48		 dec	 eax
  00013	48		 dec	 eax
  00014	74 11		 je	 SHORT $L99683
  00016	83 e8 05	 sub	 eax, 5
  00019	74 04		 je	 SHORT $L99684

; 460  : 	default:
; 461  : 		return false;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 19		 jmp	 SHORT $L99676
$L99684:

; 455  : 	case CRYPT_TYPE3:
; 456  : 		{
; 457  : 			Decrypt3(data);

  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ?Decrypt3@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ; CCryptManager::Decrypt3

; 458  : 		}
; 459  : 		break;

  00025	eb 0e		 jmp	 SHORT $L99679
$L99683:

; 448  : 		}
; 449  : 		break;
; 450  : 	case CRYPT_TYPE2:
; 451  : 		{
; 452  : 			Decrypt2(data);

  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 ?Decrypt2@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ; CCryptManager::Decrypt2

; 453  : 		}
; 454  : 		break;

  0002d	eb 06		 jmp	 SHORT $L99679
$L99682:

; 444  : 	{
; 445  : 	case CRYPT_TYPE1:
; 446  : 		{
; 447  : 			Decrypt1(data);

  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ?Decrypt1@CCryptManager@@QAEXPAU_PACKETDATA@@@Z ; CCryptManager::Decrypt1
$L99679:

; 462  : 	}
; 463  : 
; 464  : 	return true;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
$L99676:

; 465  : }

  00038	c2 04 00	 ret	 4
?Decrypt@CCryptManager@@QAEHPAU_PACKETDATA@@@Z ENDP	; CCryptManager::Decrypt
_TEXT	ENDS
PUBLIC	?InitCryptManager@CCryptManager@@QAEH_N@Z	; CCryptManager::InitCryptManager
; Function compile flags: /Ogsy
;	COMDAT ?InitCryptManager@CCryptManager@@QAEH_N@Z
_TEXT	SEGMENT
_bMakeRandomTable$ = 8					; size = 1
?InitCryptManager@CCryptManager@@QAEH_N@Z PROC NEAR	; CCryptManager::InitCryptManager, COMDAT
; _this$ = ecx

; 761  : 	if(!LoadTable())

  00000	e8 00 00 00 00	 call	 ?LoadTable@CCryptManager@@IAEHXZ ; CCryptManager::LoadTable
  00005	85 c0		 test	 eax, eax
  00007	74 11		 je	 SHORT $L99812
$L99813:

; 762  : 	{
; 763  : 		return false;
; 764  : 	}
; 765  : 	//LoadTable2();
; 766  : //#ifndef __LINUX__
; 767  : //	srand((unsigned)time(NULL));
; 768  : //#endif
; 769  : 	
; 770  : 	if(bMakeRandomTable)

  00009	80 7c 24 04 00	 cmp	 BYTE PTR _bMakeRandomTable$[esp-4], 0
  0000e	74 07		 je	 SHORT $L99814

; 771  : 		return MakeRandomKeyTable();

  00010	e8 00 00 00 00	 call	 ?MakeRandomKeyTable@CCryptManager@@QAEHXZ ; CCryptManager::MakeRandomKeyTable
  00015	eb 03		 jmp	 SHORT $L99812
$L99814:

; 772  : 
; 773  : 	return true;

  00017	33 c0		 xor	 eax, eax
  00019	40		 inc	 eax
$L99812:

; 774  : }

  0001a	c2 04 00	 ret	 4
?InitCryptManager@CCryptManager@@QAEH_N@Z ENDP		; CCryptManager::InitCryptManager
_TEXT	ENDS
END
