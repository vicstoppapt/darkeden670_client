; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\Client\TickTimer.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?Clear@CTimeCtrl@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CTimeCtrl@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCTimeCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetEnable@CTickTimer@@QAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEnable@CTickTimer@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTickTimer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CTickTimer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTickTimer@@QAE@K_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartTimer@CTickTimer@@QAEXK_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetTimer@CTickTimer@@QAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTimeLimit@CTickTimer@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CTimeCtrl@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CTimeCtrl@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CTimeCtrl@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCTimeCtrl@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CTimeCtrl@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CTimeCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?SetEnable@CTickTimer@@QAEX_N@Z			; CTickTimer::SetEnable
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\client\ticktimer.h
;	COMDAT ?SetEnable@CTickTimer@@QAEX_N@Z
_TEXT	SEGMENT
_enable$ = 8						; size = 1
?SetEnable@CTickTimer@@QAEX_N@Z PROC NEAR		; CTickTimer::SetEnable, COMDAT
; _this$ = ecx

; 85   : 	void		SetEnable(bool enable = true)	{ m_bEnable = enable;		}

  00000	8a 44 24 04	 mov	 al, BYTE PTR _enable$[esp-4]
  00004	88 41 11	 mov	 BYTE PTR [ecx+17], al
  00007	c2 04 00	 ret	 4
?SetEnable@CTickTimer@@QAEX_N@Z ENDP			; CTickTimer::SetEnable
_TEXT	ENDS
PUBLIC	?IsEnable@CTickTimer@@QBE_NXZ			; CTickTimer::IsEnable
; Function compile flags: /Ogty
;	COMDAT ?IsEnable@CTickTimer@@QBE_NXZ
_TEXT	SEGMENT
?IsEnable@CTickTimer@@QBE_NXZ PROC NEAR			; CTickTimer::IsEnable, COMDAT
; _this$ = ecx

; 86   : 	bool		IsEnable() const				{ return m_bEnable;			}

  00000	8a 41 11	 mov	 al, BYTE PTR [ecx+17]
  00003	c3		 ret	 0
?IsEnable@CTickTimer@@QBE_NXZ ENDP			; CTickTimer::IsEnable
_TEXT	ENDS
PUBLIC	??0CTickTimer@@QAE@XZ				; CTickTimer::CTickTimer
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\client\ticktimer.cpp
;	COMDAT ??0CTickTimer@@QAE@XZ
_TEXT	SEGMENT
??0CTickTimer@@QAE@XZ PROC NEAR				; CTickTimer::CTickTimer, COMDAT
; _this$ = ecx

; 13   : {

  00000	8b c1		 mov	 eax, ecx

; 14   : 	SetEnable(false);

  00002	c6 40 11 00	 mov	 BYTE PTR [eax+17], 0

; 15   : }

  00006	c3		 ret	 0
??0CTickTimer@@QAE@XZ ENDP				; CTickTimer::CTickTimer
_TEXT	ENDS
PUBLIC	??1CTickTimer@@QAE@XZ				; CTickTimer::~CTickTimer
; Function compile flags: /Ogty
;	COMDAT ??1CTickTimer@@QAE@XZ
_TEXT	SEGMENT
??1CTickTimer@@QAE@XZ PROC NEAR				; CTickTimer::~CTickTimer, COMDAT
; _this$ = ecx

; 19   : }

  00000	c3		 ret	 0
??1CTickTimer@@QAE@XZ ENDP				; CTickTimer::~CTickTimer
_TEXT	ENDS
PUBLIC	?ResetTimer@CTickTimer@@QAEX_N@Z		; CTickTimer::ResetTimer
EXTRN	__imp__GetTickCount@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?ResetTimer@CTickTimer@@QAEX_N@Z
_TEXT	SEGMENT
_nextLimit$ = 8						; size = 1
?ResetTimer@CTickTimer@@QAEX_N@Z PROC NEAR		; CTickTimer::ResetTimer, COMDAT
; _this$ = ecx

; 35   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 36   : 	m_dwRestartTime	= GetTickCount();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 37   : 	m_bNextLimit	= nextLimit;
; 38   : 	m_dwTimeLimit	= m_dwTickSize + m_dwRestartTime;

  00009	8b 16		 mov	 edx, DWORD PTR [esi]
  0000b	8a 4c 24 08	 mov	 cl, BYTE PTR _nextLimit$[esp]
  0000f	03 d0		 add	 edx, eax
  00011	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00014	88 4e 10	 mov	 BYTE PTR [esi+16], cl
  00017	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  0001a	5e		 pop	 esi

; 39   : }

  0001b	c2 04 00	 ret	 4
?ResetTimer@CTickTimer@@QAEX_N@Z ENDP			; CTickTimer::ResetTimer
_TEXT	ENDS
PUBLIC	?IsTimeLimit@CTickTimer@@QAE_NXZ		; CTickTimer::IsTimeLimit
; Function compile flags: /Ogty
;	COMDAT ?IsTimeLimit@CTickTimer@@QAE_NXZ
_TEXT	SEGMENT
?IsTimeLimit@CTickTimer@@QAE_NXZ PROC NEAR		; CTickTimer::IsTimeLimit, COMDAT
; _this$ = ecx

; 42   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 43   : 	if(!IsEnable()) return false;

  00003	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00006	84 c0		 test	 al, al
  00008	75 04		 jne	 SHORT $L74014
  0000a	32 c0		 xor	 al, al
  0000c	5e		 pop	 esi

; 53   : 	}
; 54   : }

  0000d	c3		 ret	 0
$L74014:

; 44   : 
; 45   : 	if(m_bNextLimit || GetTickCount() >= m_dwTimeLimit)

  0000e	8a 46 10	 mov	 al, BYTE PTR [esi+16]
  00011	84 c0		 test	 al, al
  00013	57		 push	 edi
  00014	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  0001a	75 0c		 jne	 SHORT $L74016
  0001c	ff d7		 call	 edi
  0001e	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00021	73 05		 jae	 SHORT $L74016
  00023	5f		 pop	 edi

; 49   : 	}
; 50   : 	else
; 51   : 	{
; 52   : 		return false;

  00024	32 c0		 xor	 al, al
  00026	5e		 pop	 esi

; 53   : 	}
; 54   : }

  00027	c3		 ret	 0
$L74016:

; 46   : 	{
; 47   : 		ResetTimer();

  00028	ff d7		 call	 edi
  0002a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002c	03 c8		 add	 ecx, eax
  0002e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00031	5f		 pop	 edi
  00032	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  00036	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx

; 48   : 		return true;

  00039	b0 01		 mov	 al, 1
  0003b	5e		 pop	 esi

; 53   : 	}
; 54   : }

  0003c	c3		 ret	 0
?IsTimeLimit@CTickTimer@@QAE_NXZ ENDP			; CTickTimer::IsTimeLimit
_TEXT	ENDS
PUBLIC	?StartTimer@CTickTimer@@QAEXK_N@Z		; CTickTimer::StartTimer
EXTRN	__imp__timeGetTime@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?StartTimer@CTickTimer@@QAEXK_N@Z
_TEXT	SEGMENT
_tickSize$ = 8						; size = 4
_nextLimit$ = 12					; size = 1
?StartTimer@CTickTimer@@QAEXK_N@Z PROC NEAR		; CTickTimer::StartTimer, COMDAT
; _this$ = ecx

; 27   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 28   : 	m_dwStartTime	= timeGetTime();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00009	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 29   : 	m_dwTickSize	= tickSize;

  0000c	8b 44 24 08	 mov	 eax, DWORD PTR _tickSize$[esp]
  00010	89 06		 mov	 DWORD PTR [esi], eax

; 30   : 	ResetTimer(nextLimit);

  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00018	8b 16		 mov	 edx, DWORD PTR [esi]
  0001a	8a 4c 24 0c	 mov	 cl, BYTE PTR _nextLimit$[esp]
  0001e	03 d0		 add	 edx, eax
  00020	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00023	88 4e 10	 mov	 BYTE PTR [esi+16], cl
  00026	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 31   : 	SetEnable();

  00029	c6 46 11 01	 mov	 BYTE PTR [esi+17], 1
  0002d	5e		 pop	 esi

; 32   : }

  0002e	c2 08 00	 ret	 8
?StartTimer@CTickTimer@@QAEXK_N@Z ENDP			; CTickTimer::StartTimer
_TEXT	ENDS
PUBLIC	??0CTickTimer@@QAE@K_N@Z			; CTickTimer::CTickTimer
; Function compile flags: /Ogty
;	COMDAT ??0CTickTimer@@QAE@K_N@Z
_TEXT	SEGMENT
_tickSize$ = 8						; size = 4
_nextLimit$ = 12					; size = 1
??0CTickTimer@@QAE@K_N@Z PROC NEAR			; CTickTimer::CTickTimer, COMDAT
; _this$ = ecx

; 22   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 23   : 	StartTimer(tickSize, nextLimit);

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00009	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000c	8b 44 24 08	 mov	 eax, DWORD PTR _tickSize$[esp]
  00010	89 06		 mov	 DWORD PTR [esi], eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00018	8b 16		 mov	 edx, DWORD PTR [esi]
  0001a	8a 4c 24 0c	 mov	 cl, BYTE PTR _nextLimit$[esp]
  0001e	03 d0		 add	 edx, eax
  00020	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00023	88 4e 10	 mov	 BYTE PTR [esi+16], cl
  00026	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00029	c6 46 11 01	 mov	 BYTE PTR [esi+17], 1

; 24   : }

  0002d	8b c6		 mov	 eax, esi
  0002f	5e		 pop	 esi
  00030	c2 08 00	 ret	 8
??0CTickTimer@@QAE@K_N@Z ENDP				; CTickTimer::CTickTimer
_TEXT	ENDS
END
