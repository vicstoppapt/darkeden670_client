; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\New - vs_ui\src\hangul\FL2.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BN@ODLNCKCA@Data?2?2Info?2?2ClientConfig?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@DFPLPGPC@Data?2?2Info?2?2GuildMapper?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@LHODHNBK@Data?2?2Info?2?2GuildVersion?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@DDPLNCOL@Data?2?2Info?2?2Player?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@ILLNAPHB@Data?2?2Info?2?2Resolution?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@HEIGFDLG@Data?2?2Info?2?2SelectedChannel?4inf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JCJOPEPL@?$CFd?$LO?o?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GDOJEDNK@?$CFd?$LI?$LI?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?g_Print@@YAXHHPBDPAUPrintInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_PrintColorStr@@YAHHHPBDAAUPrintInfo@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Is565@CDirectDraw@@SA_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Red@CDirectDraw@@SAEABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Green@CDirectDraw@@SAEABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blue@CDirectDraw@@SAEABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClipLeftTop@CDirectDrawSurface@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClipRightBottom@CDirectDrawSurface@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?start@CNFS@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@CNFS@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@VirtualFileHeader@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1IFileIO@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GIFileIO@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iovfs_base@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Giovfs_base@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1iovfs_base@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@iovfs_base@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Givfstream@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ivfstream@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?open@ivfstream@@UAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Govfstream@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ovfstream@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?open@ovfstream@@UAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ITypePackBase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GITypePackBase@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsInit@CSpritePalBase@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@ACriticalSection@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@ACriticalSection@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_SetFL2Surface@@YAXPAUIDirectDrawSurface7@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_PossibleStringCut@@YA_NPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_GetStringWidth2@@YAHPBDHPAUHFONT__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_GetStringIndexByWidth@@YAHPBDHPAUHFONT__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_PrintColorStr2@@YAHHHPBDAAUPrintInfo@@KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_GetStringWidth@@YAHPBDPAUHFONT__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_GetStringHeight@@YAHPBDPAUHFONT__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_MakeLinefeedString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@PADHPAUHFONT__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_DrawText@@YAXPAUtagRECT@@PBDPAUPrintInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_DBCSLen@@YAHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_GetByteLenth@@YAHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_Convert_DBCS_Ascii2SingleByte@@YAHPBGHAAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_ConvertAscii2DBCS@@YAHPBDHAAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_FL2_GetDC@@YA_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_FL2_ReleaseDC@@YA_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReduceString@@YAXPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReduceString2@@YAXPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReduceString3@@YAXPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_PrintColorStrLen@@YAHHHPBDHAAUPrintInfo@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_PrintColorStrOut@@YAHHHPBDAAUPrintInfo@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_PrintColorStrShadow@@YAHHHPBDAAUPrintInfo@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_GetNumberString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_GetStringByMoney@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@IPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@GV?$char_traits@G@_STL@@V?$allocator@G@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@GV?$char_traits@G@_STL@@V?$allocator@G@2@@_STL@@QBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$list@PAVWindow@@V?$allocator@PAVWindow@@@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$list@PAVWindow@@V?$allocator@PAVWindow@@@_STL@@@_STL@@QBE?AU?$_List_iterator@PAVWindow@@U?$_Const_traits@PAVWindow@@@_STL@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVWindow@@V?$allocator@PAVWindow@@@_STL@@@_STL@@QBE?AU?$_List_iterator@PAVWindow@@U?$_Const_traits@PAVWindow@@@_STL@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_iterator@PAVWindow@@U?$_Const_traits@PAVWindow@@@_STL@@@_STL@@QAE@PAU?$_List_node@PAVWindow@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$SimpleDataList@PAVPI_Processor@@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$SimpleDataList@PAVLineEditorVisual@@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@PBDABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$SimpleDataList@PAVWindow@@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$SimpleDataList@PAUMESSAGE@@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_throw_out_of_range@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEXPADPBD1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@U?$_List_iterator@PAVWindow@@U?$_Const_traits@PAVWindow@@@_STL@@@_STL@@@_STL@@YAHABU?$_List_iterator@PAVWindow@@U?$_Const_traits@PAVWindow@@@_STL@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$SimpleDataList@PAVPI_Processor@@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$SimpleDataList@PAVLineEditorVisual@@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$SimpleDataList@PAVWindow@@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$SimpleDataList@PAUMESSAGE@@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_insert_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@U?$_List_iterator@PAVWindow@@U?$_Const_traits@PAVWindow@@@_STL@@@_STL@@@_STL@@YAHABU?$_List_iterator@PAVWindow@@U?$_Const_traits@PAVWindow@@@_STL@@@0@0ABUinput_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_append_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABU__false_type@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$_List_iterator@PAVWindow@@U?$_Const_traits@PAVWindow@@@_STL@@@_STL@@QAEAAU01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_move@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$advance@PBDH@_STL@@YAXAAPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__advance@PBDH@_STL@@YAXAAPBDHABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$SimpleDataList@PAVLineEditorVisual@@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ITypePackBase@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$SimpleDataList@PAUMESSAGE@@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$SimpleDataList@PAVPI_Processor@@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$SimpleDataList@PAVWindow@@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$SimpleDataList@PAVLineEditorVisual@@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ITypePackBase@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$SimpleDataList@PAUMESSAGE@@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$SimpleDataList@PAVPI_Processor@@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$SimpleDataList@PAVWindow@@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@IFileIO@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$SimpleDataList@PAVLineEditorVisual@@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ITypePackBase@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ovfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ivfstream@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$SimpleDataList@PAUMESSAGE@@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$SimpleDataList@PAVPI_Processor@@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@iovfs_base@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$SimpleDataList@PAVWindow@@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVIFileIO@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$SimpleDataList@PAVLineEditorVisual@@@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVITypePackBase@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVovfstream@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVivfstream@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$SimpleDataList@PAUMESSAGE@@@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$SimpleDataList@PAVPI_Processor@@@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AViovfs_base@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$SimpleDataList@PAVWindow@@@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4IFileIO@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$SimpleDataList@PAVLineEditorVisual@@@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ITypePackBase@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ovfstream@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ivfstream@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$SimpleDataList@PAUMESSAGE@@@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$SimpleDataList@PAVPI_Processor@@@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4iovfs_base@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$SimpleDataList@PAVWindow@@@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_incr@_List_iterator_base@_STL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9_List_iterator_base@_STL@@QBE_NABU01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$SimpleDataList@PAUMESSAGE@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$SimpleDataList@PAVWindow@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$SimpleDataList@PAVLineEditorVisual@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$SimpleDataList@PAVPI_Processor@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_List_iterator_base@_STL@@QAE@PAU_List_node_base@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@_STL@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ITypePackBase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ovfstream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ivfstream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7iovfs_base@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IFileIO@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A	; gpC_fl2_surface
PUBLIC	?gh_FL2_DC@@3PAUHDC__@@A			; gh_FL2_DC
_BSS	SEGMENT
?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A DD 01H DUP (?) ; gpC_fl2_surface
?gh_FL2_DC@@3PAUHDC__@@A DD 01H DUP (?)			; gh_FL2_DC
_BSS	ENDS
PUBLIC	?__stl_new@_STL@@YAPAXI@Z			; _STL::__stl_new
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_new.h
;	COMDAT ?__stl_new@_STL@@YAPAXI@Z
_TEXT	SEGMENT
___n$ = 8						; size = 4
?__stl_new@_STL@@YAPAXI@Z PROC NEAR			; _STL::__stl_new, COMDAT

; 86   : inline void*  _STLP_CALL __stl_new(size_t __n)   { _STLP_CHECK_NULL_ALLOC(::operator _STLP_NEW(__n)); }

  00000	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
?__stl_new@_STL@@YAPAXI@Z ENDP				; _STL::__stl_new
_TEXT	ENDS
PUBLIC	?__stl_delete@_STL@@YAXPAX@Z			; _STL::__stl_delete
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ?__stl_delete@_STL@@YAXPAX@Z
_TEXT	SEGMENT
___p$ = 8						; size = 4
?__stl_delete@_STL@@YAXPAX@Z PROC NEAR			; _STL::__stl_delete, COMDAT

; 87   : inline void   _STLP_CALL __stl_delete(void* __p) { ::operator delete(__p); }

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?__stl_delete@_STL@@YAXPAX@Z ENDP			; _STL::__stl_delete
_TEXT	ENDS
PUBLIC	?_Destroy@_STL@@YAXPAD0@Z			; _STL::_Destroy
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_construct.h
;	COMDAT ?_Destroy@_STL@@YAXPAD0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Destroy@_STL@@YAXPAD0@Z PROC NEAR			; _STL::_Destroy, COMDAT

; 142  : inline void _Destroy(char*, char*) {}

  00000	c3		 ret	 0
?_Destroy@_STL@@YAXPAD0@Z ENDP				; _STL::_Destroy
_TEXT	ENDS
PUBLIC	?__copy_trivial@_STL@@YAPAXPBX0PAX@Z		; _STL::__copy_trivial
EXTRN	_memmove:NEAR
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_algobase.h
;	COMDAT ?__copy_trivial@_STL@@YAPAXPBX0PAX@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
___result$ = 16						; size = 4
?__copy_trivial@_STL@@YAPAXPBX0PAX@Z PROC NEAR		; _STL::__copy_trivial, COMDAT

; 148  :   return (__last == __first) ? __result : 
; 149  :     ((char*)memmove(__result, __first, ((const char*)__last - (const char*)__first))) + 
; 150  :     ((const char*)__last - (const char*)__first);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___first$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR ___last$[esp]
  00009	3b f0		 cmp	 esi, eax
  0000b	75 06		 jne	 SHORT $L90049
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR ___result$[esp]
  00011	5e		 pop	 esi

; 151  : }

  00012	c3		 ret	 0
$L90049:

; 148  :   return (__last == __first) ? __result : 
; 149  :     ((char*)memmove(__result, __first, ((const char*)__last - (const char*)__first))) + 
; 150  :     ((const char*)__last - (const char*)__first);

  00013	2b f0		 sub	 esi, eax
  00015	56		 push	 esi
  00016	50		 push	 eax
  00017	8b 44 24 18	 mov	 eax, DWORD PTR ___result$[esp+8]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 151  : }

  00027	c3		 ret	 0
?__copy_trivial@_STL@@YAPAXPBX0PAX@Z ENDP		; _STL::__copy_trivial
_TEXT	ENDS
PUBLIC	?uninitialized_copy@_STL@@YAPADPBD0PAD@Z	; _STL::uninitialized_copy
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_uninitialized.h
;	COMDAT ?uninitialized_copy@_STL@@YAPADPBD0PAD@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
___result$ = 16						; size = 4
?uninitialized_copy@_STL@@YAPADPBD0PAD@Z PROC NEAR	; _STL::uninitialized_copy, COMDAT

; 84   :   return  (char*)__copy_trivial (__first, __last, __result);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___first$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR ___last$[esp]
  00009	3b f0		 cmp	 esi, eax
  0000b	75 06		 jne	 SHORT $L90059
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR ___result$[esp]
  00011	5e		 pop	 esi

; 85   : }

  00012	c3		 ret	 0

; 84   :   return  (char*)__copy_trivial (__first, __last, __result);

$L90059:
  00013	2b f0		 sub	 esi, eax
  00015	56		 push	 esi
  00016	50		 push	 eax
  00017	8b 44 24 18	 mov	 eax, DWORD PTR ___result$[esp+8]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 85   : }

  00027	c3		 ret	 0
?uninitialized_copy@_STL@@YAPADPBD0PAD@Z ENDP		; _STL::uninitialized_copy
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@_STL@@SAIPBD@Z		; _STL::char_traits<char>::length
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\char_traits.h
;	COMDAT ?length@?$char_traits@D@_STL@@SAIPBD@Z
_TEXT	SEGMENT
___s$ = 8						; size = 4
?length@?$char_traits@D@_STL@@SAIPBD@Z PROC NEAR	; _STL::char_traits<char>::length, COMDAT

; 238  :   static size_t _STLP_CALL length(const char* __s) { return strlen(__s); }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___s$[esp-4]
  00004	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L90064:
  00007	8a 08		 mov	 cl, BYTE PTR [eax]
  00009	40		 inc	 eax
  0000a	84 c9		 test	 cl, cl
  0000c	75 f9		 jne	 SHORT $L90064
  0000e	2b c2		 sub	 eax, edx
  00010	c3		 ret	 0
?length@?$char_traits@D@_STL@@SAIPBD@Z ENDP		; _STL::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@_STL@@SAXAADABD@Z	; _STL::char_traits<char>::assign
; Function compile flags: /Ogty
;	COMDAT ?assign@?$char_traits@D@_STL@@SAXAADABD@Z
_TEXT	SEGMENT
___c1$ = 8						; size = 4
___c2$ = 12						; size = 4
?assign@?$char_traits@D@_STL@@SAXAADABD@Z PROC NEAR	; _STL::char_traits<char>::assign, COMDAT

; 240  :   static void _STLP_CALL assign(char& __c1, const char& __c2) { __c1 = __c2; }

  00000	8b 44 24 08	 mov	 eax, DWORD PTR ___c2$[esp-4]
  00004	8a 08		 mov	 cl, BYTE PTR [eax]
  00006	8b 54 24 04	 mov	 edx, DWORD PTR ___c1$[esp-4]
  0000a	88 0a		 mov	 BYTE PTR [edx], cl
  0000c	c3		 ret	 0
?assign@?$char_traits@D@_STL@@SAXAADABD@Z ENDP		; _STL::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?g_SetFL2Surface@@YAXPAUIDirectDrawSurface7@@@Z	; g_SetFL2Surface
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\new - vs_ui\src\hangul\fl2.cpp
;	COMDAT ?g_SetFL2Surface@@YAXPAUIDirectDrawSurface7@@@Z
_TEXT	SEGMENT
_surface$ = 8						; size = 4
?g_SetFL2Surface@@YAXPAUIDirectDrawSurface7@@@Z PROC NEAR ; g_SetFL2Surface, COMDAT

; 29   : 	gpC_fl2_surface = surface;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _surface$[esp-4]
  00004	a3 00 00 00 00	 mov	 DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A, eax ; gpC_fl2_surface

; 30   : }

  00009	c3		 ret	 0
?g_SetFL2Surface@@YAXPAUIDirectDrawSurface7@@@Z ENDP	; g_SetFL2Surface
_TEXT	ENDS
PUBLIC	?g_PossibleStringCut@@YA_NPBDH@Z		; g_PossibleStringCut
; Function compile flags: /Ogty
;	COMDAT ?g_PossibleStringCut@@YA_NPBDH@Z
_TEXT	SEGMENT
_sz_str$ = 8						; size = 4
_position$ = 12						; size = 4
?g_PossibleStringCut@@YA_NPBDH@Z PROC NEAR		; g_PossibleStringCut, COMDAT

; 39   : {

  00000	56		 push	 esi

; 40   : 	if (sz_str != NULL)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _sz_str$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 41		 je	 SHORT $L88423

; 41   : 	{
; 42   : 		if ((int)strlen(sz_str) <= position)

  00009	8b c6		 mov	 eax, esi
  0000b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000e	8b ff		 npad	 2
$L90076:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L90076
  00017	2b c2		 sub	 eax, edx
  00019	8b 54 24 0c	 mov	 edx, DWORD PTR _position$[esp]
  0001d	3b c2		 cmp	 eax, edx

; 43   : 			return true;

  0001f	7e 25		 jle	 SHORT $L88438

; 44   : 
; 45   : 		//
; 46   : 		// positionñÕ? Ðü?×» ÷úöáÕÉ data? ?? ? ?õµ.
; 47   : 		//
; 48   : 		// (1) ASCII
; 49   : 		// (2) ÊµÞ¢ 1 byte
; 50   : 		// (3) ÊµÞ¢ 2 byte
; 51   : 		//
; 52   : 		// øÉ?óÝ (3)ÕÉ ÷úöá øÉ ?? ASCII? ñÐ?äù? ×Ø?ó¦ ? ?õµ.
; 53   : 		// øÉ?? ??ù¼Úñ position?×» ø¢?ÜË òÚÎý Êµõµ.
; 54   : 		//
; 55   : 		enum _CODE
; 56   : 		{
; 57   : 			_ENG,
; 58   : 			_HAN,
; 59   : 		};
; 60   : 
; 61   : 		_CODE code = _ENG;
; 62   : 		int i;
; 63   : 		for (i=0; i <= position; i++)

  00021	33 c0		 xor	 eax, eax
  00023	85 d2		 test	 edx, edx
  00025	7c 1f		 jl	 SHORT $L88438
$L88431:

; 64   : 		{
; 65   : 			if ((BYTE)sz_str[i] > 128) // no ASCII?

  00027	80 3c 30 80	 cmp	 BYTE PTR [eax+esi], 128	; 00000080H
  0002b	76 08		 jbe	 SHORT $L88435

; 66   : 			{
; 67   : 				i++;

  0002d	40		 inc	 eax

; 68   : 				code = _HAN;

  0002e	b9 01 00 00 00	 mov	 ecx, 1

; 69   : 			}
; 70   : 			else

  00033	eb 02		 jmp	 SHORT $L88432
$L88435:

; 71   : 				code = _ENG;

  00035	33 c9		 xor	 ecx, ecx
$L88432:

; 44   : 
; 45   : 		//
; 46   : 		// positionñÕ? Ðü?×» ÷úöáÕÉ data? ?? ? ?õµ.
; 47   : 		//
; 48   : 		// (1) ASCII
; 49   : 		// (2) ÊµÞ¢ 1 byte
; 50   : 		// (3) ÊµÞ¢ 2 byte
; 51   : 		//
; 52   : 		// øÉ?óÝ (3)ÕÉ ÷úöá øÉ ?? ASCII? ñÐ?äù? ×Ø?ó¦ ? ?õµ.
; 53   : 		// øÉ?? ??ù¼Úñ position?×» ø¢?ÜË òÚÎý Êµõµ.
; 54   : 		//
; 55   : 		enum _CODE
; 56   : 		{
; 57   : 			_ENG,
; 58   : 			_HAN,
; 59   : 		};
; 60   : 
; 61   : 		_CODE code = _ENG;
; 62   : 		int i;
; 63   : 		for (i=0; i <= position; i++)

  00037	40		 inc	 eax
  00038	3b c2		 cmp	 eax, edx
  0003a	7e eb		 jle	 SHORT $L88431

; 72   : 		}
; 73   : 
; 74   : 		if (code == _HAN)

  0003c	83 f9 01	 cmp	 ecx, 1
  0003f	75 05		 jne	 SHORT $L88438

; 75   : 			if (i <= position+1)

  00041	42		 inc	 edx
  00042	3b c2		 cmp	 eax, edx

; 76   : 				return false;

  00044	7e 04		 jle	 SHORT $L88423
$L88438:

; 77   : 
; 78   : 		return true;

  00046	b0 01		 mov	 al, 1
  00048	5e		 pop	 esi

; 82   : }

  00049	c3		 ret	 0
$L88423:

; 79   : 	}
; 80   : 
; 81   : 	return false;

  0004a	32 c0		 xor	 al, al
  0004c	5e		 pop	 esi

; 82   : }

  0004d	c3		 ret	 0
?g_PossibleStringCut@@YA_NPBDH@Z ENDP			; g_PossibleStringCut
_TEXT	ENDS
PUBLIC	?g_DBCSLen@@YAHPBG@Z				; g_DBCSLen
; Function compile flags: /Ogty
;	COMDAT ?g_DBCSLen@@YAHPBG@Z
_TEXT	SEGMENT
_p_dbcs$ = 8						; size = 4
?g_DBCSLen@@YAHPBG@Z PROC NEAR				; g_DBCSLen, COMDAT

; 397  : 	if (p_dbcs == NULL)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _p_dbcs$[esp-4]

; 398  : 		return 0;

  00004	33 c0		 xor	 eax, eax
  00006	85 c9		 test	 ecx, ecx
  00008	74 10		 je	 SHORT $L88586

; 399  : 
; 400  : 	int len = 0;
; 401  : 	while (*p_dbcs++ != 0)

  0000a	66 39 01	 cmp	 WORD PTR [ecx], ax
  0000d	74 0b		 je	 SHORT $L88586
  0000f	90		 npad	 1
$L88590:
  00010	83 c1 02	 add	 ecx, 2

; 402  : 		len++;

  00013	40		 inc	 eax
  00014	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00018	75 f6		 jne	 SHORT $L88590
$L88586:

; 403  : 
; 404  : 	return len;
; 405  : }

  0001a	c3		 ret	 0
?g_DBCSLen@@YAHPBG@Z ENDP				; g_DBCSLen
_TEXT	ENDS
PUBLIC	?g_GetByteLenth@@YAHPBGH@Z			; g_GetByteLenth
; Function compile flags: /Ogty
;	COMDAT ?g_GetByteLenth@@YAHPBGH@Z
_TEXT	SEGMENT
_p_dbcs$ = 8						; size = 4
_dbcs_len$ = 12						; size = 4
?g_GetByteLenth@@YAHPBGH@Z PROC NEAR			; g_GetByteLenth, COMDAT

; 407  : {

  00000	56		 push	 esi

; 408  : 
; 409  : 	if (p_dbcs == NULL || dbcs_len <= 0)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _p_dbcs$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 2b		 je	 SHORT $L88597
  00009	8b 54 24 0c	 mov	 edx, DWORD PTR _dbcs_len$[esp]
  0000d	85 d2		 test	 edx, edx
  0000f	7e 23		 jle	 SHORT $L88597

; 411  : 	// convert
; 412  : 	for (int i=0, c=0; i < dbcs_len; i++)

  00011	33 c9		 xor	 ecx, ecx
  00013	33 c0		 xor	 eax, eax
  00015	85 d2		 test	 edx, edx
  00017	7e 1d		 jle	 SHORT $L88595
  00019	8d a4 24 00 00
	00 00		 npad	 7
$L88600:

; 413  : 	{
; 414  : 		// check high byte
; 415  : 		if ((p_dbcs[i]&0xFF00) != 0)

  00020	f6 44 4e 01 ff	 test	 BYTE PTR [esi+ecx*2+1], -1
  00025	74 05		 je	 SHORT $L88603

; 416  : 		{
; 417  : 			c+=2;

  00027	83 c0 02	 add	 eax, 2

; 418  : 		}
; 419  : 		else

  0002a	eb 01		 jmp	 SHORT $L88601
$L88603:

; 420  : 		{
; 421  : 			c++;

  0002c	40		 inc	 eax
$L88601:

; 411  : 	// convert
; 412  : 	for (int i=0, c=0; i < dbcs_len; i++)

  0002d	41		 inc	 ecx
  0002e	3b ca		 cmp	 ecx, edx
  00030	7c ee		 jl	 SHORT $L88600
  00032	5e		 pop	 esi

; 422  : 		}
; 423  : 	}
; 424  : 	return c;
; 425  : 
; 426  : }

  00033	c3		 ret	 0
$L88597:

; 410  : 		return 0;

  00034	33 c0		 xor	 eax, eax
$L88595:
  00036	5e		 pop	 esi

; 422  : 		}
; 423  : 	}
; 424  : 	return c;
; 425  : 
; 426  : }

  00037	c3		 ret	 0
?g_GetByteLenth@@YAHPBGH@Z ENDP				; g_GetByteLenth
_TEXT	ENDS
PUBLIC	??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@ ; `string'
PUBLIC	?g_Convert_DBCS_Ascii2SingleByte@@YAHPBGHAAPAD@Z ; g_Convert_DBCS_Ascii2SingleByte
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z:NEAR ; g_BasicException
;	COMDAT ??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
CONST	SEGMENT
??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@ DB '\darkeden\Des'
	DB	'igned_Common\Project\New - vs_ui\src\hangul\FL2.cpp', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?g_Convert_DBCS_Ascii2SingleByte@@YAHPBGHAAPAD@Z
_TEXT	SEGMENT
tv239 = 8						; size = 4
_p_dbcs$ = 8						; size = 4
_dbcs_len$ = 12						; size = 4
_p_new_buf$ = 16					; size = 4
?g_Convert_DBCS_Ascii2SingleByte@@YAHPBGHAAPAD@Z PROC NEAR ; g_Convert_DBCS_Ascii2SingleByte, COMDAT

; 436  : {

  00000	53		 push	 ebx

; 437  : 	//
; 438  : 	// (1) ignore 'p_new_buf'.
; 439  : 	//
; 440  : 
; 441  : 	if (p_dbcs == NULL || dbcs_len <= 0)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _p_dbcs$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	55		 push	 ebp
  00008	0f 84 e0 00 00
	00		 je	 $L88611
  0000e	8b 6c 24 10	 mov	 ebp, DWORD PTR _dbcs_len$[esp+4]
  00012	85 ed		 test	 ebp, ebp
  00014	0f 8e d4 00 00
	00		 jle	 $L88611
  0001a	56		 push	 esi
  0001b	57		 push	 edi

; 443  : 
; 444  : 	int max_size = dbcs_len*2+1;

  0001c	8d 7c 2d 01	 lea	 edi, DWORD PTR [ebp+ebp+1]

; 445  : 
; 446  : 	char * p_temp = new char[max_size];

  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4

; 447  : 	CheckMemAlloc(p_temp);

  0002b	85 f6		 test	 esi, esi
  0002d	75 15		 jne	 SHORT $L88616
  0002f	68 bf 01 00 00	 push	 447			; 000001bfH
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  00039	50		 push	 eax
  0003a	6a 01		 push	 1
  0003c	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  00041	83 c4 10	 add	 esp, 16			; 00000010H
$L88616:

; 448  : 	memset(p_temp, 0, max_size);

  00044	8b cf		 mov	 ecx, edi
  00046	8b d1		 mov	 edx, ecx
  00048	c1 e9 02	 shr	 ecx, 2
  0004b	33 c0		 xor	 eax, eax
  0004d	8b fe		 mov	 edi, esi
  0004f	f3 ab		 rep stosd
  00051	8b ca		 mov	 ecx, edx
  00053	83 e1 03	 and	 ecx, 3
  00056	f3 aa		 rep stosb

; 449  : 
; 450  : 	// convert
; 451  : 	for (int i=0, c=0; i < dbcs_len; i++)

  00058	33 c0		 xor	 eax, eax
  0005a	33 d2		 xor	 edx, edx
  0005c	85 ed		 test	 ebp, ebp
  0005e	7e 29		 jle	 SHORT $L88621
$L88619:

; 452  : 	{
; 453  : 		// check high byte
; 454  : 		if ((p_dbcs[i]&0xFF00) != 0)

  00060	66 8b 0c 43	 mov	 cx, WORD PTR [ebx+eax*2]
  00064	f6 c5 ff	 test	 ch, -1
  00067	74 0a		 je	 SHORT $L88622

; 455  : 		{
; 456  : 			*(char_t *)(p_temp+i+c) = p_dbcs[i];

  00069	8d 3c 02	 lea	 edi, DWORD PTR [edx+eax]
  0006c	66 89 0c 37	 mov	 WORD PTR [edi+esi], cx

; 457  : 			c++;

  00070	42		 inc	 edx

; 458  : 		}
; 459  : 		else

  00071	eb 11		 jmp	 SHORT $L88620
$L88622:

; 460  : 		{
; 461  : 			p_temp[i+c] = (char)(p_dbcs[i]);

  00073	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  00076	89 44 24 14	 mov	 DWORD PTR tv239[esp+12], eax
  0007a	8a 04 43	 mov	 al, BYTE PTR [ebx+eax*2]
  0007d	88 04 31	 mov	 BYTE PTR [ecx+esi], al
  00080	8b 44 24 14	 mov	 eax, DWORD PTR tv239[esp+12]
$L88620:
  00084	40		 inc	 eax
  00085	3b c5		 cmp	 eax, ebp
  00087	7c d7		 jl	 SHORT $L88619
$L88621:

; 462  : 		}
; 463  : 	}
; 464  : 
; 465  : 	int len = strlen(p_temp);

  00089	8b c6		 mov	 eax, esi
  0008b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0008e	8b ff		 npad	 2
$L90098:
  00090	8a 08		 mov	 cl, BYTE PTR [eax]
  00092	40		 inc	 eax
  00093	84 c9		 test	 cl, cl
  00095	75 f9		 jne	 SHORT $L90098
  00097	2b c2		 sub	 eax, edx
  00099	8b d8		 mov	 ebx, eax

; 466  : 	p_new_buf = new char[len+1];

  0009b	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000a4	8b 7c 24 20	 mov	 edi, DWORD PTR _p_new_buf$[esp+16]
  000a8	83 c4 04	 add	 esp, 4

; 467  : 	CheckMemAlloc(p_new_buf);

  000ab	85 c0		 test	 eax, eax
  000ad	89 07		 mov	 DWORD PTR [edi], eax
  000af	75 15		 jne	 SHORT $L88629
  000b1	68 d3 01 00 00	 push	 467			; 000001d3H
  000b6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  000bb	50		 push	 eax
  000bc	6a 01		 push	 1
  000be	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  000c3	83 c4 10	 add	 esp, 16			; 00000010H
$L88629:

; 468  : 
; 469  : 	strcpy(p_new_buf, p_temp);

  000c6	8b 17		 mov	 edx, DWORD PTR [edi]
  000c8	8b ce		 mov	 ecx, esi
  000ca	8d 9b 00 00 00
	00		 npad	 6
$L90093:
  000d0	8a 01		 mov	 al, BYTE PTR [ecx]
  000d2	41		 inc	 ecx
  000d3	88 02		 mov	 BYTE PTR [edx], al
  000d5	42		 inc	 edx
  000d6	84 c0		 test	 al, al
  000d8	75 f6		 jne	 SHORT $L90093

; 470  : 
; 471  : 	DeleteNewArray(p_temp);

  000da	85 f6		 test	 esi, esi
  000dc	74 09		 je	 SHORT $L88630
  000de	56		 push	 esi
  000df	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000e4	83 c4 04	 add	 esp, 4
$L88630:
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5d		 pop	 ebp

; 472  : 
; 473  : 	return len;

  000ea	8b c3		 mov	 eax, ebx
  000ec	5b		 pop	 ebx

; 474  : }

  000ed	c3		 ret	 0
$L88611:
  000ee	5d		 pop	 ebp

; 442  : 		return 0;

  000ef	33 c0		 xor	 eax, eax
  000f1	5b		 pop	 ebx

; 474  : }

  000f2	c3		 ret	 0
?g_Convert_DBCS_Ascii2SingleByte@@YAHPBGHAAPAD@Z ENDP	; g_Convert_DBCS_Ascii2SingleByte
_TEXT	ENDS
PUBLIC	?g_ConvertAscii2DBCS@@YAHPBDHAAPAG@Z		; g_ConvertAscii2DBCS
; Function compile flags: /Ogty
;	COMDAT ?g_ConvertAscii2DBCS@@YAHPBDHAAPAG@Z
_TEXT	SEGMENT
_p_ascii$ = 8						; size = 4
_ascii_len$ = 12					; size = 4
_p_new_buf$ = 16					; size = 4
?g_ConvertAscii2DBCS@@YAHPBDHAAPAG@Z PROC NEAR		; g_ConvertAscii2DBCS, COMDAT

; 491  : {

  00000	53		 push	 ebx

; 492  : 	if (p_ascii == NULL || ascii_len <= 0)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _p_ascii$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	55		 push	 ebp
  00008	0f 84 8d 00 00
	00		 je	 $L88638
  0000e	8b 6c 24 10	 mov	 ebp, DWORD PTR _ascii_len$[esp+4]
  00012	85 ed		 test	 ebp, ebp
  00014	0f 8e 81 00 00
	00		 jle	 $L88638
  0001a	56		 push	 esi

; 494  : 
; 495  : 	int size = ascii_len+1;
; 496  : 	char_t * p_temp = new char_t[size];

  0001b	8d 44 2d 02	 lea	 eax, DWORD PTR [ebp+ebp+2]
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00026	8b f8		 mov	 edi, eax
  00028	83 c4 04	 add	 esp, 4

; 497  : 
; 498  : 	int dbcs = 0;

  0002b	33 f6		 xor	 esi, esi

; 499  : 	for (int i=0; i<ascii_len; i++, dbcs++)

  0002d	33 c0		 xor	 eax, eax
  0002f	85 ed		 test	 ebp, ebp
  00031	7e 21		 jle	 SHORT $L88647
$L88645:

; 500  : 		if (isascii(p_ascii[i]) != 0) // ascii? or not hangul code?

  00033	8a 0c 18	 mov	 cl, BYTE PTR [eax+ebx]
  00036	80 f9 80	 cmp	 cl, 128			; 00000080H
  00039	73 0a		 jae	 SHORT $L88649

; 501  : 		{
; 502  : 			// ascii
; 503  : 
; 504  : 			p_temp[dbcs] = (char_t)p_ascii[i];

  0003b	66 0f be c9	 movsx	 cx, cl
  0003f	66 89 0c 77	 mov	 WORD PTR [edi+esi*2], cx

; 505  : 		}
; 506  : 		else

  00043	eb 09		 jmp	 SHORT $L88646
$L88649:

; 507  : 		{
; 508  : 			// hangul
; 509  : 
; 510  : 			p_temp[dbcs] = *((char_t *)(p_ascii+i));

  00045	66 8b 14 18	 mov	 dx, WORD PTR [eax+ebx]
  00049	66 89 14 77	 mov	 WORD PTR [edi+esi*2], dx

; 511  : 			i++;

  0004d	40		 inc	 eax
$L88646:
  0004e	40		 inc	 eax
  0004f	46		 inc	 esi
  00050	3b c5		 cmp	 eax, ebp
  00052	7c df		 jl	 SHORT $L88645
$L88647:

; 512  : 		}
; 513  : 
; 514  : 	// ?Ì³Êµ sizeÕÉ bufferÜË p_new_buf? ?Ý¤ùË?? Êµõµ.
; 515  : 	// ÊµÞ¢? Ðï?Ôô? dbcsËÔ ascii_len? õµÜØõµ.
; 516  : 	p_new_buf = new char_t[dbcs+1];

  00054	8d 44 36 02	 lea	 eax, DWORD PTR [esi+esi+2]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0005e	8b 5c 24 20	 mov	 ebx, DWORD PTR _p_new_buf$[esp+16]
  00062	89 03		 mov	 DWORD PTR [ebx], eax
  00064	83 c4 04	 add	 esp, 4

; 517  : 
; 518  : 	for (int m=0; m < dbcs; m++)

  00067	33 c0		 xor	 eax, eax
  00069	85 f6		 test	 esi, esi
  0006b	7e 12		 jle	 SHORT $L88658
  0006d	8d 49 00	 npad	 3
$L88656:

; 519  : 		p_new_buf[m] = p_temp[m];

  00070	66 8b 14 47	 mov	 dx, WORD PTR [edi+eax*2]
  00074	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00076	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  0007a	40		 inc	 eax
  0007b	3b c6		 cmp	 eax, esi
  0007d	7c f1		 jl	 SHORT $L88656
$L88658:

; 520  : 
; 521  : 	DeleteNewArray(p_temp);

  0007f	85 ff		 test	 edi, edi
  00081	74 09		 je	 SHORT $L88659
  00083	57		 push	 edi
  00084	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00089	83 c4 04	 add	 esp, 4
$L88659:

; 522  : 	p_new_buf[dbcs] = 0;

  0008c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0008e	5f		 pop	 edi
  0008f	66 c7 04 70 00
	00		 mov	 WORD PTR [eax+esi*2], 0

; 523  : 
; 524  : 	return dbcs;

  00095	8b c6		 mov	 eax, esi
  00097	5e		 pop	 esi
  00098	5d		 pop	 ebp
  00099	5b		 pop	 ebx

; 525  : }

  0009a	c3		 ret	 0
$L88638:
  0009b	5d		 pop	 ebp

; 493  : 		return 0;

  0009c	33 c0		 xor	 eax, eax
  0009e	5b		 pop	 ebx

; 525  : }

  0009f	c3		 ret	 0
?g_ConvertAscii2DBCS@@YAHPBDHAAPAG@Z ENDP		; g_ConvertAscii2DBCS
_TEXT	ENDS
PUBLIC	?g_FL2_GetDC@@YA_NXZ				; g_FL2_GetDC
; Function compile flags: /Ogty
;	COMDAT ?g_FL2_GetDC@@YA_NXZ
_TEXT	SEGMENT
?g_FL2_GetDC@@YA_NXZ PROC NEAR				; g_FL2_GetDC, COMDAT

; 530  : 	assert(!gpC_base->m_p_DDSurface_back->IsLock());
; 531  : 	if (gpC_fl2_surface == NULL)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00005	85 c0		 test	 eax, eax
  00007	75 1a		 jne	 SHORT $L88664

; 532  : 		_Error(NULL_REF);

  00009	68 14 02 00 00	 push	 532			; 00000214H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  00013	50		 push	 eax
  00014	6a 05		 push	 5
  00016	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00020	83 c4 10	 add	 esp, 16			; 00000010H
$L88664:

; 533  : 
; 534  : 	if(gh_FL2_DC == NULL)

  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00029	85 c9		 test	 ecx, ecx
  0002b	75 0e		 jne	 SHORT $L88665

; 535  : 	{
; 536  : 		gpC_fl2_surface->GetDC(&gh_FL2_DC);

  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00034	50		 push	 eax
  00035	ff 51 44	 call	 DWORD PTR [ecx+68]

; 537  : 
; 538  : 		return true;

  00038	b0 01		 mov	 al, 1

; 542  : }

  0003a	c3		 ret	 0
$L88665:

; 539  : 	}
; 540  : 
; 541  : 	return false;

  0003b	32 c0		 xor	 al, al

; 542  : }

  0003d	c3		 ret	 0
?g_FL2_GetDC@@YA_NXZ ENDP				; g_FL2_GetDC
_TEXT	ENDS
PUBLIC	?g_FL2_ReleaseDC@@YA_NXZ			; g_FL2_ReleaseDC
; Function compile flags: /Ogty
;	COMDAT ?g_FL2_ReleaseDC@@YA_NXZ
_TEXT	SEGMENT
?g_FL2_ReleaseDC@@YA_NXZ PROC NEAR			; g_FL2_ReleaseDC, COMDAT

; 547  : 	assert(!gpC_base->m_p_DDSurface_back->IsLock());
; 548  : 	if (gpC_fl2_surface == NULL)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00005	85 c0		 test	 eax, eax
  00007	75 1a		 jne	 SHORT $L88669

; 549  : 		_Error(NULL_REF);

  00009	68 25 02 00 00	 push	 549			; 00000225H
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  00013	50		 push	 eax
  00014	6a 05		 push	 5
  00016	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00020	83 c4 10	 add	 esp, 16			; 00000010H
$L88669:

; 550  : 
; 551  : 	if(gh_FL2_DC != NULL)

  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00029	85 c9		 test	 ecx, ecx
  0002b	74 14		 je	 SHORT $L88670

; 552  : 	{
; 553  : 		gpC_fl2_surface->ReleaseDC(gh_FL2_DC);

  0002d	8b 10		 mov	 edx, DWORD PTR [eax]
  0002f	51		 push	 ecx
  00030	50		 push	 eax
  00031	ff 52 68	 call	 DWORD PTR [edx+104]

; 554  : 		gh_FL2_DC = NULL;

  00034	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A, 0 ; gh_FL2_DC

; 555  : 
; 556  : 		return true;

  0003e	b0 01		 mov	 al, 1

; 560  : }

  00040	c3		 ret	 0
$L88670:

; 557  : 	}
; 558  : 
; 559  : 	return false;

  00041	32 c0		 xor	 al, al

; 560  : }

  00043	c3		 ret	 0
?g_FL2_ReleaseDC@@YA_NXZ ENDP				; g_FL2_ReleaseDC
_TEXT	ENDS
PUBLIC	?ReduceString@@YAXPADH@Z			; ReduceString
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?ReduceString@@YAXPADH@Z
_TEXT	SEGMENT
tv202 = -120						; size = 4
_lt$ = -120						; size = 4
_size$ = -116						; size = 4
_name$ = -112						; size = 100
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_str$ = 8						; size = 4
_len$ = 12						; size = 4
?ReduceString@@YAXPADH@Z PROC NEAR			; ReduceString, COMDAT

; 572  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	53		 push	 ebx

; 573  : 	if(len<15) return;

  0000f	8b 5d 0c	 mov	 ebx, DWORD PTR _len$[ebp]
  00012	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  00015	56		 push	 esi
  00016	89 84 24 80 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+132], eax
  0001d	57		 push	 edi
  0001e	0f 8c cf 00 00
	00		 jl	 $L88683

; 574  : 	char name[100]="",*p_name;
; 575  : 	int lt=strlen(str),passlen,position,size;

  00024	8b 75 08	 mov	 esi, DWORD PTR _str$[ebp]
  00027	33 c0		 xor	 eax, eax
  00029	c6 44 24 18 00	 mov	 BYTE PTR _name$[esp+136], 0
  0002e	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00033	8d 7c 24 19	 lea	 edi, DWORD PTR _name$[esp+137]
  00037	f3 ab		 rep stosd
  00039	66 ab		 stosw
  0003b	aa		 stosb
  0003c	8b c6		 mov	 eax, esi
  0003e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L90119:
  00041	8a 08		 mov	 cl, BYTE PTR [eax]
  00043	40		 inc	 eax
  00044	84 c9		 test	 cl, cl
  00046	75 f9		 jne	 SHORT $L90119
  00048	2b c2		 sub	 eax, edx

; 576  : 	p_name=&name[0];
; 577  : 	//bool g_PossibleStringCut(const char * sz_str, int position)
; 578  : 	if(lt>len)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	89 44 24 10	 mov	 DWORD PTR _lt$[esp+136], eax
  00050	0f 8e 9d 00 00
	00		 jle	 $L88683

; 579  : 	{
; 580  : 		if(g_PossibleStringCut(str,5))

  00056	6a 05		 push	 5
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ?g_PossibleStringCut@@YA_NPBDH@Z ; g_PossibleStringCut
  0005e	f6 d8		 neg	 al

; 581  : 			passlen=5;
; 582  : 		else	
; 583  : 			passlen=6;
; 584  : 		memcpy(p_name,str,passlen);
; 585  : 		p_name+=passlen;
; 586  : 		*(p_name++)='.';
; 587  : 		*(p_name++)='.';
; 588  : 		*(p_name++)='.';
; 589  : 		passlen+=3;
; 590  : 		size=passlen;
; 591  : 		position=lt-(len-passlen);

  00060	8b 54 24 18	 mov	 edx, DWORD PTR _lt$[esp+144]
  00064	8d 7c 24 20	 lea	 edi, DWORD PTR _name$[esp+144]
  00068	1b c0		 sbb	 eax, eax
  0006a	83 c0 06	 add	 eax, 6
  0006d	8b d8		 mov	 ebx, eax
  0006f	8b cb		 mov	 ecx, ebx
  00071	c1 e9 02	 shr	 ecx, 2
  00074	f3 a5		 rep movsd
  00076	8b c8		 mov	 ecx, eax
  00078	83 e1 03	 and	 ecx, 3
  0007b	f3 a4		 rep movsb
  0007d	8b 75 0c	 mov	 esi, DWORD PTR _len$[ebp]
  00080	8d 7c 1c 20	 lea	 edi, DWORD PTR _name$[esp+ebx+144]
  00084	83 c3 03	 add	 ebx, 3
  00087	c6 07 2e	 mov	 BYTE PTR [edi], 46	; 0000002eH
  0008a	8b cb		 mov	 ecx, ebx
  0008c	2b ce		 sub	 ecx, esi
  0008e	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00091	47		 inc	 edi
  00092	c6 07 2e	 mov	 BYTE PTR [edi], 46	; 0000002eH

; 592  : 		if(g_PossibleStringCut(str,position))

  00095	50		 push	 eax
  00096	89 44 24 1c	 mov	 DWORD PTR tv202[esp+148], eax
  0009a	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0009d	47		 inc	 edi
  0009e	c6 07 2e	 mov	 BYTE PTR [edi], 46	; 0000002eH
  000a1	50		 push	 eax
  000a2	47		 inc	 edi
  000a3	89 5c 24 24	 mov	 DWORD PTR _size$[esp+152], ebx
  000a7	e8 00 00 00 00	 call	 ?g_PossibleStringCut@@YA_NPBDH@Z ; g_PossibleStringCut

; 593  : 			{
; 594  : 			position=lt-len+passlen;

  000ac	8b 54 24 20	 mov	 edx, DWORD PTR tv202[esp+152]
  000b0	83 c4 10	 add	 esp, 16			; 00000010H

; 595  : 			passlen=len-passlen;

  000b3	2b f3		 sub	 esi, ebx
  000b5	84 c0		 test	 al, al

; 596  : 		}
; 597  : 		else

  000b7	75 02		 jne	 SHORT $L90123

; 598  : 			{
; 599  : 			position=lt-len+passlen-1;

  000b9	4a		 dec	 edx

; 600  : 			passlen=len-passlen+1;

  000ba	46		 inc	 esi
$L90123:

; 601  : 		}
; 602  : 		size+=passlen;

  000bb	8b 44 24 14	 mov	 eax, DWORD PTR _size$[esp+136]
  000bf	8b ce		 mov	 ecx, esi

; 603  : 		memcpy(p_name,str+position,passlen);		

  000c1	8b 75 08	 mov	 esi, DWORD PTR _str$[ebp]
  000c4	03 c1		 add	 eax, ecx
  000c6	03 f2		 add	 esi, edx
  000c8	8b d1		 mov	 edx, ecx
  000ca	c1 e9 02	 shr	 ecx, 2
  000cd	f3 a5		 rep movsd
  000cf	8b ca		 mov	 ecx, edx

; 604  : 		memcpy(str,name,size);

  000d1	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  000d4	83 e1 03	 and	 ecx, 3
  000d7	f3 a4		 rep movsb
  000d9	8b c8		 mov	 ecx, eax
  000db	8b d9		 mov	 ebx, ecx
  000dd	c1 e9 02	 shr	 ecx, 2
  000e0	8d 74 24 18	 lea	 esi, DWORD PTR _name$[esp+136]
  000e4	8b fa		 mov	 edi, edx
  000e6	f3 a5		 rep movsd
  000e8	8b cb		 mov	 ecx, ebx
  000ea	83 e1 03	 and	 ecx, 3
  000ed	f3 a4		 rep movsb

; 605  : 		str[size]='\0';		

  000ef	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
$L88683:

; 606  : 	}		
; 607  : }

  000f3	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+136]
  000fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5b		 pop	 ebx
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
?ReduceString@@YAXPADH@Z ENDP				; ReduceString
_TEXT	ENDS
PUBLIC	?ReduceString2@@YAXPADH@Z			; ReduceString2
; Function compile flags: /Ogty
;	COMDAT ?ReduceString2@@YAXPADH@Z
_TEXT	SEGMENT
tv204 = -120						; size = 4
_lt$ = -120						; size = 4
_size$ = -116						; size = 4
_name$ = -112						; size = 100
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_str$ = 8						; size = 4
_len$ = 12						; size = 4
?ReduceString2@@YAXPADH@Z PROC NEAR			; ReduceString2, COMDAT

; 611  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 7c	 sub	 esp, 124		; 0000007cH

; 612  : 	if(len<15) return;

  00009	8b 55 0c	 mov	 edx, DWORD PTR _len$[ebp]
  0000c	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	89 84 24 80 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+132], eax
  0001d	57		 push	 edi
  0001e	0f 8c d2 00 00
	00		 jl	 $L88700

; 613  : 	char name[100]="",*p_name;
; 614  : 	int lt=strlen(str),passlen,position,size;

  00024	8b 75 08	 mov	 esi, DWORD PTR _str$[ebp]
  00027	33 c0		 xor	 eax, eax
  00029	c6 44 24 18 00	 mov	 BYTE PTR _name$[esp+136], 0
  0002e	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00033	8d 7c 24 19	 lea	 edi, DWORD PTR _name$[esp+137]
  00037	f3 ab		 rep stosd
  00039	66 ab		 stosw
  0003b	aa		 stosb
  0003c	8b c6		 mov	 eax, esi
  0003e	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$L90127:
  00041	8a 08		 mov	 cl, BYTE PTR [eax]
  00043	40		 inc	 eax
  00044	84 c9		 test	 cl, cl
  00046	75 f9		 jne	 SHORT $L90127
  00048	2b c7		 sub	 eax, edi

; 615  : 	p_name=&name[0];
; 616  : 	//bool g_PossibleStringCut(const char * sz_str, int position)
; 617  : 	
; 618  : 	int skip_len=len-14;
; 619  : 	if(lt>len)

  0004a	3b c2		 cmp	 eax, edx
  0004c	89 44 24 10	 mov	 DWORD PTR _lt$[esp+136], eax
  00050	8d 5a f2	 lea	 ebx, DWORD PTR [edx-14]
  00053	0f 8e 9d 00 00
	00		 jle	 $L88700

; 620  : 	{
; 621  : 		if(g_PossibleStringCut(str,skip_len))

  00059	53		 push	 ebx
  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ?g_PossibleStringCut@@YA_NPBDH@Z ; g_PossibleStringCut
  00060	83 c4 08	 add	 esp, 8
  00063	84 c0		 test	 al, al

; 622  : 			passlen=skip_len;
; 623  : 		else	

  00065	75 01		 jne	 SHORT $L88702

; 624  : 			passlen=skip_len+1;

  00067	43		 inc	 ebx
$L88702:

; 625  : 		memcpy(p_name,str,passlen);
; 626  : 		p_name+=passlen;
; 627  : 		*(p_name++)='.';
; 628  : 		*(p_name++)='.';
; 629  : 		*(p_name++)='.';
; 630  : 		passlen+=3;
; 631  : 		size=passlen;
; 632  : 		position=lt-(len-passlen);

  00068	8b 54 24 10	 mov	 edx, DWORD PTR _lt$[esp+136]
  0006c	8b cb		 mov	 ecx, ebx
  0006e	8b c1		 mov	 eax, ecx
  00070	c1 e9 02	 shr	 ecx, 2
  00073	8d 7c 24 18	 lea	 edi, DWORD PTR _name$[esp+136]
  00077	f3 a5		 rep movsd
  00079	8b c8		 mov	 ecx, eax
  0007b	83 e1 03	 and	 ecx, 3
  0007e	f3 a4		 rep movsb
  00080	8b 75 0c	 mov	 esi, DWORD PTR _len$[ebp]
  00083	8d 7c 1c 18	 lea	 edi, DWORD PTR _name$[esp+ebx+136]
  00087	83 c3 03	 add	 ebx, 3
  0008a	c6 07 2e	 mov	 BYTE PTR [edi], 46	; 0000002eH
  0008d	8b cb		 mov	 ecx, ebx
  0008f	2b ce		 sub	 ecx, esi
  00091	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00094	47		 inc	 edi
  00095	c6 07 2e	 mov	 BYTE PTR [edi], 46	; 0000002eH

; 633  : 		if(g_PossibleStringCut(str,position))

  00098	50		 push	 eax
  00099	89 44 24 14	 mov	 DWORD PTR tv204[esp+140], eax
  0009d	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  000a0	47		 inc	 edi
  000a1	c6 07 2e	 mov	 BYTE PTR [edi], 46	; 0000002eH
  000a4	50		 push	 eax
  000a5	47		 inc	 edi
  000a6	89 5c 24 1c	 mov	 DWORD PTR _size$[esp+144], ebx
  000aa	e8 00 00 00 00	 call	 ?g_PossibleStringCut@@YA_NPBDH@Z ; g_PossibleStringCut

; 634  : 			{
; 635  : 			position=lt-len+passlen;

  000af	8b 54 24 18	 mov	 edx, DWORD PTR tv204[esp+144]
  000b3	83 c4 08	 add	 esp, 8

; 636  : 			passlen=len-passlen;

  000b6	2b f3		 sub	 esi, ebx
  000b8	84 c0		 test	 al, al

; 637  : 		}
; 638  : 		else

  000ba	75 02		 jne	 SHORT $L90129

; 639  : 			{
; 640  : 			position=lt-len+passlen-1;

  000bc	4a		 dec	 edx

; 641  : 			passlen=len-passlen+1;

  000bd	46		 inc	 esi
$L90129:

; 642  : 		}
; 643  : 		size+=passlen;

  000be	8b 44 24 14	 mov	 eax, DWORD PTR _size$[esp+136]
  000c2	8b ce		 mov	 ecx, esi

; 644  : 		memcpy(p_name,str+position,passlen);		

  000c4	8b 75 08	 mov	 esi, DWORD PTR _str$[ebp]
  000c7	03 c1		 add	 eax, ecx
  000c9	03 f2		 add	 esi, edx
  000cb	8b d1		 mov	 edx, ecx
  000cd	c1 e9 02	 shr	 ecx, 2
  000d0	f3 a5		 rep movsd
  000d2	8b ca		 mov	 ecx, edx

; 645  : 		memcpy(str,name,size);

  000d4	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  000d7	83 e1 03	 and	 ecx, 3
  000da	f3 a4		 rep movsb
  000dc	8b c8		 mov	 ecx, eax
  000de	8b d9		 mov	 ebx, ecx
  000e0	c1 e9 02	 shr	 ecx, 2
  000e3	8d 74 24 18	 lea	 esi, DWORD PTR _name$[esp+136]
  000e7	8b fa		 mov	 edi, edx
  000e9	f3 a5		 rep movsd
  000eb	8b cb		 mov	 ecx, ebx
  000ed	83 e1 03	 and	 ecx, 3
  000f0	f3 a4		 rep movsb

; 646  : 		str[size]='\0';		

  000f2	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
$L88700:

; 647  : 	}		
; 648  : }

  000f6	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+136]
  000fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00102	5f		 pop	 edi
  00103	5e		 pop	 esi
  00104	5b		 pop	 ebx
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
?ReduceString2@@YAXPADH@Z ENDP				; ReduceString2
_TEXT	ENDS
PUBLIC	?ReduceString3@@YAXPADH@Z			; ReduceString3
; Function compile flags: /Ogty
;	COMDAT ?ReduceString3@@YAXPADH@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_len$ = 12						; size = 4
?ReduceString3@@YAXPADH@Z PROC NEAR			; ReduceString3, COMDAT

; 651  : {

  00000	57		 push	 edi

; 652  : 	if(str == NULL) return;

  00001	8b 7c 24 08	 mov	 edi, DWORD PTR _str$[esp]
  00005	85 ff		 test	 edi, edi
  00007	74 3d		 je	 SHORT $L88708
  00009	56		 push	 esi

; 653  : 	if(len<15) return;

  0000a	8b 74 24 10	 mov	 esi, DWORD PTR _len$[esp+4]
  0000e	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00011	7c 32		 jl	 SHORT $L90133

; 654  : 	int CurLen = strlen(str);

  00013	8b c7		 mov	 eax, edi
  00015	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L90132:
  00018	8a 08		 mov	 cl, BYTE PTR [eax]
  0001a	40		 inc	 eax
  0001b	84 c9		 test	 cl, cl
  0001d	75 f9		 jne	 SHORT $L90132
  0001f	2b c2		 sub	 eax, edx

; 655  : 	if(CurLen<=len) return;

  00021	3b c6		 cmp	 eax, esi
  00023	7e 20		 jle	 SHORT $L90133

; 656  : 	
; 657  : 	if(!g_PossibleStringCut(str,len))

  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?g_PossibleStringCut@@YA_NPBDH@Z ; g_PossibleStringCut
  0002c	83 c4 08	 add	 esp, 8
  0002f	84 c0		 test	 al, al
  00031	b1 2e		 mov	 cl, 46			; 0000002eH
  00033	75 04		 jne	 SHORT $L88713

; 658  : 		str[len-3] = '.';

  00035	88 4c 37 fd	 mov	 BYTE PTR [edi+esi-3], cl
$L88713:

; 659  : 	str[len-2] = '.';

  00039	88 4c 37 fe	 mov	 BYTE PTR [edi+esi-2], cl

; 660  : 	str[len-1] = '.';

  0003d	88 4c 37 ff	 mov	 BYTE PTR [edi+esi-1], cl

; 661  : 	str[len] = '\0';

  00041	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
$L90133:
  00045	5e		 pop	 esi
$L88708:
  00046	5f		 pop	 edi

; 662  : }

  00047	c3		 ret	 0
?ReduceString3@@YAXPADH@Z ENDP				; ReduceString3
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::size
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::size, COMDAT
; _this$ = ecx

; 431  :   size_type size() const { return this->_M_finish - this->_M_start; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c3		 ret	 0
?size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?length@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::length
; Function compile flags: /Ogty
;	COMDAT ?length@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::length, COMDAT
; _this$ = ecx

; 432  :   size_type length() const { return size(); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c3		 ret	 0
?length@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::length
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEPBDXZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::c_str
; Function compile flags: /Ogty
;	COMDAT ?c_str@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEPBDXZ PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1065 :   const _CharT* c_str() const { return this->_M_start; }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
?c_str@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEPBDXZ ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	??0?$allocator@D@_STL@@QAE@XZ			; _STL::allocator<char>::allocator<char>
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_alloc.h
;	COMDAT ??0?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@_STL@@QAE@XZ PROC NEAR			; _STL::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 345  :   allocator() _STLP_NOTHROW {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@_STL@@QAE@XZ ENDP			; _STL::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::end
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ
_TEXT	SEGMENT
?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::end, COMDAT
; _this$ = ecx

; 417  :   iterator end()               { return this->_M_finish; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?end@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEPADXZ ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ ; _STL::_String_base<char,_STL::allocator<char> >::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ PROC NEAR ; _STL::_String_base<char,_STL::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 126  :   size_t max_size() const { return (size_t(-1) / sizeof(_Tp)) - 1; }

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00005	c3		 ret	 0
?max_size@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEIXZ ENDP ; _STL::_String_base<char,_STL::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z ; _STL::__char_traits_base<char,int>::move
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\char_traits.h
;	COMDAT ?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z
_TEXT	SEGMENT
___s1$ = 8						; size = 4
___s2$ = 12						; size = 4
__Sz$ = 16						; size = 4
?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z PROC NEAR ; _STL::__char_traits_base<char,int>::move, COMDAT

; 166  :     return (_Sz == 0 ? __s1 : (_CharT*)memmove(__s1, __s2, _Sz * sizeof(_CharT)));

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Sz$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 05		 jne	 SHORT $L90158
  00008	8b 44 24 04	 mov	 eax, DWORD PTR ___s1$[esp-4]

; 167  :   }

  0000c	c3		 ret	 0
$L90158:

; 166  :     return (_Sz == 0 ? __s1 : (_CharT*)memmove(__s1, __s2, _Sz * sizeof(_CharT)));

  0000d	89 44 24 0c	 mov	 DWORD PTR __Sz$[esp-4], eax
  00011	e9 00 00 00 00	 jmp	 _memmove
?move@?$__char_traits_base@DH@_STL@@SAPADPADPBDI@Z ENDP	; _STL::__char_traits_base<char,int>::move
_TEXT	ENDS
PUBLIC	??_C@_0N@GOPDCEEB@basic_string?$AA@		; `string'
PUBLIC	?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ ; _STL::_String_base<char,_STL::allocator<char> >::_M_throw_length_error
EXTRN	?__stl_throw_length_error@_STL@@YAXPBD@Z:NEAR	; _STL::__stl_throw_length_error
;	COMDAT ??_C@_0N@GOPDCEEB@basic_string?$AA@
; File c:\stlport-4.6.1\stlport\stl\_string.c
CONST	SEGMENT
??_C@_0N@GOPDCEEB@basic_string?$AA@ DB 'basic_string', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT
?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ PROC NEAR ; _STL::_String_base<char,_STL::allocator<char> >::_M_throw_length_error, COMDAT
; _this$ = ecx

; 523  :     __stl_throw_length_error("basic_string");

  00000	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@GOPDCEEB@basic_string?$AA@
  00005	e8 00 00 00 00	 call	 ?__stl_throw_length_error@_STL@@YAXPBD@Z ; _STL::__stl_throw_length_error
  0000a	59		 pop	 ecx

; 524  : }

  0000b	c3		 ret	 0
?_M_throw_length_error@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ ENDP ; _STL::_String_base<char,_STL::allocator<char> >::_M_throw_length_error
_TEXT	ENDS
PUBLIC	?_M_throw_out_of_range@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ ; _STL::_String_base<char,_STL::allocator<char> >::_M_throw_out_of_range
EXTRN	?__stl_throw_out_of_range@_STL@@YAXPBD@Z:NEAR	; _STL::__stl_throw_out_of_range
; Function compile flags: /Ogty
;	COMDAT ?_M_throw_out_of_range@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ
_TEXT	SEGMENT
?_M_throw_out_of_range@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ PROC NEAR ; _STL::_String_base<char,_STL::allocator<char> >::_M_throw_out_of_range, COMDAT
; _this$ = ecx

; 527  :     __stl_throw_out_of_range("basic_string");

  00000	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@GOPDCEEB@basic_string?$AA@
  00005	e8 00 00 00 00	 call	 ?__stl_throw_out_of_range@_STL@@YAXPBD@Z ; _STL::__stl_throw_out_of_range
  0000a	59		 pop	 ecx

; 528  : }

  0000b	c3		 ret	 0
?_M_throw_out_of_range@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QBEXXZ ENDP ; _STL::_String_base<char,_STL::allocator<char> >::_M_throw_out_of_range
_TEXT	ENDS
PUBLIC	??1?$allocator@D@_STL@@QAE@XZ			; _STL::allocator<char>::~allocator<char>
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_alloc.h
;	COMDAT ??1?$allocator@D@_STL@@QAE@XZ
_TEXT	SEGMENT
??1?$allocator@D@_STL@@QAE@XZ PROC NEAR			; _STL::allocator<char>::~allocator<char>, COMDAT
; _this$ = ecx

; 350  :   ~allocator() _STLP_NOTHROW {}

  00000	c3		 ret	 0
??1?$allocator@D@_STL@@QAE@XZ ENDP			; _STL::allocator<char>::~allocator<char>
_TEXT	ENDS
PUBLIC	?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z ; _STL::__node_alloc<1,0>::deallocate
EXTRN	?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z:NEAR ; _STL::__node_alloc<1,0>::_M_deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z
_TEXT	SEGMENT
___p$ = 8						; size = 4
___n$ = 12						; size = 4
?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z PROC NEAR ; _STL::__node_alloc<1,0>::deallocate, COMDAT

; 253  :   static void _STLP_CALL deallocate(void *__p, size_t __n) { if (__n > (size_t)_MAX_BYTES) __stl_delete(__p); else _M_deallocate(__p, __n); }

  00000	8b 44 24 08	 mov	 eax, DWORD PTR ___n$[esp-4]
  00004	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00009	76 0e		 jbe	 SHORT $L73486
  0000b	8b 44 24 04	 mov	 eax, DWORD PTR ___p$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
  00018	c3		 ret	 0
$L73486:
  00019	89 44 24 08	 mov	 DWORD PTR ___n$[esp-4], eax
  0001d	e9 00 00 00 00	 jmp	 ?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z ; _STL::__node_alloc<1,0>::_M_deallocate
?deallocate@?$__node_alloc@$00$0A@@_STL@@SAXPAXI@Z ENDP	; _STL::__node_alloc<1,0>::deallocate
_TEXT	ENDS
PUBLIC	?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_terminate_string_aux
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_terminate_string_aux, COMDAT
; _this$ = ecx

; 351  :     *(this->_M_finish)=0;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c6 00 00	 mov	 BYTE PTR [eax], 0

; 352  :   }

  00006	c2 04 00	 ret	 4
?_M_terminate_string_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXABU__true_type@2@@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_terminate_string_aux
_TEXT	ENDS
PUBLIC	??0?$allocator@D@_STL@@QAE@ABV01@@Z		; _STL::allocator<char>::allocator<char>
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_alloc.h
;	COMDAT ??0?$allocator@D@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@_STL@@QAE@ABV01@@Z PROC NEAR		; _STL::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 349  :   allocator(const allocator<_Tp>&) _STLP_NOTHROW {}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@D@_STL@@QAE@ABV01@@Z ENDP		; _STL::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z ; _STL::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z
_TEXT	SEGMENT
___a$ = 8						; size = 4
___p$ = 12						; size = 4
??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z PROC NEAR ; _STL::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >, COMDAT
; _this$ = ecx

; 487  :   inline _STLP_alloc_proxy(const _MaybeReboundAlloc& __a, _Value __p) : _MaybeReboundAlloc(__a), _M_data(__p) {}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR ___p$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
  00008	c2 08 00	 ret	 8
??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z ENDP ; _STL::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >
_TEXT	ENDS
PUBLIC	?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z	; _STL::__node_alloc<1,0>::allocate
EXTRN	?_M_allocate@?$__node_alloc@$00$0A@@_STL@@CAPAXI@Z:NEAR ; _STL::__node_alloc<1,0>::_M_allocate
; Function compile flags: /Ogty
;	COMDAT ?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z
_TEXT	SEGMENT
___n$ = 8						; size = 4
?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z PROC NEAR ; _STL::__node_alloc<1,0>::allocate, COMDAT

; 251  :   static void * _STLP_CALL allocate(size_t __n) { return (__n > (size_t)_MAX_BYTES) ?  __stl_new(__n) : _M_allocate(__n); }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___n$[esp-4]
  00004	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00009	76 09		 jbe	 SHORT $L90187
  0000b	89 44 24 04	 mov	 DWORD PTR ___n$[esp-4], eax
  0000f	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$L90187:
  00014	89 44 24 04	 mov	 DWORD PTR ___n$[esp-4], eax
  00018	e9 00 00 00 00	 jmp	 ?_M_allocate@?$__node_alloc@$00$0A@@_STL@@CAPAXI@Z ; _STL::__node_alloc<1,0>::_M_allocate
?allocate@?$__node_alloc@$00$0A@@_STL@@SAPAXI@Z ENDP	; _STL::__node_alloc<1,0>::allocate
_TEXT	ENDS
PUBLIC	?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::capacity
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::capacity, COMDAT
; _this$ = ecx

; 447  :   size_type capacity() const { return (this->_M_end_of_storage._M_data - this->_M_start) - 1; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	48		 dec	 eax
  00006	c3		 ret	 0
?capacity@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::capacity
_TEXT	ENDS
PUBLIC	?_M_move@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0PAD@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_move
; Function compile flags: /Ogty
;	COMDAT ?_M_move@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0PAD@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
___result$ = 16						; size = 4
?_M_move@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0PAD@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_move, COMDAT
; _this$ = ecx

; 842  :     _Traits::move(__result, __first, __last - __first);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR ___last$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR ___first$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	74 0f		 je	 SHORT $L90203
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR ___result$[esp]
  00011	51		 push	 ecx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
$L90203:

; 843  :   }

  0001b	c2 0c 00	 ret	 12			; 0000000cH
?_M_move@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0PAD@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_move
_TEXT	ENDS
PUBLIC	?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_construct_null_aux
; Function compile flags: /Ogty
;	COMDAT ?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z
_TEXT	SEGMENT
___p$ = 8						; size = 4
___formal$ = 12						; size = 4
?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_construct_null_aux, COMDAT
; _this$ = ecx

; 332  :     *__p = 0;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___p$[esp-4]
  00004	c6 00 00	 mov	 BYTE PTR [eax], 0

; 333  :   }

  00007	c2 08 00	 ret	 8
?_M_construct_null_aux@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADABU__true_type@2@@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_construct_null_aux
_TEXT	ENDS
PUBLIC	??$max@I@_STL@@YAABIABI0@Z			; _STL::max<unsigned int>
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_algobase.h
;	COMDAT ??$max@I@_STL@@YAABIABI0@Z
_TEXT	SEGMENT
___a$ = 8						; size = 4
___b$ = 12						; size = 4
??$max@I@_STL@@YAABIABI0@Z PROC NEAR			; _STL::max<unsigned int>, COMDAT

; 79   : inline const _Tp& (max)(const _Tp& __a, const _Tp& __b) {  return  __a < __b ? __b : __a; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___a$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR ___b$[esp-4]
  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	73 02		 jae	 SHORT $L90214
  0000e	8b c1		 mov	 eax, ecx
$L90214:
  00010	c3		 ret	 0
??$max@I@_STL@@YAABIABI0@Z ENDP				; _STL::max<unsigned int>
_TEXT	ENDS
PUBLIC	??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z ; _STL::__distance<char const *>
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_iterator_base.h
;	COMDAT ??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z PROC NEAR ; _STL::__distance<char const *>, COMDAT

; 363  :   return __last - __first;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR ___last$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR ___first$[esp-4]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	2b 01		 sub	 eax, DWORD PTR [ecx]

; 364  : }

  0000c	c3		 ret	 0
??$__distance@PBD@_STL@@YAHABQBD0ABUrandom_access_iterator_tag@0@@Z ENDP ; _STL::__distance<char const *>
_TEXT	ENDS
PUBLIC	??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z ; _STL::__distance<char *>
; Function compile flags: /Ogty
;	COMDAT ??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z PROC NEAR ; _STL::__distance<char *>, COMDAT

; 363  :   return __last - __first;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR ___last$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR ___first$[esp-4]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	2b 01		 sub	 eax, DWORD PTR [ecx]

; 364  : }

  0000c	c3		 ret	 0
??$__distance@PAD@_STL@@YAHABQAD0ABUrandom_access_iterator_tag@0@@Z ENDP ; _STL::__distance<char *>
_TEXT	ENDS
PUBLIC	??$__advance@PBDH@_STL@@YAXAAPBDHABUrandom_access_iterator_tag@0@@Z ; _STL::__advance<char const *,int>
; Function compile flags: /Ogty
;	COMDAT ??$__advance@PBDH@_STL@@YAXAAPBDHABUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
___i$ = 8						; size = 4
___n$ = 12						; size = 4
___formal$ = 16						; size = 4
??$__advance@PBDH@_STL@@YAXAAPBDHABUrandom_access_iterator_tag@0@@Z PROC NEAR ; _STL::__advance<char const *,int>, COMDAT

; 444  :   __i += __n;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___i$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8b 4c 24 08	 mov	 ecx, DWORD PTR ___n$[esp-4]
  0000a	03 d1		 add	 edx, ecx
  0000c	89 10		 mov	 DWORD PTR [eax], edx

; 445  : }

  0000e	c3		 ret	 0
??$__advance@PBDH@_STL@@YAXAAPBDHABUrandom_access_iterator_tag@0@@Z ENDP ; _STL::__advance<char const *,int>
_TEXT	ENDS
PUBLIC	?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ ; _STL::_BothPtrType<char *,char *>::_Ret
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\type_traits.h
;	COMDAT ?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ PROC NEAR ; _STL::_BothPtrType<char *,char *>::_Ret, COMDAT

; 234  :   static __true_type _Ret() { return __true_type();} 

  00000	32 c0		 xor	 al, al
  00002	c3		 ret	 0
?_Ret@?$_BothPtrType@PADPAD@_STL@@SA?AU__true_type@2@XZ ENDP ; _STL::_BothPtrType<char *,char *>::_Ret
_TEXT	ENDS
PUBLIC	?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ ; _STL::_OKToMemCpy<char,char>::_Ret
; Function compile flags: /Ogty
;	COMDAT ?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ
_TEXT	SEGMENT
?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ PROC NEAR ; _STL::_OKToMemCpy<char,char>::_Ret, COMDAT

; 361  :   static _Type _Ret() { return _Type(); }

  00000	32 c0		 xor	 al, al
  00002	c3		 ret	 0
?_Ret@?$_OKToMemCpy@DD@_STL@@SA?AU__true_type@2@XZ ENDP	; _STL::_OKToMemCpy<char,char>::_Ret
_TEXT	ENDS
PUBLIC	??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z ; _STL::_IsOKToMemCpy<char,char>
; Function compile flags: /Ogty
;	COMDAT ??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z PROC NEAR ; _STL::_IsOKToMemCpy<char,char>, COMDAT

; 366  :   return _OKToMemCpy<_Tp1, _Tp2>();

  00000	32 c0		 xor	 al, al

; 367  : }

  00002	c3		 ret	 0
??$_IsOKToMemCpy@DD@_STL@@YA?AU?$_OKToMemCpy@DD@0@PAD0@Z ENDP ; _STL::_IsOKToMemCpy<char,char>
_TEXT	ENDS
PUBLIC	??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z ; _STL::__copy_ptrs<char *,char *>
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_algobase.h
;	COMDAT ??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
___result$ = 16						; size = 4
___formal$ = 20						; size = 4
??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z PROC NEAR ; _STL::__copy_ptrs<char *,char *>, COMDAT

; 195  : // we know they all pointers, so this cast is OK 
; 196  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 197  :   return (_OutputIter)__copy_trivial(__first, __last, __result);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___first$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR ___last$[esp]
  00009	3b f0		 cmp	 esi, eax
  0000b	75 06		 jne	 SHORT $L90244
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR ___result$[esp]
  00011	5e		 pop	 esi

; 198  : }

  00012	c3		 ret	 0

; 195  : // we know they all pointers, so this cast is OK 
; 196  :   //  return (_OutputIter)__copy_trivial(&(*__first), &(*__last), &(*__result));
; 197  :   return (_OutputIter)__copy_trivial(__first, __last, __result);

$L90244:
  00013	2b f0		 sub	 esi, eax
  00015	56		 push	 esi
  00016	50		 push	 eax
  00017	8b 44 24 18	 mov	 eax, DWORD PTR ___result$[esp+8]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 198  : }

  00027	c3		 ret	 0
??$__copy_ptrs@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z ENDP ; _STL::__copy_ptrs<char *,char *>
_TEXT	ENDS
PUBLIC	?g_GetStringWidth2@@YAHPBDHPAUHFONT__@@@Z	; g_GetStringWidth2
EXTRN	__imp__GetTextExtentPoint32A@16:NEAR
EXTRN	__imp__SelectObject@8:NEAR
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\new - vs_ui\src\hangul\fl2.cpp
;	COMDAT ?g_GetStringWidth2@@YAHPBDHPAUHFONT__@@@Z
_TEXT	SEGMENT
_size$ = -8						; size = 8
_sz_str$ = 8						; size = 4
_Index$ = 12						; size = 4
_hfont$ = 16						; size = 4
?g_GetStringWidth2@@YAHPBDHPAUHFONT__@@@Z PROC NEAR	; g_GetStringWidth2, COMDAT

; 85   : {

  00000	83 ec 08	 sub	 esp, 8
  00003	55		 push	 ebp

; 86   : 	int iStrLen = strlen (sz_str);

  00004	8b 6c 24 10	 mov	 ebp, DWORD PTR _sz_str$[esp+8]
  00008	8b c5		 mov	 eax, ebp
  0000a	57		 push	 edi
  0000b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000e	8b ff		 npad	 2
$L90254:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L90254

; 87   : 	if(Index >= iStrLen)

  00017	8b 7c 24 18	 mov	 edi, DWORD PTR _Index$[esp+12]
  0001b	2b c2		 sub	 eax, edx
  0001d	3b f8		 cmp	 edi, eax
  0001f	7c 03		 jl	 SHORT $L88445

; 88   : 		Index = iStrLen-1;

  00021	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
$L88445:

; 89   : 
; 90   : 	assert(!gpC_base->m_p_DDSurface_back->IsLock());
; 91   : 	if (gpC_fl2_surface == NULL)

  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00029	85 c0		 test	 eax, eax
  0002b	75 17		 jne	 SHORT $L88447

; 92   : 		_Error(NULL_REF);

  0002d	6a 5c		 push	 92			; 0000005cH
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  00034	50		 push	 eax
  00035	6a 05		 push	 5
  00037	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00041	83 c4 10	 add	 esp, 16			; 00000010H
$L88447:

; 93   : 
; 94   : 	if (sz_str == NULL)

  00044	85 ed		 test	 ebp, ebp
  00046	75 08		 jne	 SHORT $L88449
  00048	5f		 pop	 edi

; 95   : 		return 0;

  00049	33 c0		 xor	 eax, eax
  0004b	5d		 pop	 ebp

; 113  : }

  0004c	83 c4 08	 add	 esp, 8
  0004f	c3		 ret	 0
$L88449:

; 96   : 
; 97   : 	HDC hdc;
; 98   : 
; 99   : 	bool bGetDC = g_FL2_GetDC();

  00050	85 c0		 test	 eax, eax
  00052	75 1a		 jne	 SHORT $L90252
  00054	68 14 02 00 00	 push	 532			; 00000214H
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  0005e	50		 push	 eax
  0005f	6a 05		 push	 5
  00061	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  0006b	83 c4 10	 add	 esp, 16			; 00000010H
$L90252:
  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00074	85 c9		 test	 ecx, ecx
  00076	53		 push	 ebx
  00077	56		 push	 esi
  00078	75 0f		 jne	 SHORT $L90253
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	68 00 00 00 00	 push	 OFFSET FLAT:?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00081	50		 push	 eax
  00082	ff 51 44	 call	 DWORD PTR [ecx+68]
  00085	b3 01		 mov	 bl, 1
  00087	eb 02		 jmp	 SHORT $L90251
$L90253:
  00089	32 db		 xor	 bl, bl
$L90251:

; 100  : 
; 101  : 	hdc = gh_FL2_DC;
; 102  : 	
; 103  : 	if (hfont != NULL)

  0008b	8b 44 24 24	 mov	 eax, DWORD PTR _hfont$[esp+20]
  0008f	85 c0		 test	 eax, eax
  00091	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00097	74 08		 je	 SHORT $L88452

; 104  : 		SelectObject(hdc, hfont);

  00099	50		 push	 eax
  0009a	56		 push	 esi
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
$L88452:

; 105  : 
; 106  : 	SIZE size;
; 107  : 	GetTextExtentPoint32(hdc, sz_str, Index, &size);

  000a1	8d 54 24 10	 lea	 edx, DWORD PTR _size$[esp+24]
  000a5	52		 push	 edx
  000a6	57		 push	 edi
  000a7	55		 push	 ebp
  000a8	56		 push	 esi
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextExtentPoint32A@16
  000af	5e		 pop	 esi

; 108  : 
; 109  : 	if(bGetDC)

  000b0	84 db		 test	 bl, bl
  000b2	5b		 pop	 ebx
  000b3	74 05		 je	 SHORT $L88454

; 110  : 		g_FL2_ReleaseDC();

  000b5	e8 00 00 00 00	 call	 ?g_FL2_ReleaseDC@@YA_NXZ ; g_FL2_ReleaseDC
$L88454:

; 111  : 
; 112  : 	return size.cx;

  000ba	8b 44 24 08	 mov	 eax, DWORD PTR _size$[esp+16]
  000be	5f		 pop	 edi
  000bf	5d		 pop	 ebp

; 113  : }

  000c0	83 c4 08	 add	 esp, 8
  000c3	c3		 ret	 0
?g_GetStringWidth2@@YAHPBDHPAUHFONT__@@@Z ENDP		; g_GetStringWidth2
_TEXT	ENDS
PUBLIC	?g_GetStringWidth@@YAHPBDPAUHFONT__@@@Z		; g_GetStringWidth
; Function compile flags: /Ogty
;	COMDAT ?g_GetStringWidth@@YAHPBDPAUHFONT__@@@Z
_TEXT	SEGMENT
_size$ = -8						; size = 8
_sz_str$ = 8						; size = 4
_hfont$ = 12						; size = 4
?g_GetStringWidth@@YAHPBDPAUHFONT__@@@Z PROC NEAR	; g_GetStringWidth, COMDAT

; 191  : 	assert(!gpC_base->m_p_DDSurface_back->IsLock());
; 192  : 	if (gpC_fl2_surface == NULL)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00005	83 ec 08	 sub	 esp, 8
  00008	85 c0		 test	 eax, eax
  0000a	75 1a		 jne	 SHORT $L88503

; 193  : 		_Error(NULL_REF);

  0000c	68 c1 00 00 00	 push	 193			; 000000c1H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  00016	50		 push	 eax
  00017	6a 05		 push	 5
  00019	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00023	83 c4 10	 add	 esp, 16			; 00000010H
$L88503:
  00026	57		 push	 edi

; 194  : 
; 195  : 	if (sz_str == NULL)

  00027	8b 7c 24 10	 mov	 edi, DWORD PTR _sz_str$[esp+8]
  0002b	85 ff		 test	 edi, edi
  0002d	75 07		 jne	 SHORT $L88504

; 196  : 		return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	5f		 pop	 edi

; 214  : }

  00032	83 c4 08	 add	 esp, 8
  00035	c3		 ret	 0
$L88504:

; 197  : 
; 198  : 	HDC hdc;
; 199  : 
; 200  : 	bool bGetDC = g_FL2_GetDC();

  00036	85 c0		 test	 eax, eax
  00038	75 1a		 jne	 SHORT $L90261
  0003a	68 14 02 00 00	 push	 532			; 00000214H
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  00044	50		 push	 eax
  00045	6a 05		 push	 5
  00047	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00051	83 c4 10	 add	 esp, 16			; 00000010H
$L90261:
  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  0005a	85 c9		 test	 ecx, ecx
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	75 0f		 jne	 SHORT $L90262
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	68 00 00 00 00	 push	 OFFSET FLAT:?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00067	50		 push	 eax
  00068	ff 51 44	 call	 DWORD PTR [ecx+68]
  0006b	b3 01		 mov	 bl, 1
  0006d	eb 02		 jmp	 SHORT $L90260
$L90262:
  0006f	32 db		 xor	 bl, bl
$L90260:

; 201  : 
; 202  : 	hdc = gh_FL2_DC;
; 203  : 	
; 204  : 	if (hfont != NULL)

  00071	8b 44 24 1c	 mov	 eax, DWORD PTR _hfont$[esp+16]
  00075	85 c0		 test	 eax, eax
  00077	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  0007d	74 08		 je	 SHORT $L88507

; 205  : 		SelectObject(hdc, hfont);

  0007f	50		 push	 eax
  00080	56		 push	 esi
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
$L88507:

; 206  : 
; 207  : 	SIZE size;
; 208  : 	GetTextExtentPoint32(hdc, sz_str, strlen(sz_str), &size);

  00087	8b c7		 mov	 eax, edi
  00089	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0008c	8d 64 24 00	 npad	 4
$L90263:
  00090	8a 08		 mov	 cl, BYTE PTR [eax]
  00092	40		 inc	 eax
  00093	84 c9		 test	 cl, cl
  00095	75 f9		 jne	 SHORT $L90263
  00097	2b c2		 sub	 eax, edx
  00099	8d 54 24 0c	 lea	 edx, DWORD PTR _size$[esp+20]
  0009d	52		 push	 edx
  0009e	50		 push	 eax
  0009f	57		 push	 edi
  000a0	56		 push	 esi
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextExtentPoint32A@16
  000a7	5e		 pop	 esi

; 209  : 
; 210  : 	if(bGetDC)

  000a8	84 db		 test	 bl, bl
  000aa	5b		 pop	 ebx
  000ab	74 05		 je	 SHORT $L88509

; 211  : 		g_FL2_ReleaseDC();

  000ad	e8 00 00 00 00	 call	 ?g_FL2_ReleaseDC@@YA_NXZ ; g_FL2_ReleaseDC
$L88509:

; 212  : 
; 213  : 	return size.cx;

  000b2	8b 44 24 04	 mov	 eax, DWORD PTR _size$[esp+12]
  000b6	5f		 pop	 edi

; 214  : }

  000b7	83 c4 08	 add	 esp, 8
  000ba	c3		 ret	 0
?g_GetStringWidth@@YAHPBDPAUHFONT__@@@Z ENDP		; g_GetStringWidth
_TEXT	ENDS
PUBLIC	?g_GetStringHeight@@YAHPBDPAUHFONT__@@@Z	; g_GetStringHeight
; Function compile flags: /Ogty
;	COMDAT ?g_GetStringHeight@@YAHPBDPAUHFONT__@@@Z
_TEXT	SEGMENT
_size$ = -8						; size = 8
_sz_str$ = 8						; size = 4
_hfont$ = 12						; size = 4
?g_GetStringHeight@@YAHPBDPAUHFONT__@@@Z PROC NEAR	; g_GetStringHeight, COMDAT

; 226  : 	assert(!gpC_base->m_p_DDSurface_back->IsLock());
; 227  : 	if (gpC_fl2_surface == NULL)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00005	83 ec 08	 sub	 esp, 8
  00008	85 c0		 test	 eax, eax
  0000a	75 1a		 jne	 SHORT $L88515

; 228  : 		_Error(NULL_REF);

  0000c	68 e4 00 00 00	 push	 228			; 000000e4H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  00016	50		 push	 eax
  00017	6a 05		 push	 5
  00019	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00023	83 c4 10	 add	 esp, 16			; 00000010H
$L88515:
  00026	57		 push	 edi

; 229  : 
; 230  : 	if (sz_str == NULL)

  00027	8b 7c 24 10	 mov	 edi, DWORD PTR _sz_str$[esp+8]
  0002b	85 ff		 test	 edi, edi
  0002d	75 07		 jne	 SHORT $L88516

; 231  : 		return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	5f		 pop	 edi

; 250  : }

  00032	83 c4 08	 add	 esp, 8
  00035	c3		 ret	 0
$L88516:

; 232  : 	
; 233  : 	HDC hdc;
; 234  : 
; 235  : 	bool bGetDC = g_FL2_GetDC();

  00036	85 c0		 test	 eax, eax
  00038	75 1a		 jne	 SHORT $L90270
  0003a	68 14 02 00 00	 push	 532			; 00000214H
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  00044	50		 push	 eax
  00045	6a 05		 push	 5
  00047	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00051	83 c4 10	 add	 esp, 16			; 00000010H
$L90270:
  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  0005a	85 c9		 test	 ecx, ecx
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	75 0f		 jne	 SHORT $L90271
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	68 00 00 00 00	 push	 OFFSET FLAT:?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00067	50		 push	 eax
  00068	ff 51 44	 call	 DWORD PTR [ecx+68]
  0006b	b3 01		 mov	 bl, 1
  0006d	eb 02		 jmp	 SHORT $L90269
$L90271:
  0006f	32 db		 xor	 bl, bl
$L90269:

; 236  : 
; 237  : 	hdc = gh_FL2_DC;
; 238  : 	
; 239  : 	
; 240  : 	if (hfont != NULL)

  00071	8b 44 24 1c	 mov	 eax, DWORD PTR _hfont$[esp+16]
  00075	85 c0		 test	 eax, eax
  00077	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  0007d	74 08		 je	 SHORT $L88519

; 241  : 		SelectObject(hdc, hfont);

  0007f	50		 push	 eax
  00080	56		 push	 esi
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
$L88519:

; 242  : 
; 243  : 	SIZE size;
; 244  : 	GetTextExtentPoint32(hdc, sz_str, strlen(sz_str), &size);

  00087	8b c7		 mov	 eax, edi
  00089	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0008c	8d 64 24 00	 npad	 4
$L90272:
  00090	8a 08		 mov	 cl, BYTE PTR [eax]
  00092	40		 inc	 eax
  00093	84 c9		 test	 cl, cl
  00095	75 f9		 jne	 SHORT $L90272
  00097	2b c2		 sub	 eax, edx
  00099	8d 54 24 0c	 lea	 edx, DWORD PTR _size$[esp+20]
  0009d	52		 push	 edx
  0009e	50		 push	 eax
  0009f	57		 push	 edi
  000a0	56		 push	 esi
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTextExtentPoint32A@16
  000a7	5e		 pop	 esi

; 245  : 
; 246  : 	if(bGetDC)

  000a8	84 db		 test	 bl, bl
  000aa	5b		 pop	 ebx
  000ab	74 05		 je	 SHORT $L88521

; 247  : 		g_FL2_ReleaseDC();

  000ad	e8 00 00 00 00	 call	 ?g_FL2_ReleaseDC@@YA_NXZ ; g_FL2_ReleaseDC
$L88521:

; 248  : 
; 249  : 	return size.cy;

  000b2	8b 44 24 08	 mov	 eax, DWORD PTR _size$[esp+16]
  000b6	5f		 pop	 edi

; 250  : }

  000b7	83 c4 08	 add	 esp, 8
  000ba	c3		 ret	 0
?g_GetStringHeight@@YAHPBDPAUHFONT__@@@Z ENDP		; g_GetStringHeight
_TEXT	ENDS
PUBLIC	?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z		; g_PrintLen
EXTRN	__imp__TextOutA@20:NEAR
EXTRN	__imp__SetBkColor@8:NEAR
EXTRN	__imp__SetBkMode@8:NEAR
EXTRN	__imp__SetTextColor@8:NEAR
EXTRN	__imp__SetTextAlign@8:NEAR
; Function compile flags: /Ogty
;	COMDAT ?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sz_str$ = 16						; size = 4
_str_length$ = 20					; size = 4
_p_print_info$ = 24					; size = 4
?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z PROC NEAR	; g_PrintLen, COMDAT

; 261  : {

  00000	55		 push	 ebp

; 262  : 	assert(!gpC_base->m_p_DDSurface_back->IsLock());
; 263  : 	if (sz_str!=NULL)

  00001	8b 6c 24 10	 mov	 ebp, DWORD PTR _sz_str$[esp]
  00005	85 ed		 test	 ebp, ebp
  00007	0f 84 a9 00 00
	00		 je	 $L88535

; 264  : 	{
; 265  : 		//assert(sz_str != NULL);
; 266  : 		assert(gpC_fl2_surface != NULL);
; 267  : 
; 268  : 		// no Release exception handling code for speed.
; 269  : 
; 270  : 		HDC hdc;
; 271  : 
; 272  : 		bool bGetDC = g_FL2_GetDC();

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00012	85 c0		 test	 eax, eax
  00014	75 1a		 jne	 SHORT $L90279
  00016	68 14 02 00 00	 push	 532			; 00000214H
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  00020	50		 push	 eax
  00021	6a 05		 push	 5
  00023	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  0002d	83 c4 10	 add	 esp, 16			; 00000010H
$L90279:
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00036	85 c9		 test	 ecx, ecx
  00038	53		 push	 ebx
  00039	56		 push	 esi
  0003a	57		 push	 edi
  0003b	75 0f		 jne	 SHORT $L90280
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00044	50		 push	 eax
  00045	ff 51 44	 call	 DWORD PTR [ecx+68]
  00048	b3 01		 mov	 bl, 1
  0004a	eb 02		 jmp	 SHORT $L90278
$L90280:
  0004c	32 db		 xor	 bl, bl
$L90278:

; 273  : 
; 274  : 		hdc = gh_FL2_DC;
; 275  : 
; 276  : 		if (p_print_info != NULL)

  0004e	8b 7c 24 24	 mov	 edi, DWORD PTR _p_print_info$[esp+12]
  00052	85 ff		 test	 edi, edi
  00054	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  0005a	74 36		 je	 SHORT $L88534

; 277  : 		{
; 278  : 			SetTextAlign(hdc, p_print_info->text_align);

  0005c	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextAlign@8

; 279  : 			SetBkMode(hdc, p_print_info->bk_mode);

  00067	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0006a	50		 push	 eax
  0006b	56		 push	 esi
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkMode@8

; 280  : 			SetBkColor(hdc, p_print_info->back_color);

  00072	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00075	51		 push	 ecx
  00076	56		 push	 esi
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8

; 281  : 			SetTextColor(hdc, p_print_info->text_color);

  0007d	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00080	52		 push	 edx
  00081	56		 push	 esi
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8

; 282  : 			SelectObject(hdc, p_print_info->hfont);

  00088	8b 07		 mov	 eax, DWORD PTR [edi]
  0008a	50		 push	 eax
  0008b	56		 push	 esi
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
$L88534:

; 283  : 		}
; 284  : 
; 285  : 		TextOut(hdc, x, y, sz_str, str_length);

  00092	8b 4c 24 20	 mov	 ecx, DWORD PTR _str_length$[esp+12]
  00096	8b 54 24 18	 mov	 edx, DWORD PTR _y$[esp+12]
  0009a	8b 44 24 14	 mov	 eax, DWORD PTR _x$[esp+12]
  0009e	51		 push	 ecx
  0009f	55		 push	 ebp
  000a0	52		 push	 edx
  000a1	50		 push	 eax
  000a2	56		 push	 esi
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TextOutA@20
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi

; 286  : 
; 287  : 		if(bGetDC)

  000ab	84 db		 test	 bl, bl
  000ad	5b		 pop	 ebx
  000ae	74 06		 je	 SHORT $L88535
  000b0	5d		 pop	 ebp

; 288  : 			g_FL2_ReleaseDC();

  000b1	e9 00 00 00 00	 jmp	 ?g_FL2_ReleaseDC@@YA_NXZ ; g_FL2_ReleaseDC
$L88535:
  000b6	5d		 pop	 ebp

; 289  : 
; 290  : 	}
; 291  : }

  000b7	c3		 ret	 0
?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z ENDP		; g_PrintLen
_TEXT	ENDS
PUBLIC	?g_PrintColorStrLen@@YAHHHPBDHAAUPrintInfo@@K@Z	; g_PrintColorStrLen
; Function compile flags: /Ogty
;	COMDAT ?g_PrintColorStrLen@@YAHHHPBDHAAUPrintInfo@@K@Z
_TEXT	SEGMENT
_use_pi$ = -20						; size = 20
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sz_str$ = 16						; size = 4
_str_length$ = 20					; size = 4
_pi$ = 24						; size = 4
_str_rgb$ = 28						; size = 4
?g_PrintColorStrLen@@YAHHHPBDHAAUPrintInfo@@K@Z PROC NEAR ; g_PrintColorStrLen, COMDAT

; 671  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H

; 672  : 	PrintInfo use_pi = pi;

  00003	8b 44 24 28	 mov	 eax, DWORD PTR _pi$[esp+16]
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	8b 28		 mov	 ebp, DWORD PTR [eax]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00011	89 4c 24 0c	 mov	 DWORD PTR _use_pi$[esp+32], ecx
  00015	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00018	89 54 24 10	 mov	 DWORD PTR _use_pi$[esp+36], edx
  0001c	8b 50 10	 mov	 edx, DWORD PTR [eax+16]

; 673  : 
; 674  : 	use_pi.text_color = str_rgb;

  0001f	8b 44 24 34	 mov	 eax, DWORD PTR _str_rgb$[esp+24]
  00023	89 44 24 0c	 mov	 DWORD PTR _use_pi$[esp+32], eax

; 675  : 
; 676  : 	bool bGetDC = g_FL2_GetDC();

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  0002c	85 c0		 test	 eax, eax
  0002e	56		 push	 esi
  0002f	57		 push	 edi
  00030	89 6c 24 10	 mov	 DWORD PTR _use_pi$[esp+36], ebp
  00034	89 4c 24 1c	 mov	 DWORD PTR _use_pi$[esp+48], ecx
  00038	89 54 24 20	 mov	 DWORD PTR _use_pi$[esp+52], edx
  0003c	75 1a		 jne	 SHORT $L90288
  0003e	68 14 02 00 00	 push	 532			; 00000214H
  00043	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  00048	50		 push	 eax
  00049	6a 05		 push	 5
  0004b	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00055	83 c4 10	 add	 esp, 16			; 00000010H
$L90288:
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  0005e	85 c9		 test	 ecx, ecx
  00060	75 0f		 jne	 SHORT $L90289
  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	68 00 00 00 00	 push	 OFFSET FLAT:?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00069	50		 push	 eax
  0006a	ff 51 44	 call	 DWORD PTR [ecx+68]
  0006d	b3 01		 mov	 bl, 1
  0006f	eb 02		 jmp	 SHORT $L90287
$L90289:
  00071	32 db		 xor	 bl, bl
$L90287:

; 677  : 
; 678  : 	g_PrintLen(x, y, sz_str, str_length, &use_pi);

  00073	8b 44 24 34	 mov	 eax, DWORD PTR _str_length$[esp+32]
  00077	8b 74 24 30	 mov	 esi, DWORD PTR _sz_str$[esp+32]
  0007b	8b 4c 24 2c	 mov	 ecx, DWORD PTR _y$[esp+32]
  0007f	8b 7c 24 28	 mov	 edi, DWORD PTR _x$[esp+32]
  00083	8d 54 24 10	 lea	 edx, DWORD PTR _use_pi$[esp+36]
  00087	52		 push	 edx
  00088	50		 push	 eax
  00089	56		 push	 esi
  0008a	51		 push	 ecx
  0008b	57		 push	 edi
  0008c	e8 00 00 00 00	 call	 ?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z ; g_PrintLen

; 679  : 
; 680  : 	int re = (x+g_GetStringWidth(sz_str, use_pi.hfont));

  00091	55		 push	 ebp
  00092	56		 push	 esi
  00093	e8 00 00 00 00	 call	 ?g_GetStringWidth@@YAHPBDPAUHFONT__@@@Z ; g_GetStringWidth
  00098	8b f0		 mov	 esi, eax
  0009a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0009d	03 f7		 add	 esi, edi

; 681  : 
; 682  : 	if(bGetDC)

  0009f	84 db		 test	 bl, bl
  000a1	74 05		 je	 SHORT $L90290

; 683  : 		g_FL2_ReleaseDC();

  000a3	e8 00 00 00 00	 call	 ?g_FL2_ReleaseDC@@YA_NXZ ; g_FL2_ReleaseDC
$L90290:
  000a8	5f		 pop	 edi

; 684  : 
; 685  : 	return re;

  000a9	8b c6		 mov	 eax, esi
  000ab	5e		 pop	 esi
  000ac	5d		 pop	 ebp
  000ad	5b		 pop	 ebx

; 686  : }

  000ae	83 c4 14	 add	 esp, 20			; 00000014H
  000b1	c3		 ret	 0
?g_PrintColorStrLen@@YAHHHPBDHAAUPrintInfo@@K@Z ENDP	; g_PrintColorStrLen
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::max_size
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 434  :   size_t max_size() const { return _Base::max_size(); }

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00005	c3		 ret	 0
?max_size@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBEIXZ ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ ; _STL::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >::~_STLP_alloc_proxy<char *,char,_STL::allocator<char> >
; Function compile flags: /Ogty
;	COMDAT ??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT
??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ PROC NEAR ; _STL::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >::~_STLP_alloc_proxy<char *,char,_STL::allocator<char> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@XZ ENDP ; _STL::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >::~_STLP_alloc_proxy<char *,char,_STL::allocator<char> >
_TEXT	ENDS
PUBLIC	?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::get_allocator
; Function compile flags: /Ogty
;	COMDAT ?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 216  :     return _STLP_CONVERT_ALLOCATOR((const allocator_type&)this->_M_end_of_storage, _CharT);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 217  :   }

  00004	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QBE?AV?$allocator@D@2@XZ ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::get_allocator
_TEXT	ENDS
PUBLIC	?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_terminate_string
; Function compile flags: /Ogty
;	COMDAT ?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ
_TEXT	SEGMENT
?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_terminate_string, COMDAT
; _this$ = ecx

; 355  :     _M_terminate_string_aux(_Char_Is_Integral());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c6 00 00	 mov	 BYTE PTR [eax], 0

; 356  :   }

  00006	c3		 ret	 0
?_M_terminate_string@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXXZ ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_terminate_string
_TEXT	ENDS
PUBLIC	??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z ; _STL::_String_base<char,_STL::allocator<char> >::_String_base<char,_STL::allocator<char> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___a$ = 8						; size = 4
??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z PROC NEAR ; _STL::_String_base<char,_STL::allocator<char> >::_String_base<char,_STL::allocator<char> >, COMDAT
; _this$ = ecx

; 129  :     : _M_start(0), _M_finish(0), _M_end_of_storage(__a, (_Tp*)0) {}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___a$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	50		 push	 eax
  0000a	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	e8 00 00 00 00	 call	 ??0?$_STLP_alloc_proxy@PADDV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@PAD@Z ; _STL::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >::_STLP_alloc_proxy<char *,char,_STL::allocator<char> >
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	c2 04 00	 ret	 4
??0?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@ABV?$allocator@D@1@@Z ENDP ; _STL::_String_base<char,_STL::allocator<char> >::_String_base<char,_STL::allocator<char> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@_STL@@QAEXPADI@Z	; _STL::allocator<char>::deallocate
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_alloc.h
;	COMDAT ?deallocate@?$allocator@D@_STL@@QAEXPADI@Z
_TEXT	SEGMENT
___p$ = 8						; size = 4
___n$ = 12						; size = 4
?deallocate@?$allocator@D@_STL@@QAEXPADI@Z PROC NEAR	; _STL::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 359  :     _STLP_ASSERT( (__p == 0) == (__n == 0) )
; 360  :       if (__p != 0) __sgi_alloc::deallocate((void*)__p, __n * sizeof(value_type));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___p$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 22		 je	 SHORT $L90328
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR ___n$[esp-4]
  0000c	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00012	76 0c		 jbe	 SHORT $L90327
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001a	83 c4 04	 add	 esp, 4

; 361  :   }

  0001d	c2 08 00	 ret	 8

; 359  :     _STLP_ASSERT( (__p == 0) == (__n == 0) )
; 360  :       if (__p != 0) __sgi_alloc::deallocate((void*)__p, __n * sizeof(value_type));

$L90327:
  00020	51		 push	 ecx
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z ; _STL::__node_alloc<1,0>::_M_deallocate
  00027	83 c4 08	 add	 esp, 8
$L90328:

; 361  :   }

  0002a	c2 08 00	 ret	 8
?deallocate@?$allocator@D@_STL@@QAEXPADI@Z ENDP		; _STL::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z	; _STL::allocator<char>::allocate
; Function compile flags: /Ogty
;	COMDAT ?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z
_TEXT	SEGMENT
___n$ = 8						; size = 4
___formal$ = 12						; size = 4
?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z PROC NEAR	; _STL::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 355  :     return __n != 0 ? __REINTERPRET_CAST(value_type*,__sgi_alloc::allocate(__n * sizeof(value_type))) : 0;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___n$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 1e		 je	 SHORT $L90332
  00008	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0000d	50		 push	 eax
  0000e	76 0b		 jbe	 SHORT $L90342
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	83 c4 04	 add	 esp, 4

; 356  :   }

  00018	c2 08 00	 ret	 8

; 355  :     return __n != 0 ? __REINTERPRET_CAST(value_type*,__sgi_alloc::allocate(__n * sizeof(value_type))) : 0;

$L90342:
  0001b	e8 00 00 00 00	 call	 ?_M_allocate@?$__node_alloc@$00$0A@@_STL@@CAPAXI@Z ; _STL::__node_alloc<1,0>::_M_allocate
  00020	83 c4 04	 add	 esp, 4

; 356  :   }

  00023	c2 08 00	 ret	 8
$L90332:

; 355  :     return __n != 0 ? __REINTERPRET_CAST(value_type*,__sgi_alloc::allocate(__n * sizeof(value_type))) : 0;

  00026	33 c0		 xor	 eax, eax

; 356  :   }

  00028	c2 08 00	 ret	 8
?allocate@?$allocator@D@_STL@@QAEPADIPBX@Z ENDP		; _STL::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_construct_null
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z
_TEXT	SEGMENT
___p$ = 8						; size = 4
?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_construct_null, COMDAT
; _this$ = ecx

; 336  :     _M_construct_null_aux(__p, _Char_Is_Integral());

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___p$[esp-4]
  00004	c6 00 00	 mov	 BYTE PTR [eax], 0

; 337  :   }

  00007	c2 04 00	 ret	 4
?_M_construct_null@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_construct_null
_TEXT	ENDS
PUBLIC	??$distance@PBD@_STL@@YAHABQBD0@Z		; _STL::distance<char const *>
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_iterator_base.h
;	COMDAT ??$distance@PBD@_STL@@YAHABQBD0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$distance@PBD@_STL@@YAHABQBD0@Z PROC NEAR		; _STL::distance<char const *>, COMDAT

; 369  :   return __distance(__first, __last, _STLP_ITERATOR_CATEGORY(__first, _InputIterator));  

  00000	8b 44 24 08	 mov	 eax, DWORD PTR ___last$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR ___first$[esp-4]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	2b 01		 sub	 eax, DWORD PTR [ecx]

; 370  : }

  0000c	c3		 ret	 0
??$distance@PBD@_STL@@YAHABQBD0@Z ENDP			; _STL::distance<char const *>
_TEXT	ENDS
PUBLIC	?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z ; _STL::_String_base<char,_STL::allocator<char> >::_M_allocate_block
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.c
;	COMDAT ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z
_TEXT	SEGMENT
___n$ = 8						; size = 4
?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z PROC NEAR ; _STL::_String_base<char,_STL::allocator<char> >::_M_allocate_block, COMDAT
; _this$ = ecx

; 530  : template <class _Tp, class _Alloc> void _String_base<_Tp, _Alloc>::_M_allocate_block(size_t __n) {  

  00000	56		 push	 esi

; 531  :   if ((__n <= (max_size()+1)) && (__n>0)){ 

  00001	8b 74 24 08	 mov	 esi, DWORD PTR ___n$[esp]
  00005	83 fe ff	 cmp	 esi, -1
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	77 3b		 ja	 SHORT $L89515
  0000d	85 f6		 test	 esi, esi
  0000f	76 37		 jbe	 SHORT $L89515

; 532  :     _M_start  = _M_end_of_storage.allocate(__n); 

  00011	81 fe 80 00 00
	00		 cmp	 esi, 128		; 00000080H
  00017	56		 push	 esi
  00018	76 17		 jbe	 SHORT $L90387
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	83 c4 04	 add	 esp, 4
  00022	89 07		 mov	 DWORD PTR [edi], eax

; 533  :     _M_finish = _M_start; 

  00024	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 534  :     _M_end_of_storage._M_data = _M_start + __n; 

  00027	03 c6		 add	 eax, esi
  00029	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 538  : } 

  0002e	c2 04 00	 ret	 4

; 532  :     _M_start  = _M_end_of_storage.allocate(__n); 

$L90387:
  00031	e8 00 00 00 00	 call	 ?_M_allocate@?$__node_alloc@$00$0A@@_STL@@CAPAXI@Z ; _STL::__node_alloc<1,0>::_M_allocate
  00036	83 c4 04	 add	 esp, 4
  00039	89 07		 mov	 DWORD PTR [edi], eax

; 533  :     _M_finish = _M_start; 

  0003b	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 534  :     _M_end_of_storage._M_data = _M_start + __n; 

  0003e	03 c6		 add	 eax, esi
  00040	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi

; 538  : } 

  00045	c2 04 00	 ret	 4
$L89515:

; 535  :   } 
; 536  :     else 
; 537  :       _M_throw_length_error(); 

  00048	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@GOPDCEEB@basic_string?$AA@
  0004d	e8 00 00 00 00	 call	 ?__stl_throw_length_error@_STL@@YAXPBD@Z ; _STL::__stl_throw_length_error
  00052	83 c4 04	 add	 esp, 4
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 538  : } 

  00057	c2 04 00	 ret	 4
?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z ENDP ; _STL::_String_base<char,_STL::allocator<char> >::_M_allocate_block
_TEXT	ENDS
PUBLIC	??$distance@PAD@_STL@@YAHABQAD0@Z		; _STL::distance<char *>
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_iterator_base.h
;	COMDAT ??$distance@PAD@_STL@@YAHABQAD0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
??$distance@PAD@_STL@@YAHABQAD0@Z PROC NEAR		; _STL::distance<char *>, COMDAT

; 369  :   return __distance(__first, __last, _STLP_ITERATOR_CATEGORY(__first, _InputIterator));  

  00000	8b 44 24 08	 mov	 eax, DWORD PTR ___last$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR ___first$[esp-4]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	2b 01		 sub	 eax, DWORD PTR [ecx]

; 370  : }

  0000c	c3		 ret	 0
??$distance@PAD@_STL@@YAHABQAD0@Z ENDP			; _STL::distance<char *>
_TEXT	ENDS
PUBLIC	??$advance@PBDH@_STL@@YAXAAPBDH@Z		; _STL::advance<char const *,int>
; Function compile flags: /Ogty
;	COMDAT ??$advance@PBDH@_STL@@YAXAAPBDH@Z
_TEXT	SEGMENT
___i$ = 8						; size = 4
___n$ = 12						; size = 4
??$advance@PBDH@_STL@@YAXAAPBDH@Z PROC NEAR		; _STL::advance<char const *,int>, COMDAT

; 449  :   __advance(__i, __n, _STLP_ITERATOR_CATEGORY(__i, _InputIterator));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___i$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8b 4c 24 08	 mov	 ecx, DWORD PTR ___n$[esp-4]
  0000a	03 d1		 add	 edx, ecx
  0000c	89 10		 mov	 DWORD PTR [eax], edx

; 450  : }

  0000e	c3		 ret	 0
??$advance@PBDH@_STL@@YAXAAPBDH@Z ENDP			; _STL::advance<char const *,int>
_TEXT	ENDS
PUBLIC	??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z ; _STL::__copy_aux<char *,char *>
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_algobase.h
;	COMDAT ??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
___result$ = 16						; size = 4
___formal$ = 20						; size = 4
??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z PROC NEAR ; _STL::__copy_aux<char *,char *>, COMDAT

; 202  :   return __copy_ptrs(__first, __last, __result, 
; 203  :                      _IsOKToMemCpy(_STLP_VALUE_TYPE(__first, _InputIter), 
; 204  :                                    _STLP_VALUE_TYPE(__result, _OutputIter))._Ret());

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___first$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR ___last$[esp]
  00009	3b f0		 cmp	 esi, eax
  0000b	75 06		 jne	 SHORT $L90435
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR ___result$[esp]
  00011	5e		 pop	 esi

; 205  : }

  00012	c3		 ret	 0

; 202  :   return __copy_ptrs(__first, __last, __result, 
; 203  :                      _IsOKToMemCpy(_STLP_VALUE_TYPE(__first, _InputIter), 
; 204  :                                    _STLP_VALUE_TYPE(__result, _OutputIter))._Ret());

$L90435:
  00013	2b f0		 sub	 esi, eax
  00015	56		 push	 esi
  00016	50		 push	 eax
  00017	8b 44 24 18	 mov	 eax, DWORD PTR ___result$[esp+8]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 205  : }

  00027	c3		 ret	 0
??$__copy_aux@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z ENDP ; _STL::__copy_aux<char *,char *>
_TEXT	ENDS
PUBLIC	?g_Print@@YAXHHPBDPAUPrintInfo@@@Z		; g_Print
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\new - vs_ui\src\hangul\fl2.h
;	COMDAT ?g_Print@@YAXHHPBDPAUPrintInfo@@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sz_str$ = 16						; size = 4
_p_print_info$ = 20					; size = 4
?g_Print@@YAXHHPBDPAUPrintInfo@@@Z PROC NEAR		; g_Print, COMDAT

; 72   : { g_PrintLen(x, y, sz_str, strlen(sz_str), p_print_info); }

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR _sz_str$[esp-4]
  00004	8b c2		 mov	 eax, edx
  00006	56		 push	 esi
  00007	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000a	8d 9b 00 00 00
	00		 npad	 6
$L90441:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L90441
  00017	8b 4c 24 14	 mov	 ecx, DWORD PTR _p_print_info$[esp]
  0001b	51		 push	 ecx
  0001c	2b c6		 sub	 eax, esi
  0001e	50		 push	 eax
  0001f	8b 44 24 10	 mov	 eax, DWORD PTR _x$[esp+8]
  00023	52		 push	 edx
  00024	8b 54 24 18	 mov	 edx, DWORD PTR _y$[esp+12]
  00028	52		 push	 edx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z ; g_PrintLen
  0002f	83 c4 14	 add	 esp, 20			; 00000014H
  00032	5e		 pop	 esi
  00033	c3		 ret	 0
?g_Print@@YAXHHPBDPAUPrintInfo@@@Z ENDP			; g_Print
_TEXT	ENDS
PUBLIC	?g_PrintColorStr@@YAHHHPBDAAUPrintInfo@@K@Z	; g_PrintColorStr
; Function compile flags: /Ogty
;	COMDAT ?g_PrintColorStr@@YAHHHPBDAAUPrintInfo@@K@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sz_str$ = 16						; size = 4
_pi$ = 20						; size = 4
_str_rgb$ = 24						; size = 4
?g_PrintColorStr@@YAHHHPBDAAUPrintInfo@@K@Z PROC NEAR	; g_PrintColorStr, COMDAT

; 77   : 	if ( sz_str != NULL )

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR _sz_str$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	74 31		 je	 SHORT $L74307

; 78   : 	    return g_PrintColorStrLen(x, y, sz_str, strlen(sz_str), pi, str_rgb); 

  00008	8b c2		 mov	 eax, edx
  0000a	56		 push	 esi
  0000b	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000e	8b ff		 npad	 2
$L90445:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L90445
  00017	8b 4c 24 18	 mov	 ecx, DWORD PTR _str_rgb$[esp]
  0001b	51		 push	 ecx
  0001c	8b 4c 24 18	 mov	 ecx, DWORD PTR _pi$[esp+4]
  00020	51		 push	 ecx
  00021	2b c6		 sub	 eax, esi
  00023	50		 push	 eax
  00024	8b 44 24 14	 mov	 eax, DWORD PTR _x$[esp+12]
  00028	52		 push	 edx
  00029	8b 54 24 1c	 mov	 edx, DWORD PTR _y$[esp+16]
  0002d	52		 push	 edx
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?g_PrintColorStrLen@@YAHHHPBDHAAUPrintInfo@@K@Z ; g_PrintColorStrLen
  00034	83 c4 18	 add	 esp, 24			; 00000018H
  00037	5e		 pop	 esi

; 81   : }

  00038	c3		 ret	 0
$L74307:

; 79   : 
; 80   : 	return 0;

  00039	33 c0		 xor	 eax, eax

; 81   : }

  0003b	c3		 ret	 0
?g_PrintColorStr@@YAHHHPBDAAUPrintInfo@@K@Z ENDP	; g_PrintColorStr
_TEXT	ENDS
PUBLIC	?g_GetStringIndexByWidth@@YAHPBDHPAUHFONT__@@@Z	; g_GetStringIndexByWidth
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\new - vs_ui\src\hangul\fl2.cpp
;	COMDAT ?g_GetStringIndexByWidth@@YAHPBDHPAUHFONT__@@@Z
_TEXT	SEGMENT
_sz_str$ = 8						; size = 4
_Width$ = 12						; size = 4
_hfont$ = 16						; size = 4
?g_GetStringIndexByWidth@@YAHPBDHPAUHFONT__@@@Z PROC NEAR ; g_GetStringIndexByWidth, COMDAT

; 118  : 	int iStrWidth = g_GetStringWidth (sz_str, hfont);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _hfont$[esp-4]
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR _sz_str$[esp+8]
  0000b	50		 push	 eax
  0000c	57		 push	 edi
  0000d	e8 00 00 00 00	 call	 ?g_GetStringWidth@@YAHPBDPAUHFONT__@@@Z ; g_GetStringWidth

; 119  : 	int resIndex;
; 120  : 	int Len = strlen(sz_str);

  00012	8b cf		 mov	 ecx, edi
  00014	83 c4 08	 add	 esp, 8
  00017	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$L90472:
  00020	8a 11		 mov	 dl, BYTE PTR [ecx]
  00022	41		 inc	 ecx
  00023	84 d2		 test	 dl, dl
  00025	75 f9		 jne	 SHORT $L90472

; 121  : 
; 122  : 	if (iStrWidth <= Width)	//ÊçîÙ Ðï?Ôõõµ.

  00027	8b 6c 24 14	 mov	 ebp, DWORD PTR _Width$[esp+8]
  0002b	2b ce		 sub	 ecx, esi
  0002d	3b c5		 cmp	 eax, ebp
  0002f	7f 07		 jg	 SHORT $L88463
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 123  : 		resIndex = Len - 1;

  00033	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00036	5d		 pop	 ebp

; 141  : }

  00037	c3		 ret	 0
$L88463:

; 124  : 	else
; 125  : 	{
; 126  : 		int Index = Len -1;
; 127  : 		while (--Index)

  00038	8d 71 fe	 lea	 esi, DWORD PTR [ecx-2]
  0003b	85 f6		 test	 esi, esi
  0003d	74 5e		 je	 SHORT $L90469
  0003f	53		 push	 ebx
  00040	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
$L88467:

; 128  : 		{
; 129  : 			if (!g_PossibleStringCut (sz_str, Index))

  00043	85 ff		 test	 edi, edi
  00045	74 3a		 je	 SHORT $L90452
  00047	8b c7		 mov	 eax, edi
  00049	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0004c	8d 64 24 00	 npad	 4
$L90473:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	40		 inc	 eax
  00053	84 c9		 test	 cl, cl
  00055	75 f9		 jne	 SHORT $L90473
  00057	2b c2		 sub	 eax, edx
  00059	3b c6		 cmp	 eax, esi
  0005b	7e 26		 jle	 SHORT $L88469
  0005d	33 c0		 xor	 eax, eax
  0005f	85 f6		 test	 esi, esi
  00061	7c 20		 jl	 SHORT $L88469
$L90459:
  00063	80 3c 38 80	 cmp	 BYTE PTR [eax+edi], 128	; 00000080H
  00067	76 08		 jbe	 SHORT $L90462
  00069	40		 inc	 eax
  0006a	b9 01 00 00 00	 mov	 ecx, 1
  0006f	eb 02		 jmp	 SHORT $L90460
$L90462:
  00071	33 c9		 xor	 ecx, ecx
$L90460:
  00073	40		 inc	 eax
  00074	3b c6		 cmp	 eax, esi
  00076	7e eb		 jle	 SHORT $L90459
  00078	83 f9 01	 cmp	 ecx, 1
  0007b	75 06		 jne	 SHORT $L88469
  0007d	3b c3		 cmp	 eax, ebx
  0007f	7f 02		 jg	 SHORT $L88469
$L90452:

; 130  : 				Index --;

  00081	4e		 dec	 esi
  00082	4b		 dec	 ebx
$L88469:

; 131  : 
; 132  : 			iStrWidth = g_GetStringWidth2 (sz_str, Index+1, hfont);

  00083	8b 4c 24 1c	 mov	 ecx, DWORD PTR _hfont$[esp+12]
  00087	51		 push	 ecx
  00088	53		 push	 ebx
  00089	57		 push	 edi
  0008a	e8 00 00 00 00	 call	 ?g_GetStringWidth2@@YAHPBDHPAUHFONT__@@@Z ; g_GetStringWidth2
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 133  : 			if(iStrWidth <= Width)

  00092	3b c5		 cmp	 eax, ebp
  00094	7e 06		 jle	 SHORT $L90475
  00096	4e		 dec	 esi
  00097	4b		 dec	 ebx
  00098	85 f6		 test	 esi, esi
  0009a	75 a7		 jne	 SHORT $L88467
$L90475:
  0009c	5b		 pop	 ebx
$L90469:
  0009d	5f		 pop	 edi

; 134  : 				break;
; 135  : 		}
; 136  : 		//?Õô Index??.. Width?? ÖÁ×» Ï¿? ?Öð?ÕÉ Üõ×»Ý½ Ù»Ý¯ÚñÕÉ ÍÝÙ¹.
; 137  : 		resIndex = Index;
; 138  : 	}
; 139  : 
; 140  : 	return resIndex;

  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi
  000a1	5d		 pop	 ebp

; 141  : }

  000a2	c3		 ret	 0
?g_GetStringIndexByWidth@@YAHPBDHPAUHFONT__@@@Z ENDP	; g_GetStringIndexByWidth
_TEXT	ENDS
PUBLIC	?g_PrintColorStr2@@YAHHHPBDAAUPrintInfo@@KH@Z	; g_PrintColorStr2
EXTRN	_strncpy:NEAR
; Function compile flags: /Ogty
;	COMDAT ?g_PrintColorStr2@@YAHHHPBDAAUPrintInfo@@KH@Z
_TEXT	SEGMENT
tv295 = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sz_str$ = 16						; size = 4
_pi$ = 20						; size = 4
_str_rgb$ = 24						; size = 4
_LimitWidth$ = 28					; size = 4
?g_PrintColorStr2@@YAHHHPBDAAUPrintInfo@@KH@Z PROC NEAR	; g_PrintColorStr2, COMDAT

; 144  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 145  : 	int iStrWidth = g_GetStringWidth ((const char*)sz_str, pi.hfont);

  00002	8b 5c 24 14	 mov	 ebx, DWORD PTR _sz_str$[esp+4]
  00006	56		 push	 esi
  00007	8b 74 24 1c	 mov	 esi, DWORD PTR _pi$[esp+8]
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	50		 push	 eax
  0000e	53		 push	 ebx
  0000f	e8 00 00 00 00	 call	 ?g_GetStringWidth@@YAHPBDPAUHFONT__@@@Z ; g_GetStringWidth

; 146  : 	if (iStrWidth <= LimitWidth)

  00014	8b 4c 24 2c	 mov	 ecx, DWORD PTR _LimitWidth$[esp+16]
  00018	83 c4 08	 add	 esp, 8
  0001b	3b c1		 cmp	 eax, ecx
  0001d	7f 36		 jg	 SHORT $L88481

; 147  : 		return g_PrintColorStr (x, y, sz_str, pi, str_rgb);

  0001f	85 db		 test	 ebx, ebx
  00021	74 2c		 je	 SHORT $L90484
  00023	8b c3		 mov	 eax, ebx
  00025	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L90519:
  00028	8a 08		 mov	 cl, BYTE PTR [eax]
  0002a	40		 inc	 eax
  0002b	84 c9		 test	 cl, cl
  0002d	75 f9		 jne	 SHORT $L90519
  0002f	8b 4c 24 20	 mov	 ecx, DWORD PTR _str_rgb$[esp+8]
  00033	51		 push	 ecx
  00034	2b c2		 sub	 eax, edx
  00036	8b 54 24 18	 mov	 edx, DWORD PTR _y$[esp+12]
  0003a	56		 push	 esi
  0003b	50		 push	 eax
  0003c	8b 44 24 1c	 mov	 eax, DWORD PTR _x$[esp+20]
  00040	53		 push	 ebx
  00041	52		 push	 edx
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?g_PrintColorStrLen@@YAHHHPBDHAAUPrintInfo@@K@Z ; g_PrintColorStrLen
  00048	83 c4 18	 add	 esp, 24			; 00000018H
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx

; 178  : 	}
; 179  : }

  0004d	59		 pop	 ecx
  0004e	c3		 ret	 0

; 147  : 		return g_PrintColorStr (x, y, sz_str, pi, str_rgb);

$L90484:
  0004f	5e		 pop	 esi
  00050	33 c0		 xor	 eax, eax
  00052	5b		 pop	 ebx

; 178  : 	}
; 179  : }

  00053	59		 pop	 ecx
  00054	c3		 ret	 0
$L88481:

; 148  : 	else
; 149  : 	{
; 150  : 		// Øó?ó¦ ?Öð?ÕÉ ?Ðë Ü©??, ÕôÊµ Ü©??õµ Ü©õµ. ÕôÊµ Ü©?ÜË ÖÁ×» Ï¿??.. ?Öð?? ÖðÝ×õµ..
; 151  : 		int Len = strlen (sz_str);

  00055	8b c3		 mov	 eax, ebx
  00057	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0005a	8d 9b 00 00 00
	00		 npad	 6
$L90520:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	84 c9		 test	 cl, cl
  00065	75 f9		 jne	 SHORT $L90520
  00067	2b c2		 sub	 eax, edx
  00069	55		 push	 ebp
  0006a	8b f0		 mov	 esi, eax

; 152  : 		char *strTemp = new char [Len + 1];

  0006c	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0006f	57		 push	 edi
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00076	83 c4 04	 add	 esp, 4

; 153  : 
; 154  : 		int Index = Len - 1;
; 155  : 		while (--Index)

  00079	83 c6 fe	 add	 esi, -2			; fffffffeH
  0007c	8b e8		 mov	 ebp, eax
  0007e	74 7e		 je	 SHORT $L90517
  00080	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  00083	89 54 24 10	 mov	 DWORD PTR tv295[esp+20], edx
$L88489:

; 156  : 		{
; 157  : 			if (!g_PossibleStringCut (sz_str, Index))

  00087	85 db		 test	 ebx, ebx
  00089	74 38		 je	 SHORT $L90525
  0008b	8b c3		 mov	 eax, ebx
  0008d	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L90521:
  00090	8a 08		 mov	 cl, BYTE PTR [eax]
  00092	40		 inc	 eax
  00093	84 c9		 test	 cl, cl
  00095	75 f9		 jne	 SHORT $L90521
  00097	2b c2		 sub	 eax, edx
  00099	3b c6		 cmp	 eax, esi
  0009b	7e 30		 jle	 SHORT $L88491
  0009d	33 c0		 xor	 eax, eax
  0009f	85 f6		 test	 esi, esi
  000a1	7c 2a		 jl	 SHORT $L88491
$L90495:
  000a3	80 3c 18 80	 cmp	 BYTE PTR [eax+ebx], 128	; 00000080H
  000a7	76 08		 jbe	 SHORT $L90498
  000a9	40		 inc	 eax
  000aa	b9 01 00 00 00	 mov	 ecx, 1
  000af	eb 02		 jmp	 SHORT $L90496
$L90498:
  000b1	33 c9		 xor	 ecx, ecx
$L90496:
  000b3	40		 inc	 eax
  000b4	3b c6		 cmp	 eax, esi
  000b6	7e eb		 jle	 SHORT $L90495
  000b8	83 f9 01	 cmp	 ecx, 1
  000bb	75 10		 jne	 SHORT $L88491
  000bd	3b 44 24 10	 cmp	 eax, DWORD PTR tv295[esp+20]
  000c1	7f 0a		 jg	 SHORT $L88491
$L90525:

; 158  : 			{
; 159  : 				//ÖðÜË ? ?? Index (ÊµÞ¢îü 2Î¯?? ?Öð??ñÕ?Ý« .. ?í¶)ÖÕ ÷úöá.. Êµ? ? --
; 160  : 				Index--;

  000c3	8b 44 24 10	 mov	 eax, DWORD PTR tv295[esp+20]
  000c7	4e		 dec	 esi
  000c8	48		 dec	 eax
  000c9	89 44 24 10	 mov	 DWORD PTR tv295[esp+20], eax
$L88491:

; 161  : 			}
; 162  : 			//?Öð? Ü©? ý§ÛÎ..
; 163  : 			iStrWidth = g_GetStringWidth2 ((const char*)sz_str, Index-1, pi.hfont);

  000cd	8b 44 24 24	 mov	 eax, DWORD PTR _pi$[esp+16]
  000d1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d3	51		 push	 ecx
  000d4	8d 7e ff	 lea	 edi, DWORD PTR [esi-1]
  000d7	57		 push	 edi
  000d8	53		 push	 ebx
  000d9	e8 00 00 00 00	 call	 ?g_GetStringWidth2@@YAHPBDHPAUHFONT__@@@Z ; g_GetStringWidth2

; 164  : 			if (iStrWidth <= LimitWidth)

  000de	8b 4c 24 38	 mov	 ecx, DWORD PTR _LimitWidth$[esp+28]
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	3b c1		 cmp	 eax, ecx
  000e7	7e 11		 jle	 SHORT $L90515
  000e9	8b 4c 24 10	 mov	 ecx, DWORD PTR tv295[esp+20]
  000ed	8b f7		 mov	 esi, edi
  000ef	49		 dec	 ecx
  000f0	85 f6		 test	 esi, esi
  000f2	89 4c 24 10	 mov	 DWORD PTR tv295[esp+20], ecx
  000f6	75 8f		 jne	 SHORT $L88489

; 165  : 				break;
; 166  : 		}
; 167  : 		// ?Öð?ÕÉ ???×» ?õµ?.. øÉÛíÝ¤? ÷ôÕÉ ??×»Ý«.. Ú¶?
; 168  : 		if (Index==0)

  000f8	eb 04		 jmp	 SHORT $L90517
$L90515:
  000fa	85 f6		 test	 esi, esi
  000fc	75 3e		 jne	 SHORT $L88494
$L90517:

; 169  : 			return g_PrintColorStr (x, y, sz_str, pi, str_rgb);

  000fe	85 db		 test	 ebx, ebx
  00100	74 32		 je	 SHORT $L90507
  00102	8b c3		 mov	 eax, ebx
  00104	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L90522:
  00107	8a 08		 mov	 cl, BYTE PTR [eax]
  00109	40		 inc	 eax
  0010a	84 c9		 test	 cl, cl
  0010c	75 f9		 jne	 SHORT $L90522
  0010e	8b 4c 24 24	 mov	 ecx, DWORD PTR _pi$[esp+16]
  00112	2b c2		 sub	 eax, edx
  00114	8b 54 24 28	 mov	 edx, DWORD PTR _str_rgb$[esp+16]
  00118	52		 push	 edx
  00119	8b 54 24 20	 mov	 edx, DWORD PTR _y$[esp+20]
  0011d	51		 push	 ecx
  0011e	50		 push	 eax
  0011f	8b 44 24 24	 mov	 eax, DWORD PTR _x$[esp+28]
  00123	53		 push	 ebx
  00124	52		 push	 edx
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 ?g_PrintColorStrLen@@YAHHHPBDHAAUPrintInfo@@K@Z ; g_PrintColorStrLen
  0012b	83 c4 18	 add	 esp, 24			; 00000018H
  0012e	5f		 pop	 edi
  0012f	5d		 pop	 ebp
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx

; 178  : 	}
; 179  : }

  00132	59		 pop	 ecx
  00133	c3		 ret	 0

; 169  : 			return g_PrintColorStr (x, y, sz_str, pi, str_rgb);

$L90507:
  00134	5f		 pop	 edi
  00135	5d		 pop	 ebp
  00136	5e		 pop	 esi
  00137	33 c0		 xor	 eax, eax
  00139	5b		 pop	 ebx

; 178  : 	}
; 179  : }

  0013a	59		 pop	 ecx
  0013b	c3		 ret	 0
$L88494:

; 170  : 		// ñÐ?äù?.. Index Ý«ÒÁÝ«.. øÉÝ¹õµ. ÖÕ?.. ÕÜ? ÖðÝ× õµ?ñÕ.. '..'? ??×ùÖð.
; 171  : 		strncpy (strTemp, sz_str, Index-2);

  0013c	8d 4e fe	 lea	 ecx, DWORD PTR [esi-2]
  0013f	51		 push	 ecx
  00140	53		 push	 ebx
  00141	55		 push	 ebp
  00142	e8 00 00 00 00	 call	 _strncpy

; 172  : 		strTemp [Index-2] = '.';

  00147	b0 2e		 mov	 al, 46			; 0000002eH
  00149	83 c4 0c	 add	 esp, 12			; 0000000cH

; 173  : 		strTemp [Index-1] = '.';
; 174  : 		strTemp [Index] = '\0';
; 175  : 		int res = g_PrintColorStr (x, y, (const char*)strTemp, pi, str_rgb);

  0014c	85 ed		 test	 ebp, ebp
  0014e	88 44 2e fe	 mov	 BYTE PTR [esi+ebp-2], al
  00152	88 44 2e ff	 mov	 BYTE PTR [esi+ebp-1], al
  00156	c6 04 2e 00	 mov	 BYTE PTR [esi+ebp], 0
  0015a	74 3f		 je	 SHORT $L90512
  0015c	8b c5		 mov	 eax, ebp
  0015e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L90523:
  00161	8a 08		 mov	 cl, BYTE PTR [eax]
  00163	40		 inc	 eax
  00164	84 c9		 test	 cl, cl
  00166	75 f9		 jne	 SHORT $L90523
  00168	8b 4c 24 24	 mov	 ecx, DWORD PTR _pi$[esp+16]
  0016c	2b c2		 sub	 eax, edx
  0016e	8b 54 24 28	 mov	 edx, DWORD PTR _str_rgb$[esp+16]
  00172	52		 push	 edx
  00173	8b 54 24 20	 mov	 edx, DWORD PTR _y$[esp+20]
  00177	51		 push	 ecx
  00178	50		 push	 eax
  00179	8b 44 24 24	 mov	 eax, DWORD PTR _x$[esp+28]
  0017d	55		 push	 ebp
  0017e	52		 push	 edx
  0017f	50		 push	 eax
  00180	e8 00 00 00 00	 call	 ?g_PrintColorStrLen@@YAHHHPBDHAAUPrintInfo@@K@Z ; g_PrintColorStrLen
  00185	83 c4 18	 add	 esp, 24			; 00000018H

; 176  : 		delete strTemp;

  00188	55		 push	 ebp
  00189	8b f0		 mov	 esi, eax
  0018b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00190	83 c4 04	 add	 esp, 4
  00193	5f		 pop	 edi
  00194	5d		 pop	 ebp

; 177  : 		return res;

  00195	8b c6		 mov	 eax, esi
  00197	5e		 pop	 esi
  00198	5b		 pop	 ebx

; 178  : 	}
; 179  : }

  00199	59		 pop	 ecx
  0019a	c3		 ret	 0

; 173  : 		strTemp [Index-1] = '.';
; 174  : 		strTemp [Index] = '\0';
; 175  : 		int res = g_PrintColorStr (x, y, (const char*)strTemp, pi, str_rgb);

$L90512:

; 176  : 		delete strTemp;

  0019b	55		 push	 ebp
  0019c	33 f6		 xor	 esi, esi
  0019e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001a3	83 c4 04	 add	 esp, 4
  001a6	5f		 pop	 edi
  001a7	5d		 pop	 ebp

; 177  : 		return res;

  001a8	8b c6		 mov	 eax, esi
  001aa	5e		 pop	 esi
  001ab	5b		 pop	 ebx

; 178  : 	}
; 179  : }

  001ac	59		 pop	 ecx
  001ad	c3		 ret	 0
?g_PrintColorStr2@@YAHHHPBDAAUPrintInfo@@KH@Z ENDP	; g_PrintColorStr2
_TEXT	ENDS
PUBLIC	?g_PrintColorStrOut@@YAHHHPBDAAUPrintInfo@@KK@Z	; g_PrintColorStrOut
; Function compile flags: /Ogty
;	COMDAT ?g_PrintColorStrOut@@YAHHHPBDAAUPrintInfo@@KK@Z
_TEXT	SEGMENT
_use_pi$ = -20						; size = 20
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sz_str$ = 16						; size = 4
_pi$ = 20						; size = 4
_str_rgb$ = 24						; size = 4
_out_rgb$ = 28						; size = 4
?g_PrintColorStrOut@@YAHHHPBDAAUPrintInfo@@KK@Z PROC NEAR ; g_PrintColorStrOut, COMDAT

; 695  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H

; 696  : 	PrintInfo use_pi = pi;

  00003	8b 44 24 24	 mov	 eax, DWORD PTR _pi$[esp+16]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0000c	89 0c 24	 mov	 DWORD PTR _use_pi$[esp+20], ecx
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	89 54 24 04	 mov	 DWORD PTR _use_pi$[esp+24], edx
  00016	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00019	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0001c	89 44 24 10	 mov	 DWORD PTR _use_pi$[esp+36], eax

; 697  : 
; 698  : 	use_pi.text_color = out_rgb;
; 699  : 	bool bGetDC = g_FL2_GetDC();

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00025	85 c0		 test	 eax, eax
  00027	89 4c 24 08	 mov	 DWORD PTR _use_pi$[esp+28], ecx
  0002b	8b 4c 24 2c	 mov	 ecx, DWORD PTR _out_rgb$[esp+16]
  0002f	89 54 24 0c	 mov	 DWORD PTR _use_pi$[esp+32], edx
  00033	89 4c 24 04	 mov	 DWORD PTR _use_pi$[esp+24], ecx
  00037	75 1a		 jne	 SHORT $L90534
  00039	68 14 02 00 00	 push	 532			; 00000214H
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  00043	50		 push	 eax
  00044	6a 05		 push	 5
  00046	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00050	83 c4 10	 add	 esp, 16			; 00000010H
$L90534:
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00059	85 c9		 test	 ecx, ecx
  0005b	53		 push	 ebx
  0005c	55		 push	 ebp
  0005d	56		 push	 esi
  0005e	57		 push	 edi
  0005f	75 0f		 jne	 SHORT $L90535
  00061	8b 10		 mov	 edx, DWORD PTR [eax]
  00063	68 00 00 00 00	 push	 OFFSET FLAT:?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00068	50		 push	 eax
  00069	ff 52 44	 call	 DWORD PTR [edx+68]
  0006c	b3 01		 mov	 bl, 1
  0006e	eb 02		 jmp	 SHORT $L90533
$L90535:
  00070	32 db		 xor	 bl, bl
$L90533:

; 700  : 	g_Print(x-1, y, sz_str, &use_pi);

  00072	8b 74 24 30	 mov	 esi, DWORD PTR _sz_str$[esp+32]
  00076	8b c6		 mov	 eax, esi
  00078	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0007b	eb 03 8d 49 00	 npad	 5
$L90551:
  00080	8a 08		 mov	 cl, BYTE PTR [eax]
  00082	40		 inc	 eax
  00083	84 c9		 test	 cl, cl
  00085	75 f9		 jne	 SHORT $L90551
  00087	8b 6c 24 2c	 mov	 ebp, DWORD PTR _y$[esp+32]
  0008b	8b 7c 24 28	 mov	 edi, DWORD PTR _x$[esp+32]
  0008f	8d 4c 24 10	 lea	 ecx, DWORD PTR _use_pi$[esp+36]
  00093	51		 push	 ecx
  00094	2b c2		 sub	 eax, edx
  00096	50		 push	 eax
  00097	56		 push	 esi
  00098	8d 57 ff	 lea	 edx, DWORD PTR [edi-1]
  0009b	55		 push	 ebp
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 ?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z ; g_PrintLen

; 701  : 	g_Print(x+1, y, sz_str, &use_pi);

  000a2	8b c6		 mov	 eax, esi
  000a4	83 c4 14	 add	 esp, 20			; 00000014H
  000a7	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  000aa	8d 9b 00 00 00
	00		 npad	 6
$L90552:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	40		 inc	 eax
  000b3	84 d2		 test	 dl, dl
  000b5	75 f9		 jne	 SHORT $L90552
  000b7	2b c1		 sub	 eax, ecx
  000b9	8d 4c 24 10	 lea	 ecx, DWORD PTR _use_pi$[esp+36]
  000bd	51		 push	 ecx
  000be	50		 push	 eax
  000bf	56		 push	 esi
  000c0	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
  000c3	55		 push	 ebp
  000c4	52		 push	 edx
  000c5	e8 00 00 00 00	 call	 ?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z ; g_PrintLen

; 702  : 	g_Print(x, y-1, sz_str, &use_pi);

  000ca	8b c6		 mov	 eax, esi
  000cc	83 c4 14	 add	 esp, 20			; 00000014H
  000cf	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$L90553:
  000d2	8a 10		 mov	 dl, BYTE PTR [eax]
  000d4	40		 inc	 eax
  000d5	84 d2		 test	 dl, dl
  000d7	75 f9		 jne	 SHORT $L90553
  000d9	2b c1		 sub	 eax, ecx
  000db	8d 4c 24 10	 lea	 ecx, DWORD PTR _use_pi$[esp+36]
  000df	51		 push	 ecx
  000e0	50		 push	 eax
  000e1	56		 push	 esi
  000e2	8d 55 ff	 lea	 edx, DWORD PTR [ebp-1]
  000e5	52		 push	 edx
  000e6	57		 push	 edi
  000e7	e8 00 00 00 00	 call	 ?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z ; g_PrintLen

; 703  : 	g_Print(x, y+1, sz_str, &use_pi);

  000ec	8b c6		 mov	 eax, esi
  000ee	83 c4 14	 add	 esp, 20			; 00000014H
  000f1	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$L90554:
  000f4	8a 10		 mov	 dl, BYTE PTR [eax]
  000f6	40		 inc	 eax
  000f7	84 d2		 test	 dl, dl
  000f9	75 f9		 jne	 SHORT $L90554
  000fb	2b c1		 sub	 eax, ecx
  000fd	8d 4c 24 10	 lea	 ecx, DWORD PTR _use_pi$[esp+36]
  00101	51		 push	 ecx
  00102	50		 push	 eax
  00103	56		 push	 esi
  00104	8d 55 01	 lea	 edx, DWORD PTR [ebp+1]
  00107	52		 push	 edx
  00108	57		 push	 edi
  00109	e8 00 00 00 00	 call	 ?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z ; g_PrintLen

; 704  : 
; 705  : 	use_pi.text_color = str_rgb;

  0010e	8b 44 24 4c	 mov	 eax, DWORD PTR _str_rgb$[esp+52]
  00112	89 44 24 28	 mov	 DWORD PTR _use_pi$[esp+60], eax

; 706  : 	g_Print(x, y, sz_str, &use_pi);

  00116	8b c6		 mov	 eax, esi
  00118	83 c4 14	 add	 esp, 20			; 00000014H
  0011b	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0011e	8b ff		 npad	 2
$L90555:
  00120	8a 10		 mov	 dl, BYTE PTR [eax]
  00122	40		 inc	 eax
  00123	84 d2		 test	 dl, dl
  00125	75 f9		 jne	 SHORT $L90555
  00127	2b c1		 sub	 eax, ecx
  00129	8d 4c 24 10	 lea	 ecx, DWORD PTR _use_pi$[esp+36]
  0012d	51		 push	 ecx
  0012e	50		 push	 eax
  0012f	56		 push	 esi
  00130	55		 push	 ebp
  00131	57		 push	 edi
  00132	e8 00 00 00 00	 call	 ?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z ; g_PrintLen

; 707  : 	
; 708  : 	int re = (x+g_GetStringWidth(sz_str, use_pi.hfont));

  00137	8b 54 24 24	 mov	 edx, DWORD PTR _use_pi$[esp+56]
  0013b	52		 push	 edx
  0013c	56		 push	 esi
  0013d	e8 00 00 00 00	 call	 ?g_GetStringWidth@@YAHPBDPAUHFONT__@@@Z ; g_GetStringWidth
  00142	8b f0		 mov	 esi, eax
  00144	83 c4 1c	 add	 esp, 28			; 0000001cH
  00147	03 f7		 add	 esi, edi

; 709  : 
; 710  : 	if(bGetDC)

  00149	84 db		 test	 bl, bl
  0014b	74 05		 je	 SHORT $L90556

; 711  : 		g_FL2_ReleaseDC();

  0014d	e8 00 00 00 00	 call	 ?g_FL2_ReleaseDC@@YA_NXZ ; g_FL2_ReleaseDC
$L90556:
  00152	5f		 pop	 edi

; 712  : 
; 713  : 	return re;

  00153	8b c6		 mov	 eax, esi
  00155	5e		 pop	 esi
  00156	5d		 pop	 ebp
  00157	5b		 pop	 ebx

; 714  : }

  00158	83 c4 14	 add	 esp, 20			; 00000014H
  0015b	c3		 ret	 0
?g_PrintColorStrOut@@YAHHHPBDAAUPrintInfo@@KK@Z ENDP	; g_PrintColorStrOut
_TEXT	ENDS
PUBLIC	?g_PrintColorStrShadow@@YAHHHPBDAAUPrintInfo@@KK@Z ; g_PrintColorStrShadow
; Function compile flags: /Ogty
;	COMDAT ?g_PrintColorStrShadow@@YAHHHPBDAAUPrintInfo@@KK@Z
_TEXT	SEGMENT
_use_pi$ = -20						; size = 20
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sz_str$ = 16						; size = 4
_bGetDC$ = 20						; size = 1
_pi$ = 20						; size = 4
_str_rgb$ = 24						; size = 4
_shadow_rgb$ = 28					; size = 4
?g_PrintColorStrShadow@@YAHHHPBDAAUPrintInfo@@KK@Z PROC NEAR ; g_PrintColorStrShadow, COMDAT

; 722  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H

; 723  : 	assert(!gpC_base->m_p_DDSurface_back->IsLock());
; 724  : 	PrintInfo use_pi = pi;

  00003	8b 44 24 24	 mov	 eax, DWORD PTR _pi$[esp+16]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0000c	53		 push	 ebx

; 725  : 
; 726  : 	if(shadow_rgb == 0xFFFFFFFF)

  0000d	8b 5c 24 2c	 mov	 ebx, DWORD PTR _str_rgb$[esp+20]
  00011	55		 push	 ebp
  00012	89 4c 24 08	 mov	 DWORD PTR _use_pi$[esp+28], ecx
  00016	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00019	56		 push	 esi
  0001a	8b 74 24 38	 mov	 esi, DWORD PTR _shadow_rgb$[esp+28]
  0001e	83 fe ff	 cmp	 esi, -1
  00021	89 54 24 10	 mov	 DWORD PTR _use_pi$[esp+36], edx
  00025	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00028	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0002b	57		 push	 edi
  0002c	89 4c 24 18	 mov	 DWORD PTR _use_pi$[esp+44], ecx
  00030	89 54 24 1c	 mov	 DWORD PTR _use_pi$[esp+48], edx
  00034	89 44 24 20	 mov	 DWORD PTR _use_pi$[esp+52], eax
  00038	75 22		 jne	 SHORT $L88748

; 747  : 
; 748  : 	return re;

  0003a	8b f3		 mov	 esi, ebx
  0003c	c1 fe 02	 sar	 esi, 2
  0003f	83 e6 3f	 and	 esi, 63			; 0000003fH
  00042	8b cb		 mov	 ecx, ebx
  00044	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  00047	c1 e6 08	 shl	 esi, 8
  0004a	83 e1 3f	 and	 ecx, 63			; 0000003fH
  0004d	8b d3		 mov	 edx, ebx
  0004f	0b f1		 or	 esi, ecx
  00051	c1 ea 12	 shr	 edx, 18			; 00000012H
  00054	c1 e6 08	 shl	 esi, 8
  00057	83 e2 3f	 and	 edx, 63			; 0000003fH
  0005a	0b f2		 or	 esi, edx
$L88748:
  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  00061	85 c0		 test	 eax, eax
  00063	75 1a		 jne	 SHORT $L90563
  00065	68 14 02 00 00	 push	 532			; 00000214H
  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@MPNGGJFM@?2darkeden?2Designed_Common?2Projec@
  0006f	50		 push	 eax
  00070	6a 05		 push	 5
  00072	e8 00 00 00 00	 call	 ?g_BasicException@@YAXW4EXCEPTION_CODE@@PAD1K@Z ; g_BasicException
  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpC_fl2_surface@@3PAUIDirectDrawSurface7@@A ; gpC_fl2_surface
  0007c	83 c4 10	 add	 esp, 16			; 00000010H
$L90563:
  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00085	85 c9		 test	 ecx, ecx
  00087	75 12		 jne	 SHORT $L90564
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  00090	50		 push	 eax
  00091	ff 51 44	 call	 DWORD PTR [ecx+68]
  00094	c6 44 24 34 01	 mov	 BYTE PTR _bGetDC$[esp+32], 1
  00099	eb 05		 jmp	 SHORT $L90562

; 727  : 	{
; 728  : 		int r = (str_rgb&0xFF0000) >> 16;
; 729  : 		int g = (str_rgb&0xFF00) >> 8;
; 730  : 		int b = str_rgb&0xFF;
; 731  : //		shadow_rgb = RGB(max(0, r-150), max(0, g-150), max(0, b-150));
; 732  : 		shadow_rgb = RGB(r>>2, g>>2, b>>2);
; 733  : 	}
; 734  : 
; 735  : 	bool bGetDC = g_FL2_GetDC();

$L90564:
  0009b	c6 44 24 34 00	 mov	 BYTE PTR _bGetDC$[esp+32], 0
$L90562:

; 736  : 
; 737  : 	use_pi.text_color = shadow_rgb;

  000a0	89 74 24 14	 mov	 DWORD PTR _use_pi$[esp+40], esi

; 738  : 	g_Print(x+1, y+1, sz_str, &use_pi);

  000a4	8b 74 24 30	 mov	 esi, DWORD PTR _sz_str$[esp+32]
  000a8	8b c6		 mov	 eax, esi
  000aa	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  000ad	8d 49 00	 npad	 3
$L90571:
  000b0	8a 08		 mov	 cl, BYTE PTR [eax]
  000b2	40		 inc	 eax
  000b3	84 c9		 test	 cl, cl
  000b5	75 f9		 jne	 SHORT $L90571
  000b7	8b 6c 24 2c	 mov	 ebp, DWORD PTR _y$[esp+32]
  000bb	8b 7c 24 28	 mov	 edi, DWORD PTR _x$[esp+32]
  000bf	2b c2		 sub	 eax, edx
  000c1	8d 54 24 10	 lea	 edx, DWORD PTR _use_pi$[esp+36]
  000c5	52		 push	 edx
  000c6	50		 push	 eax
  000c7	56		 push	 esi
  000c8	8d 45 01	 lea	 eax, DWORD PTR [ebp+1]
  000cb	50		 push	 eax
  000cc	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  000cf	51		 push	 ecx
  000d0	e8 00 00 00 00	 call	 ?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z ; g_PrintLen

; 739  : 
; 740  : 	use_pi.text_color = str_rgb;
; 741  : 	g_Print(x, y, sz_str, &use_pi);

  000d5	8b c6		 mov	 eax, esi
  000d7	83 c4 14	 add	 esp, 20			; 00000014H
  000da	89 5c 24 14	 mov	 DWORD PTR _use_pi$[esp+40], ebx
  000de	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$L90572:
  000e1	8a 10		 mov	 dl, BYTE PTR [eax]
  000e3	40		 inc	 eax
  000e4	84 d2		 test	 dl, dl
  000e6	75 f9		 jne	 SHORT $L90572
  000e8	8d 54 24 10	 lea	 edx, DWORD PTR _use_pi$[esp+36]
  000ec	52		 push	 edx
  000ed	2b c1		 sub	 eax, ecx
  000ef	50		 push	 eax
  000f0	56		 push	 esi
  000f1	55		 push	 ebp
  000f2	57		 push	 edi
  000f3	e8 00 00 00 00	 call	 ?g_PrintLen@@YAXHHPBDHPAUPrintInfo@@@Z ; g_PrintLen

; 742  : 	
; 743  : 	int re = (x+g_GetStringWidth(sz_str, use_pi.hfont));

  000f8	8b 44 24 24	 mov	 eax, DWORD PTR _use_pi$[esp+56]
  000fc	50		 push	 eax
  000fd	56		 push	 esi
  000fe	e8 00 00 00 00	 call	 ?g_GetStringWidth@@YAHPBDPAUHFONT__@@@Z ; g_GetStringWidth
  00103	8b f0		 mov	 esi, eax

; 744  : 
; 745  : 	if(bGetDC)

  00105	8a 44 24 50	 mov	 al, BYTE PTR _bGetDC$[esp+60]
  00109	83 c4 1c	 add	 esp, 28			; 0000001cH
  0010c	03 f7		 add	 esi, edi
  0010e	84 c0		 test	 al, al
  00110	74 05		 je	 SHORT $L90573

; 746  : 		g_FL2_ReleaseDC();

  00112	e8 00 00 00 00	 call	 ?g_FL2_ReleaseDC@@YA_NXZ ; g_FL2_ReleaseDC
$L90573:
  00117	5f		 pop	 edi

; 747  : 
; 748  : 	return re;

  00118	8b c6		 mov	 eax, esi
  0011a	5e		 pop	 esi
  0011b	5d		 pop	 ebp
  0011c	5b		 pop	 ebx

; 749  : }

  0011d	83 c4 14	 add	 esp, 20			; 00000014H
  00120	c3		 ret	 0
?g_PrintColorStrShadow@@YAHHHPBDAAUPrintInfo@@KK@Z ENDP	; g_PrintColorStrShadow
_TEXT	ENDS
PUBLIC	?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ ; _STL::_String_base<char,_STL::allocator<char> >::_M_deallocate_block
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ
_TEXT	SEGMENT
?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ PROC NEAR ; _STL::_String_base<char,_STL::allocator<char> >::_M_deallocate_block, COMDAT
; _this$ = ecx

; 124  :     { _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start); }

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00005	2b c2		 sub	 eax, edx
  00007	85 d2		 test	 edx, edx
  00009	74 1b		 je	 SHORT $L90594
  0000b	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00010	76 0a		 jbe	 SHORT $L90593
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
  0001b	c3		 ret	 0
$L90593:
  0001c	50		 push	 eax
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z ; _STL::__node_alloc<1,0>::_M_deallocate
  00023	83 c4 08	 add	 esp, 8
$L90594:
  00026	c3		 ret	 0
?_M_deallocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXXZ ENDP ; _STL::_String_base<char,_STL::allocator<char> >::_M_deallocate_block
_TEXT	ENDS
PUBLIC	??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_range_initialize<char const *>
; Function compile flags: /Ogty
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT
___f$ = 8						; size = 4
___l$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_range_initialize<char const *>, COMDAT
; _this$ = ecx

; 382  :   template <class _ForwardIter> void _M_range_initialize(_ForwardIter __f, _ForwardIter __l, 

  00000	53		 push	 ebx

; 383  :                            const forward_iterator_tag &) {
; 384  :     difference_type __n = distance(__f, __l);
; 385  :     this->_M_allocate_block(__n + 1);
; 386  :     this->_M_finish = uninitialized_copy(__f, __l, this->_M_start);
; 387  :     _M_terminate_string();

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR ___f$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR ___l$[esp+4]
  0000a	56		 push	 esi
  0000b	8b f5		 mov	 esi, ebp
  0000d	57		 push	 edi
  0000e	2b f3		 sub	 esi, ebx
  00010	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00013	50		 push	 eax
  00014	8b f9		 mov	 edi, ecx
  00016	e8 00 00 00 00	 call	 ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z ; _STL::_String_base<char,_STL::allocator<char> >::_M_allocate_block
  0001b	3b eb		 cmp	 ebp, ebx
  0001d	8b 07		 mov	 eax, DWORD PTR [edi]
  0001f	74 0d		 je	 SHORT $L90639
  00021	56		 push	 esi
  00022	53		 push	 ebx
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	03 c6		 add	 eax, esi
$L90639:
  0002e	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c6 00 00	 mov	 BYTE PTR [eax], 0
  00037	5b		 pop	 ebx

; 388  :   }

  00038	c2 0c 00	 ret	 12			; 0000000cH
??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0ABUforward_iterator_tag@1@@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_range_initialize<char const *>
_TEXT	ENDS
PUBLIC	??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z ; _STL::__uninitialized_copy<char *,char *>
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_uninitialized.h
;	COMDAT ??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
___result$ = 16						; size = 4
___formal$ = 20						; size = 4
??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z PROC NEAR ; _STL::__uninitialized_copy<char *,char *>, COMDAT

; 55   :   return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter> :: _Ret());

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___first$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR ___last$[esp]
  00009	3b f0		 cmp	 esi, eax
  0000b	75 06		 jne	 SHORT $L90689
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR ___result$[esp]
  00011	5e		 pop	 esi

; 56   : }

  00012	c3		 ret	 0

; 55   :   return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter> :: _Ret());

$L90689:
  00013	2b f0		 sub	 esi, eax
  00015	56		 push	 esi
  00016	50		 push	 eax
  00017	8b 44 24 18	 mov	 eax, DWORD PTR ___result$[esp+8]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 56   : }

  00027	c3		 ret	 0
??$__uninitialized_copy@PADPAD@_STL@@YAPADPAD00ABU__true_type@0@@Z ENDP ; _STL::__uninitialized_copy<char *,char *>
_TEXT	ENDS
PUBLIC	??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ ; _STL::_String_base<char,_STL::allocator<char> >::~_String_base<char,_STL::allocator<char> >
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ PROC NEAR ; _STL::_String_base<char,_STL::allocator<char> >::~_String_base<char,_STL::allocator<char> >, COMDAT
; _this$ = ecx

; 135  :   ~_String_base() { _M_deallocate_block(); }

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00005	2b c2		 sub	 eax, edx
  00007	85 d2		 test	 edx, edx
  00009	74 1b		 je	 SHORT $L90725
  0000b	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00010	76 0a		 jbe	 SHORT $L90724
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
  0001b	c3		 ret	 0
$L90724:
  0001c	50		 push	 eax
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z ; _STL::__node_alloc<1,0>::_M_deallocate
  00023	83 c4 08	 add	 esp, 8
$L90725:
  00026	c3		 ret	 0
??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ ENDP ; _STL::_String_base<char,_STL::allocator<char> >::~_String_base<char,_STL::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_range_initialize<char const *>
; Function compile flags: /Ogty
;	COMDAT ??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z
_TEXT	SEGMENT
___f$ = 8						; size = 4
___l$ = 12						; size = 4
??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_range_initialize<char const *>, COMDAT
; _this$ = ecx

; 390  :   template <class _InputIter> void _M_range_initialize(_InputIter __f, _InputIter __l) {

  00000	53		 push	 ebx

; 391  :     _M_range_initialize(__f, __l, _STLP_ITERATOR_CATEGORY(__f, _InputIter));

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR ___f$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR ___l$[esp+4]
  0000a	56		 push	 esi
  0000b	8b f5		 mov	 esi, ebp
  0000d	57		 push	 edi
  0000e	2b f3		 sub	 esi, ebx
  00010	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00013	50		 push	 eax
  00014	8b f9		 mov	 edi, ecx
  00016	e8 00 00 00 00	 call	 ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z ; _STL::_String_base<char,_STL::allocator<char> >::_M_allocate_block
  0001b	3b eb		 cmp	 ebp, ebx
  0001d	8b 07		 mov	 eax, DWORD PTR [edi]
  0001f	74 0d		 je	 SHORT $L90792
  00021	56		 push	 esi
  00022	53		 push	 ebx
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	03 c6		 add	 eax, esi
$L90792:
  0002e	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c6 00 00	 mov	 BYTE PTR [eax], 0
  00037	5b		 pop	 ebx

; 392  :   }

  00038	c2 08 00	 ret	 8
??$_M_range_initialize@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPBD0@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_range_initialize<char const *>
_TEXT	ENDS
PUBLIC	??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z	; _STL::uninitialized_copy<char *,char *>
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_uninitialized.h
;	COMDAT ??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
___last$ = 12						; size = 4
___result$ = 16						; size = 4
??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z PROC NEAR ; _STL::uninitialized_copy<char *,char *>, COMDAT

; 79   :   return __uninitialized_copy(__first, __last, __result,  _IS_POD_ITER(__result, _ForwardIter));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___first$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR ___last$[esp]
  00009	3b f0		 cmp	 esi, eax
  0000b	75 06		 jne	 SHORT $L90867
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR ___result$[esp]
  00011	5e		 pop	 esi

; 80   : }

  00012	c3		 ret	 0

; 79   :   return __uninitialized_copy(__first, __last, __result,  _IS_POD_ITER(__result, _ForwardIter));

$L90867:
  00013	2b f0		 sub	 esi, eax
  00015	56		 push	 esi
  00016	50		 push	 eax
  00017	8b 44 24 18	 mov	 eax, DWORD PTR ___result$[esp+8]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 80   : }

  00027	c3		 ret	 0
??$uninitialized_copy@PADPAD@_STL@@YAPADPAD00@Z ENDP	; _STL::uninitialized_copy<char *,char *>
_TEXT	ENDS
PUBLIC	??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@PBDABV?$allocator@D@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\stlport-4.6.1\stlport\stl\_string.h
xdata$x	SEGMENT
$T90975	DD	0ffffffffH
	DD	FLAT:$L90872
$T90971	DD	019930520H
	DD	01H
	DD	FLAT:$T90975
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.c
xdata$x	ENDS
;	COMDAT ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@PBDABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___s$ = 8						; size = 4
___a$ = 12						; size = 4
??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@PBDABV?$allocator@D@1@@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >, COMDAT
; _this$ = ecx

; 552  : { 

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@PBDABV?$allocator@D@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	55		 push	 ebp
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx
  0001a	33 c0		 xor	 eax, eax
  0001c	89 06		 mov	 DWORD PTR [esi], eax
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	57		 push	 edi
  00022	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00026	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 553  :   _STLP_FIX_LITERAL_BUG(__s) 
; 554  :     _M_range_initialize(__s, __s + traits_type::length(__s));  

  00029	8b 6c 24 20	 mov	 ebp, DWORD PTR ___s$[esp+24]
  0002d	89 44 24 18	 mov	 DWORD PTR __$EHRec$[esp+36], eax
  00031	8b c5		 mov	 eax, ebp
  00033	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L90972:
  00036	8a 08		 mov	 cl, BYTE PTR [eax]
  00038	40		 inc	 eax
  00039	84 c9		 test	 cl, cl
  0003b	75 f9		 jne	 SHORT $L90972
  0003d	2b c2		 sub	 eax, edx
  0003f	53		 push	 ebx
  00040	8d 1c 28	 lea	 ebx, DWORD PTR [eax+ebp]

; 555  : } 

  00043	8b fb		 mov	 edi, ebx
  00045	2b fd		 sub	 edi, ebp
  00047	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0004a	50		 push	 eax
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z ; _STL::_String_base<char,_STL::allocator<char> >::_M_allocate_block
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	3b dd		 cmp	 ebx, ebp
  00056	5b		 pop	 ebx
  00057	74 0d		 je	 SHORT $L90962
  00059	57		 push	 edi
  0005a	55		 push	 ebp
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _memmove
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	03 c7		 add	 eax, edi
$L90962:
  00066	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  0006a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0006d	c6 00 00	 mov	 BYTE PTR [eax], 0
  00070	5f		 pop	 edi
  00071	8b c6		 mov	 eax, esi
  00073	5e		 pop	 esi
  00074	5d		 pop	 ebp
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007c	83 c4 10	 add	 esp, 16			; 00000010H
  0007f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L90872:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ ; _STL::_String_base<char,_STL::allocator<char> >::~_String_base<char,_STL::allocator<char> >
__ehhandler$??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@PBDABV?$allocator@D@1@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T90971
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@PBDABV?$allocator@D@1@@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
PUBLIC	??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
;	COMDAT xdata$x
; File c:\stlport-4.6.1\stlport\stl\_string.h
xdata$x	SEGMENT
$T91037	DD	0ffffffffH
	DD	FLAT:$L90983
$T91035	DD	019930520H
	DD	01H
	DD	FLAT:$T91037
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.c
xdata$x	ENDS
;	COMDAT ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >, COMDAT
; _this$ = ecx

; 541  :   : _String_base<_CharT,_Alloc>(allocator_type()) {  

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0001f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00026	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0002a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 542  :   this->_M_start = this->_M_end_of_storage.allocate(8); 

  00031	6a 08		 push	 8
  00033	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  0003b	e8 00 00 00 00	 call	 ?_M_allocate@?$__node_alloc@$00$0A@@_STL@@CAPAXI@Z ; _STL::__node_alloc<1,0>::_M_allocate

; 543  :   this->_M_finish = this->_M_start; 
; 544  :   this->_M_end_of_storage._M_data = this->_M_start + 8; 

  00040	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00043	89 06		 mov	 DWORD PTR [esi], eax
  00045	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00048	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 545  :   _M_terminate_string();  
; 546  : } 

  0004b	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0004f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00052	83 c4 04	 add	 esp, 4
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L90983:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ ; _STL::_String_base<char,_STL::allocator<char> >::~_String_base<char,_STL::allocator<char> >
__ehhandler$??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T91035
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
PUBLIC	??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >, COMDAT
; _this$ = ecx

; 305  :   ~basic_string() { _STLP_STD::_Destroy(this->_M_start, this->_M_finish + 1); }

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00005	2b c2		 sub	 eax, edx
  00007	85 d2		 test	 edx, edx
  00009	74 1b		 je	 SHORT $L91091
  0000b	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00010	76 0a		 jbe	 SHORT $L91090
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
  0001b	c3		 ret	 0
$L91090:
  0001c	50		 push	 eax
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z ; _STL::__node_alloc<1,0>::_M_deallocate
  00023	83 c4 08	 add	 esp, 8
$L91091:
  00026	c3		 ret	 0
??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_range_initialize<char *>
; Function compile flags: /Ogty
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT
___f$ = 8						; size = 4
___l$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_range_initialize<char *>, COMDAT
; _this$ = ecx

; 382  :   template <class _ForwardIter> void _M_range_initialize(_ForwardIter __f, _ForwardIter __l, 

  00000	53		 push	 ebx

; 383  :                            const forward_iterator_tag &) {
; 384  :     difference_type __n = distance(__f, __l);
; 385  :     this->_M_allocate_block(__n + 1);
; 386  :     this->_M_finish = uninitialized_copy(__f, __l, this->_M_start);
; 387  :     _M_terminate_string();

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR ___f$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR ___l$[esp+4]
  0000a	56		 push	 esi
  0000b	8b f5		 mov	 esi, ebp
  0000d	57		 push	 edi
  0000e	2b f3		 sub	 esi, ebx
  00010	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00013	50		 push	 eax
  00014	8b f9		 mov	 edi, ecx
  00016	e8 00 00 00 00	 call	 ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z ; _STL::_String_base<char,_STL::allocator<char> >::_M_allocate_block
  0001b	3b eb		 cmp	 ebp, ebx
  0001d	8b 07		 mov	 eax, DWORD PTR [edi]
  0001f	74 0d		 je	 SHORT $L91220
  00021	56		 push	 esi
  00022	53		 push	 ebx
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	03 c6		 add	 eax, esi
$L91220:
  0002e	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c6 00 00	 mov	 BYTE PTR [eax], 0
  00037	5b		 pop	 ebx

; 388  :   }

  00038	c2 0c 00	 ret	 12			; 0000000cH
??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0ABUforward_iterator_tag@1@@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_range_initialize<char *>
_TEXT	ENDS
PUBLIC	??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert<char const *>
EXTRN	__CxxThrowException@8:NEAR
; Function compile flags: /Ogty
;	COMDAT ??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT
___len$89456 = -4					; size = 4
___old_size$89455 = -4					; size = 4
___position$ = 8					; size = 4
___first$ = 12						; size = 4
___new_start$89464 = 16					; size = 4
$T91225 = 16						; size = 4
___mid$89446 = 16					; size = 4
___last$ = 16						; size = 4
___formal$ = 20						; size = 4
??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABUforward_iterator_tag@1@@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert<char const *>, COMDAT
; _this$ = ecx

; 757  :   void insert(iterator __position, _ForwardIter __first, _ForwardIter __last, 

  00000	51		 push	 ecx

; 758  : 	      const forward_iterator_tag &)  {
; 759  :     if (__first != __last) {

  00001	8b 54 24 10	 mov	 edx, DWORD PTR ___last$[esp]
  00005	8b 44 24 0c	 mov	 eax, DWORD PTR ___first$[esp]
  00009	3b c2		 cmp	 eax, edx
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	0f 84 d8 01 00
	00		 je	 $L89454

; 760  :       difference_type __n = distance(__first, __last);
; 761  :       if (this->_M_end_of_storage._M_data - this->_M_finish >= __n + 1) {

  00014	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00017	53		 push	 ebx
  00018	55		 push	 ebp
  00019	57		 push	 edi
  0001a	8b fa		 mov	 edi, edx
  0001c	2b f8		 sub	 edi, eax
  0001e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00021	2b c8		 sub	 ecx, eax
  00023	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  00026	3b cb		 cmp	 ecx, ebx
  00028	0f 8c dd 00 00
	00		 jl	 $L89436

; 762  : 	const difference_type __elems_after = this->_M_finish - __position;

  0002e	8b 4c 24 18	 mov	 ecx, DWORD PTR ___position$[esp+16]

; 763  : 	pointer __old_finish = this->_M_finish;

  00032	8b 6e 04	 mov	 ebp, DWORD PTR [esi+4]
  00035	2b c1		 sub	 eax, ecx
  00037	8b d8		 mov	 ebx, eax

; 764  : 	if (__elems_after >= __n) {

  00039	3b df		 cmp	 ebx, edi
  0003b	7c 5b		 jl	 SHORT $L89439

; 765  : 	  uninitialized_copy((this->_M_finish - __n) + 1, this->_M_finish + 1,
; 766  : 			     this->_M_finish + 1);

  0003d	8d 45 01	 lea	 eax, DWORD PTR [ebp+1]
  00040	2b ef		 sub	 ebp, edi
  00042	45		 inc	 ebp
  00043	3b c5		 cmp	 eax, ebp
  00045	74 13		 je	 SHORT $L91334
  00047	8b d0		 mov	 edx, eax
  00049	2b d5		 sub	 edx, ebp
  0004b	52		 push	 edx
  0004c	55		 push	 ebp
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _memmove
  00053	8b 4c 24 24	 mov	 ecx, DWORD PTR ___position$[esp+28]
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
$L91334:

; 767  : 	  this->_M_finish += __n;

  0005a	8b 6e 04	 mov	 ebp, DWORD PTR [esi+4]
  0005d	03 ef		 add	 ebp, edi

; 768  : 	  _Traits::move(__position + __n,
; 769  : 			__position, (__elems_after - __n) + 1);

  0005f	2b df		 sub	 ebx, edi
  00061	43		 inc	 ebx
  00062	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  00065	74 12		 je	 SHORT $L91347
  00067	53		 push	 ebx
  00068	51		 push	 ecx
  00069	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _memmove
  00072	8b 4c 24 24	 mov	 ecx, DWORD PTR ___position$[esp+28]
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
$L91347:

; 770  : 	  _M_move(__first, __last, __position);

  00079	85 ff		 test	 edi, edi
  0007b	0f 84 68 01 00
	00		 je	 $L91822
  00081	8b 54 24 1c	 mov	 edx, DWORD PTR ___first$[esp+16]
  00085	57		 push	 edi
  00086	52		 push	 edx
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _memmove
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	5f		 pop	 edi
  00091	5d		 pop	 ebp
  00092	5b		 pop	 ebx
  00093	5e		 pop	 esi

; 806  : 	    }
; 807  :     }
; 808  :   }

  00094	59		 pop	 ecx
  00095	c2 10 00	 ret	 16			; 00000010H
$L89439:

; 771  : 	      }
; 772  : 	else {
; 773  : 	  _ForwardIter __mid = __first;
; 774  : 	  advance(__mid, __elems_after + 1);

  00098	8b 44 24 1c	 mov	 eax, DWORD PTR ___first$[esp+16]
  0009c	8d 44 03 01	 lea	 eax, DWORD PTR [ebx+eax+1]

; 775  : 	  uninitialized_copy(__mid, __last, this->_M_finish + 1);

  000a0	3b d0		 cmp	 edx, eax
  000a2	89 44 24 20	 mov	 DWORD PTR ___mid$89446[esp+16], eax
  000a6	74 18		 je	 SHORT $L91821
  000a8	2b d0		 sub	 edx, eax
  000aa	52		 push	 edx
  000ab	50		 push	 eax
  000ac	8d 4d 01	 lea	 ecx, DWORD PTR [ebp+1]
  000af	51		 push	 ecx
  000b0	e8 00 00 00 00	 call	 _memmove
  000b5	8b 44 24 2c	 mov	 eax, DWORD PTR ___mid$89446[esp+28]
  000b9	8b 4c 24 24	 mov	 ecx, DWORD PTR ___position$[esp+28]
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
$L91821:

; 776  : 	  this->_M_finish += __n - __elems_after;

  000c0	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000c3	2b fb		 sub	 edi, ebx
  000c5	03 d7		 add	 edx, edi

; 777  : 	        _STLP_TRY {
; 778  : 	          uninitialized_copy(__position, __old_finish + 1, this->_M_finish);

  000c7	45		 inc	 ebp
  000c8	3b e9		 cmp	 ebp, ecx
  000ca	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000cd	74 15		 je	 SHORT $L91489
  000cf	2b e9		 sub	 ebp, ecx
  000d1	55		 push	 ebp
  000d2	51		 push	 ecx
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 _memmove
  000d9	8b 44 24 2c	 mov	 eax, DWORD PTR ___mid$89446[esp+28]
  000dd	8b 4c 24 24	 mov	 ecx, DWORD PTR ___position$[esp+28]
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L91489:

; 779  : 	          this->_M_finish += __elems_after;

  000e4	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 780  : 	        }
; 781  : 	        _STLP_UNWIND((_STLP_STD::_Destroy(__old_finish + 1, this->_M_finish), 
; 782  : 	                      this->_M_finish = __old_finish));
; 783  : 	        _M_move(__first, __mid, __position);

  000e7	8b 54 24 1c	 mov	 edx, DWORD PTR ___first$[esp+16]
  000eb	03 fb		 add	 edi, ebx
  000ed	2b c2		 sub	 eax, edx
  000ef	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000f2	0f 84 f1 00 00
	00		 je	 $L91822
  000f8	50		 push	 eax
  000f9	52		 push	 edx
  000fa	51		 push	 ecx
  000fb	e8 00 00 00 00	 call	 _memmove
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH
  00103	5f		 pop	 edi
  00104	5d		 pop	 ebp
  00105	5b		 pop	 ebx
  00106	5e		 pop	 esi

; 806  : 	    }
; 807  :     }
; 808  :   }

  00107	59		 pop	 ecx
  00108	c2 10 00	 ret	 16			; 00000010H
$L89436:

; 784  : 	}
; 785  :       }
; 786  :       else {
; 787  : 	const size_type __old_size = size();        

  0010b	2b 06		 sub	 eax, DWORD PTR [esi]

; 788  : 	const size_type __len
; 789  : 	  = __old_size + (max)(__old_size, __STATIC_CAST(size_type,__n)) + 1;

  0010d	3b c7		 cmp	 eax, edi
  0010f	89 44 24 10	 mov	 DWORD PTR ___old_size$89455[esp+20], eax
  00113	89 7c 24 20	 mov	 DWORD PTR $T91225[esp+16], edi
  00117	8d 4c 24 20	 lea	 ecx, DWORD PTR $T91225[esp+16]
  0011b	72 04		 jb	 SHORT $L91526
  0011d	8d 4c 24 10	 lea	 ecx, DWORD PTR ___old_size$89455[esp+20]
$L91526:
  00121	8b 11		 mov	 edx, DWORD PTR [ecx]
  00123	8d 44 02 01	 lea	 eax, DWORD PTR [edx+eax+1]

; 790  : 	      pointer __new_start = this->_M_end_of_storage.allocate(__len);

  00127	85 c0		 test	 eax, eax
  00129	89 44 24 10	 mov	 DWORD PTR ___len$89456[esp+20], eax
  0012d	74 24		 je	 SHORT $L91545
  0012f	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00134	50		 push	 eax
  00135	76 0e		 jbe	 SHORT $L91549
  00137	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0013c	83 c4 04	 add	 esp, 4
  0013f	89 44 24 20	 mov	 DWORD PTR ___new_start$89464[esp+16], eax
  00143	eb 16		 jmp	 SHORT $L91546
$L91549:
  00145	e8 00 00 00 00	 call	 ?_M_allocate@?$__node_alloc@$00$0A@@_STL@@CAPAXI@Z ; _STL::__node_alloc<1,0>::_M_allocate
  0014a	83 c4 04	 add	 esp, 4
  0014d	89 44 24 20	 mov	 DWORD PTR ___new_start$89464[esp+16], eax
  00151	eb 08		 jmp	 SHORT $L91546
$L91545:
  00153	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ___new_start$89464[esp+16], 0
$L91546:

; 791  : 	      pointer __new_finish = __new_start;
; 792  : 	      _STLP_TRY {
; 793  : 	        __new_finish = uninitialized_copy(this->_M_start, __position, __new_start);

  0015b	8b 06		 mov	 eax, DWORD PTR [esi]
  0015d	8b 6c 24 18	 mov	 ebp, DWORD PTR ___position$[esp+16]
  00161	3b e8		 cmp	 ebp, eax
  00163	75 06		 jne	 SHORT $L91647
  00165	8b 44 24 20	 mov	 eax, DWORD PTR ___new_start$89464[esp+16]
  00169	eb 15		 jmp	 SHORT $L91648
$L91647:
  0016b	8b dd		 mov	 ebx, ebp
  0016d	2b d8		 sub	 ebx, eax
  0016f	53		 push	 ebx
  00170	50		 push	 eax
  00171	8b 44 24 28	 mov	 eax, DWORD PTR ___new_start$89464[esp+24]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 _memmove
  0017b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017e	03 c3		 add	 eax, ebx
$L91648:

; 794  : 	        __new_finish = uninitialized_copy(__first, __last, __new_finish);

  00180	8b 4c 24 1c	 mov	 ecx, DWORD PTR ___first$[esp+16]
  00184	57		 push	 edi
  00185	51		 push	 ecx
  00186	50		 push	 eax
  00187	e8 00 00 00 00	 call	 _memmove
  0018c	8b d8		 mov	 ebx, eax

; 795  : 	        __new_finish
; 796  : 	          = uninitialized_copy(__position, this->_M_finish, __new_finish);

  0018e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00191	83 c4 0c	 add	 esp, 12			; 0000000cH
  00194	03 df		 add	 ebx, edi
  00196	3b c5		 cmp	 eax, ebp
  00198	74 13		 je	 SHORT $L91766
  0019a	8b f8		 mov	 edi, eax
  0019c	2b fd		 sub	 edi, ebp
  0019e	57		 push	 edi
  0019f	55		 push	 ebp
  001a0	53		 push	 ebx
  001a1	e8 00 00 00 00	 call	 _memmove
  001a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a9	03 c7		 add	 eax, edi
  001ab	8b d8		 mov	 ebx, eax
$L91766:

; 797  : 	        _M_construct_null(__new_finish);

  001ad	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 798  : 	      }
; 799  : 	      _STLP_UNWIND((_STLP_STD::_Destroy(__new_start,__new_finish),
; 800  : 	                    this->_M_end_of_storage.deallocate(__new_start,__len)));
; 801  : 	      _STLP_STD::_Destroy(this->_M_start, this->_M_finish + 1);
; 802  : 	      this->_M_deallocate_block();

  001b0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001b2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001b5	2b c1		 sub	 eax, ecx
  001b7	85 c9		 test	 ecx, ecx
  001b9	74 1c		 je	 SHORT $L91815
  001bb	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  001c0	76 0b		 jbe	 SHORT $L91814
  001c2	51		 push	 ecx
  001c3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001c8	83 c4 04	 add	 esp, 4
  001cb	eb 0a		 jmp	 SHORT $L91815
$L91814:
  001cd	50		 push	 eax
  001ce	51		 push	 ecx
  001cf	e8 00 00 00 00	 call	 ?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z ; _STL::__node_alloc<1,0>::_M_deallocate
  001d4	83 c4 08	 add	 esp, 8
$L91815:

; 803  : 	      this->_M_start = __new_start;

  001d7	8b 44 24 20	 mov	 eax, DWORD PTR ___new_start$89464[esp+16]

; 804  : 	      this->_M_finish = __new_finish;
; 805  : 	      this->_M_end_of_storage._M_data = __new_start + __len; 

  001db	8b 54 24 10	 mov	 edx, DWORD PTR ___len$89456[esp+20]
  001df	89 06		 mov	 DWORD PTR [esi], eax
  001e1	03 c2		 add	 eax, edx
  001e3	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  001e6	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L91822:
  001e9	5f		 pop	 edi
  001ea	5d		 pop	 ebp
  001eb	5b		 pop	 ebx
$L89454:
  001ec	5e		 pop	 esi

; 806  : 	    }
; 807  :     }
; 808  :   }

  001ed	59		 pop	 ecx
  001ee	c2 10 00	 ret	 16			; 00000010H
??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABUforward_iterator_tag@1@@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert<char const *>
_TEXT	ENDS
PUBLIC	??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>
; Function compile flags: /Ogty
;	COMDAT ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z
_TEXT	SEGMENT
___old_size$89470 = -4					; size = 4
___first$ = 8						; size = 4
$T91828 = 12						; size = 4
___len$89477 = 12					; size = 4
___last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>, COMDAT
; _this$ = ecx

; 542  :   template <class _ForwardIter> _Self& append(_ForwardIter __first, _ForwardIter __last, 

  00000	51		 push	 ecx

; 543  :                        const forward_iterator_tag &)  {
; 544  :     if (__first != __last) {

  00001	8b 44 24 08	 mov	 eax, DWORD PTR ___first$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR ___last$[esp+4]
  0000a	3b c5		 cmp	 eax, ebp
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx
  0000f	0f 84 3d 01 00
	00		 je	 $L92109

; 545  : 	    const size_type __old_size = size();

  00015	8b 16		 mov	 edx, DWORD PTR [esi]
  00017	53		 push	 ebx
  00018	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0001b	57		 push	 edi

; 546  : 	    difference_type __n = distance(__first, __last);

  0001c	8b fd		 mov	 edi, ebp
  0001e	2b da		 sub	 ebx, edx
  00020	2b f8		 sub	 edi, eax

; 547  : 	    if (__STATIC_CAST(size_type,__n) > max_size() || __old_size > max_size() - __STATIC_CAST(size_type,__n))

  00022	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00025	89 5c 24 10	 mov	 DWORD PTR ___old_size$89470[esp+20], ebx
  00029	77 0b		 ja	 SHORT $L89475
  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00030	2b c7		 sub	 eax, edi
  00032	3b d8		 cmp	 ebx, eax
  00034	76 0d		 jbe	 SHORT $L91863
$L89475:

; 548  : 	      this->_M_throw_length_error();

  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@GOPDCEEB@basic_string?$AA@
  0003b	e8 00 00 00 00	 call	 ?__stl_throw_length_error@_STL@@YAXPBD@Z ; _STL::__stl_throw_length_error
  00040	83 c4 04	 add	 esp, 4
$L91863:

; 549  : 	    if (__old_size + __n > capacity()) {

  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00048	49		 dec	 ecx
  00049	8d 14 1f	 lea	 edx, DWORD PTR [edi+ebx]
  0004c	3b d1		 cmp	 edx, ecx
  0004e	0f 86 c8 00 00
	00		 jbe	 $L89476

; 550  : 	      const size_type __len = __old_size +
; 551  : 	                            (max)(__old_size, __STATIC_CAST(size_type,__n)) + 1;

  00054	3b df		 cmp	 ebx, edi
  00056	89 7c 24 1c	 mov	 DWORD PTR $T91828[esp+16], edi
  0005a	8d 44 24 1c	 lea	 eax, DWORD PTR $T91828[esp+16]
  0005e	72 04		 jb	 SHORT $L91876
  00060	8d 44 24 10	 lea	 eax, DWORD PTR ___old_size$89470[esp+20]
$L91876:
  00064	8b 00		 mov	 eax, DWORD PTR [eax]
  00066	8d 5c 18 01	 lea	 ebx, DWORD PTR [eax+ebx+1]

; 552  : 	      pointer __new_start = this->_M_end_of_storage.allocate(__len);

  0006a	85 db		 test	 ebx, ebx
  0006c	89 5c 24 1c	 mov	 DWORD PTR ___len$89477[esp+16], ebx
  00070	74 21		 je	 SHORT $L91894
  00072	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  00078	53		 push	 ebx
  00079	76 0c		 jbe	 SHORT $L91898
  0007b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00080	83 c4 04	 add	 esp, 4
  00083	8b e8		 mov	 ebp, eax
  00085	eb 0e		 jmp	 SHORT $L91895
$L91898:
  00087	e8 00 00 00 00	 call	 ?_M_allocate@?$__node_alloc@$00$0A@@_STL@@CAPAXI@Z ; _STL::__node_alloc<1,0>::_M_allocate
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b e8		 mov	 ebp, eax
  00091	eb 02		 jmp	 SHORT $L91895
$L91894:
  00093	33 ed		 xor	 ebp, ebp
$L91895:

; 553  : 	      pointer __new_finish = __new_start;
; 554  : 	      _STLP_TRY {
; 555  : 	        __new_finish = uninitialized_copy(this->_M_start, this->_M_finish, __new_start);

  00095	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00098	8b 06		 mov	 eax, DWORD PTR [esi]
  0009a	3b d8		 cmp	 ebx, eax
  0009c	75 04		 jne	 SHORT $L91999
  0009e	8b c5		 mov	 eax, ebp
  000a0	eb 0f		 jmp	 SHORT $L92000
$L91999:
  000a2	2b d8		 sub	 ebx, eax
  000a4	53		 push	 ebx
  000a5	50		 push	 eax
  000a6	55		 push	 ebp
  000a7	e8 00 00 00 00	 call	 _memmove
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  000af	03 c3		 add	 eax, ebx
$L92000:

; 556  : 	        __new_finish = uninitialized_copy(__first, __last, __new_finish);

  000b1	8b 4c 24 18	 mov	 ecx, DWORD PTR ___first$[esp+16]
  000b5	57		 push	 edi
  000b6	51		 push	 ecx
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _memmove
  000bd	8b d8		 mov	 ebx, eax
  000bf	03 df		 add	 ebx, edi

; 557  : 	        _M_construct_null(__new_finish);

  000c1	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 558  : 	      }
; 559  : 	      _STLP_UNWIND((_STLP_STD::_Destroy(__new_start,__new_finish),
; 560  : 	                    this->_M_end_of_storage.deallocate(__new_start,__len)));
; 561  : 	      _STLP_STD::_Destroy(this->_M_start, this->_M_finish + 1);
; 562  : 	      this->_M_deallocate_block();

  000c4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000c6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cc	2b c1		 sub	 eax, ecx
  000ce	85 c9		 test	 ecx, ecx
  000d0	74 32		 je	 SHORT $L92065
  000d2	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000d7	76 21		 jbe	 SHORT $L92064
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 563  : 	      this->_M_start = __new_start;
; 564  : 	      this->_M_finish = __new_finish;
; 565  : 	      this->_M_end_of_storage._M_data = __new_start + __len; 

  000df	8b 54 24 20	 mov	 edx, DWORD PTR ___len$89477[esp+20]
  000e3	83 c4 04	 add	 esp, 4
  000e6	89 2e		 mov	 DWORD PTR [esi], ebp
  000e8	5f		 pop	 edi
  000e9	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  000ec	03 ea		 add	 ebp, edx
  000ee	5b		 pop	 ebx
  000ef	89 6e 08	 mov	 DWORD PTR [esi+8], ebp

; 577  : 	    }
; 578  : 	  }
; 579  : 	  return *this;  

  000f2	8b c6		 mov	 eax, esi
  000f4	5e		 pop	 esi
  000f5	5d		 pop	 ebp

; 580  : 	}

  000f6	59		 pop	 ecx
  000f7	c2 0c 00	 ret	 12			; 0000000cH

; 558  : 	      }
; 559  : 	      _STLP_UNWIND((_STLP_STD::_Destroy(__new_start,__new_finish),
; 560  : 	                    this->_M_end_of_storage.deallocate(__new_start,__len)));
; 561  : 	      _STLP_STD::_Destroy(this->_M_start, this->_M_finish + 1);
; 562  : 	      this->_M_deallocate_block();

$L92064:
  000fa	50		 push	 eax
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z ; _STL::__node_alloc<1,0>::_M_deallocate
  00101	83 c4 08	 add	 esp, 8
$L92065:

; 563  : 	      this->_M_start = __new_start;
; 564  : 	      this->_M_finish = __new_finish;
; 565  : 	      this->_M_end_of_storage._M_data = __new_start + __len; 

  00104	8b 54 24 1c	 mov	 edx, DWORD PTR ___len$89477[esp+16]
  00108	89 2e		 mov	 DWORD PTR [esi], ebp
  0010a	5f		 pop	 edi
  0010b	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0010e	03 ea		 add	 ebp, edx
  00110	5b		 pop	 ebx
  00111	89 6e 08	 mov	 DWORD PTR [esi+8], ebp

; 577  : 	    }
; 578  : 	  }
; 579  : 	  return *this;  

  00114	8b c6		 mov	 eax, esi
  00116	5e		 pop	 esi
  00117	5d		 pop	 ebp

; 580  : 	}

  00118	59		 pop	 ecx
  00119	c2 0c 00	 ret	 12			; 0000000cH
$L89476:

; 566  : 	    }
; 567  : 	    else {
; 568  : 	      _ForwardIter __f1 = __first;
; 569  : 	      ++__f1;

  0011c	8b 44 24 18	 mov	 eax, DWORD PTR ___first$[esp+16]
  00120	40		 inc	 eax

; 570  : 	      uninitialized_copy(__f1, __last, this->_M_finish + 1);

  00121	3b e8		 cmp	 ebp, eax
  00123	74 11		 je	 SHORT $L92082
  00125	2b e8		 sub	 ebp, eax
  00127	55		 push	 ebp
  00128	50		 push	 eax
  00129	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0012c	40		 inc	 eax
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 _memmove
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH
$L92082:

; 571  : 	      _STLP_TRY {
; 572  : 	        _M_construct_null(this->_M_finish + __n);

  00136	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 573  : 	      }
; 574  : 	      _STLP_UNWIND(_STLP_STD::_Destroy(this->_M_finish + 1, this->_M_finish + __n));
; 575  : 	      _Traits::assign(*end(), *__first);

  00139	8b 44 24 18	 mov	 eax, DWORD PTR ___first$[esp+16]
  0013d	c6 04 0f 00	 mov	 BYTE PTR [edi+ecx], 0
  00141	8a 08		 mov	 cl, BYTE PTR [eax]
  00143	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00146	88 0a		 mov	 BYTE PTR [edx], cl

; 576  : 	      this->_M_finish += __n;

  00148	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0014b	03 c7		 add	 eax, edi
  0014d	5f		 pop	 edi
  0014e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00151	5b		 pop	 ebx
$L92109:

; 577  : 	    }
; 578  : 	  }
; 579  : 	  return *this;  

  00152	8b c6		 mov	 eax, esi
  00154	5e		 pop	 esi
  00155	5d		 pop	 ebp

; 580  : 	}

  00156	59		 pop	 ecx
  00157	c2 0c 00	 ret	 12			; 0000000cH
??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>
_TEXT	ENDS
PUBLIC	??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_range_initialize<char *>
; Function compile flags: /Ogty
;	COMDAT ??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z
_TEXT	SEGMENT
___f$ = 8						; size = 4
___l$ = 12						; size = 4
??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_range_initialize<char *>, COMDAT
; _this$ = ecx

; 390  :   template <class _InputIter> void _M_range_initialize(_InputIter __f, _InputIter __l) {

  00000	53		 push	 ebx

; 391  :     _M_range_initialize(__f, __l, _STLP_ITERATOR_CATEGORY(__f, _InputIter));

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR ___f$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR ___l$[esp+4]
  0000a	56		 push	 esi
  0000b	8b f5		 mov	 esi, ebp
  0000d	57		 push	 edi
  0000e	2b f3		 sub	 esi, ebx
  00010	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00013	50		 push	 eax
  00014	8b f9		 mov	 edi, ecx
  00016	e8 00 00 00 00	 call	 ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z ; _STL::_String_base<char,_STL::allocator<char> >::_M_allocate_block
  0001b	3b eb		 cmp	 ebp, ebx
  0001d	8b 07		 mov	 eax, DWORD PTR [edi]
  0001f	74 0d		 je	 SHORT $L92280
  00021	56		 push	 esi
  00022	53		 push	 ebx
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	03 c6		 add	 eax, esi
$L92280:
  0002e	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c6 00 00	 mov	 BYTE PTR [eax], 0
  00037	5b		 pop	 ebx

; 392  :   }

  00038	c2 08 00	 ret	 8
??$_M_range_initialize@PAD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPAD0@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_range_initialize<char *>
_TEXT	ENDS
PUBLIC	??$_M_insert_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABU__false_type@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_insert_dispatch<char const *>
; Function compile flags: /Ogty
;	COMDAT ??$_M_insert_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABU__false_type@1@@Z
_TEXT	SEGMENT
___p$ = 8						; size = 4
___first$ = 12						; size = 4
$T92284 = 16						; size = 1
___last$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_M_insert_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABU__false_type@1@@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_insert_dispatch<char const *>, COMDAT
; _this$ = ecx

; 816  :                           const __false_type&) {
; 817  :     insert(__p, __first, __last, _STLP_ITERATOR_CATEGORY(__first, _InputIter));

  00000	8d 44 24 0c	 lea	 eax, DWORD PTR $T92284[esp-4]
  00004	89 44 24 10	 mov	 DWORD PTR ___formal$[esp-4], eax
  00008	e9 00 00 00 00	 jmp	 ??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert<char const *>
??$_M_insert_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABU__false_type@1@@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_insert_dispatch<char const *>
_TEXT	ENDS
PUBLIC	??$_M_append_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABU__false_type@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_append_dispatch<char const *>
; Function compile flags: /Ogty
;	COMDAT ??$_M_append_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABU__false_type@1@@Z
_TEXT	SEGMENT
___f$ = 8						; size = 4
$T92288 = 12						; size = 1
___l$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_M_append_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABU__false_type@1@@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_append_dispatch<char const *>, COMDAT
; _this$ = ecx

; 587  :                                    const __false_type&) {
; 588  :     return append(__f, __l, _STLP_ITERATOR_CATEGORY(__f, _InputIter));

  00000	8d 44 24 08	 lea	 eax, DWORD PTR $T92288[esp-4]
  00004	89 44 24 0c	 mov	 DWORD PTR ___formal$[esp-4], eax
  00008	e9 00 00 00 00	 jmp	 ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>
??$_M_append_dispatch@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABU__false_type@1@@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::_M_append_dispatch<char const *>
_TEXT	ENDS
PUBLIC	??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@ABV01@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T92519	DD	0ffffffffH
	DD	FLAT:$L92294
$T92517	DD	019930520H
	DD	01H
	DD	FLAT:$T92519
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.c
xdata$x	ENDS
;	COMDAT ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___s$ = 8						; size = 4
??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@ABV01@@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >, COMDAT
; _this$ = ecx

; 560  : {  

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@ABV01@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	53		 push	 ebx
  00017	55		 push	 ebp
  00018	56		 push	 esi
  00019	8b f1		 mov	 esi, ecx
  0001b	33 c0		 xor	 eax, eax
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00022	57		 push	 edi
  00023	89 74 24 10	 mov	 DWORD PTR _this$[esp+32], esi
  00027	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002a	89 44 24 1c	 mov	 DWORD PTR __$EHRec$[esp+40], eax

; 561  :   _M_range_initialize(__s._M_start, __s._M_finish);  

  0002e	8b 44 24 24	 mov	 eax, DWORD PTR ___s$[esp+28]
  00032	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00035	8b 28		 mov	 ebp, DWORD PTR [eax]

; 562  : } 

  00037	8b fb		 mov	 edi, ebx
  00039	2b fd		 sub	 edi, ebp
  0003b	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_M_allocate_block@?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAEXI@Z ; _STL::_String_base<char,_STL::allocator<char> >::_M_allocate_block
  00044	3b dd		 cmp	 ebx, ebp
  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	74 0d		 je	 SHORT $L92502
  0004a	57		 push	 edi
  0004b	55		 push	 ebp
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _memmove
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	03 c7		 add	 eax, edi
$L92502:
  00057	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  0005b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0005e	5f		 pop	 edi
  0005f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00062	8b c6		 mov	 eax, esi
  00064	5e		 pop	 esi
  00065	5d		 pop	 ebp
  00066	5b		 pop	 ebx
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006e	83 c4 10	 add	 esp, 16			; 00000010H
  00071	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L92294:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_base@DV?$allocator@D@_STL@@@_STL@@QAE@XZ ; _STL::_String_base<char,_STL::allocator<char> >::~_String_base<char,_STL::allocator<char> >
__ehhandler$??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@ABV01@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T92517
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@ABV01@@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
PUBLIC	??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEXPADPBD1@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert<char const *>
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEXPADPBD1@Z
_TEXT	SEGMENT
___p$ = 8						; size = 4
___first$ = 12						; size = 4
$T92530 = 16						; size = 1
___last$ = 16						; size = 4
??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEXPADPBD1@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert<char const *>, COMDAT
; _this$ = ecx

; 733  :     typedef typename _Is_integer<_InputIter>::_Integral _Integral;
; 734  :     _M_insert_dispatch(__p, __first, __last, _Integral());

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR ___last$[esp-4]
  00004	8d 44 24 0c	 lea	 eax, DWORD PTR $T92530[esp-4]
  00008	50		 push	 eax
  00009	8b 44 24 0c	 mov	 eax, DWORD PTR ___first$[esp]
  0000d	52		 push	 edx
  0000e	8b 54 24 0c	 mov	 edx, DWORD PTR ___p$[esp+4]
  00012	50		 push	 eax
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 ??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert<char const *>

; 735  :   }

  00019	c2 0c 00	 ret	 12			; 0000000cH
??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEXPADPBD1@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert<char const *>
_TEXT	ENDS
PUBLIC	??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD0@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>
; Function compile flags: /Ogty
;	COMDAT ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD0@Z
_TEXT	SEGMENT
___first$ = 8						; size = 4
$T92539 = 12						; size = 1
___last$ = 12						; size = 4
??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD0@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>, COMDAT
; _this$ = ecx

; 507  :     typedef typename _Is_integer<_InputIter>::_Integral _Integral;
; 508  :     return _M_append_dispatch(__first, __last, _Integral());

  00000	8b 54 24 08	 mov	 edx, DWORD PTR ___last$[esp-4]
  00004	8d 44 24 08	 lea	 eax, DWORD PTR $T92539[esp-4]
  00008	50		 push	 eax
  00009	8b 44 24 08	 mov	 eax, DWORD PTR ___first$[esp]
  0000d	52		 push	 edx
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>

; 509  :   }

  00014	c2 08 00	 ret	 8
??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD0@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>
_TEXT	ENDS
PUBLIC	?insert@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@IPBD@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@IPBD@Z
_TEXT	SEGMENT
$T92578 = 8						; size = 1
___pos$ = 8						; size = 4
___s$ = 12						; size = 4
?insert@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@IPBD@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 696  :   _Self& insert(size_type __pos, const _CharT* __s) {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 697  :     _STLP_FIX_LITERAL_BUG(__s)
; 698  :     if (__pos > size())

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR ___pos$[esp+4]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	2b 06		 sub	 eax, DWORD PTR [esi]
  0000e	3b e8		 cmp	 ebp, eax
  00010	57		 push	 edi
  00011	76 0d		 jbe	 SHORT $L92547

; 699  :       this->_M_throw_out_of_range();

  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@GOPDCEEB@basic_string?$AA@
  00018	e8 00 00 00 00	 call	 ?__stl_throw_out_of_range@_STL@@YAXPBD@Z ; _STL::__stl_throw_out_of_range
  0001d	83 c4 04	 add	 esp, 4
$L92547:

; 700  :     size_type __len = _Traits::length(__s);

  00020	8b 5c 24 18	 mov	 ebx, DWORD PTR ___s$[esp+12]
  00024	8b c3		 mov	 eax, ebx
  00026	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00029	8d a4 24 00 00
	00 00		 npad	 7
$L92580:
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $L92580

; 701  :     if (size() > max_size() - __len)

  00037	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003a	2b c2		 sub	 eax, edx
  0003c	2b 0e		 sub	 ecx, DWORD PTR [esi]
  0003e	8b f8		 mov	 edi, eax
  00040	ba fe ff ff ff	 mov	 edx, -2			; fffffffeH
  00045	2b d7		 sub	 edx, edi
  00047	3b ca		 cmp	 ecx, edx
  00049	76 0d		 jbe	 SHORT $L92564

; 702  :       this->_M_throw_length_error();

  0004b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@GOPDCEEB@basic_string?$AA@
  00050	e8 00 00 00 00	 call	 ?__stl_throw_length_error@_STL@@YAXPBD@Z ; _STL::__stl_throw_length_error
  00055	83 c4 04	 add	 esp, 4
$L92564:

; 703  :     insert(this->_M_start + __pos, __s, __s + __len);

  00058	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005a	8d 44 24 14	 lea	 eax, DWORD PTR $T92578[esp+12]
  0005e	50		 push	 eax
  0005f	03 fb		 add	 edi, ebx
  00061	57		 push	 edi
  00062	03 cd		 add	 ecx, ebp
  00064	53		 push	 ebx
  00065	51		 push	 ecx
  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 ??$insert@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEXPADPBD1ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert<char const *>
  0006d	5f		 pop	 edi

; 704  :     return *this;

  0006e	8b c6		 mov	 eax, esi
  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp
  00072	5b		 pop	 ebx

; 705  :   }

  00073	c2 08 00	 ret	 8
?insert@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@IPBD@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@PBD@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append
; Function compile flags: /Ogty
;	COMDAT ?append@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
$T92599 = 8						; size = 1
___s$ = 8						; size = 4
?append@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@PBD@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append, COMDAT
; _this$ = ecx

; 499  :     { _STLP_FIX_LITERAL_BUG(__s) return append(__s, __s + traits_type::length(__s)); }

  00000	56		 push	 esi
  00001	8b 74 24 08	 mov	 esi, DWORD PTR ___s$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L92600:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $L92600
  00017	2b c7		 sub	 eax, edi
  00019	8d 54 24 0c	 lea	 edx, DWORD PTR $T92599[esp+4]
  0001d	52		 push	 edx
  0001e	03 c6		 add	 eax, esi
  00020	50		 push	 eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>
  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	c2 04 00	 ret	 4
?append@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@PBD@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	?g_MakeLinefeedString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@PADHPAUHFONT__@@@Z ; g_MakeLinefeedString
;	COMDAT xdata$x
; File c:\stlport-4.6.1\stlport\stl\_new.h
xdata$x	SEGMENT
$T92692	DD	0ffffffffH
	DD	FLAT:$L92606
	DD	00H
	DD	FLAT:$L92605
$T92686	DD	019930520H
	DD	02H
	DD	FLAT:$T92692
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\new - vs_ui\src\hangul\fl2.cpp
CONST	ENDS
;	COMDAT ?g_MakeLinefeedString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@PADHPAUHFONT__@@@Z
_TEXT	SEGMENT
tv134 = -32						; size = 4
$T92607 = -28						; size = 4
_resultString$ = -24					; size = 12
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_sz_src$ = 12						; size = 4
$T92604 = 16						; size = 1
_linewidth$ = 16					; size = 4
_hfont$ = 20						; size = 4
?g_MakeLinefeedString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@PADHPAUHFONT__@@@Z PROC NEAR ; g_MakeLinefeedString, COMDAT

; 294  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?g_MakeLinefeedString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@PADHPAUHFONT__@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 14	 sub	 esp, 20			; 00000014H
  00018	53		 push	 ebx

; 295  : 	assert (sz_src != NULL);
; 296  : 
; 297  : 	std::string resultString = sz_src;

  00019	8b 5c 24 2c	 mov	 ebx, DWORD PTR _sz_src$[esp+32]
  0001d	55		 push	 ebp
  0001e	56		 push	 esi
  0001f	8d 44 24 38	 lea	 eax, DWORD PTR $T92604[esp+40]
  00023	50		 push	 eax

; 298  : 
; 299  : 	int strWidth = g_GetStringWidth(sz_src, hfont);
; 300  : 	int LinefeedCount = strWidth/linewidth;
; 301  : 
; 302  : 	int srcIndex = 0;
; 303  : 	int destIndex = 0;
; 304  : 	int LinefeedIndex = 0;
; 305  : 	for (int i=0; i<LinefeedCount; i++)

  00024	33 f6		 xor	 esi, esi
  00026	53		 push	 ebx
  00027	8d 4c 24 1c	 lea	 ecx, DWORD PTR _resultString$[esp+52]
  0002b	89 74 24 18	 mov	 DWORD PTR $T92607[esp+52], esi
  0002f	e8 00 00 00 00	 call	 ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@PBDABV?$allocator@D@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
  00034	8b 4c 24 3c	 mov	 ecx, DWORD PTR _hfont$[esp+40]
  00038	51		 push	 ecx
  00039	53		 push	 ebx
  0003a	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 1
  00042	e8 00 00 00 00	 call	 ?g_GetStringWidth@@YAHPBDPAUHFONT__@@@Z ; g_GetStringWidth
  00047	99		 cdq
  00048	f7 7c 24 40	 idiv	 DWORD PTR _linewidth$[esp+48]
  0004c	83 c4 08	 add	 esp, 8
  0004f	33 ed		 xor	 ebp, ebp
  00051	3b c6		 cmp	 eax, esi
  00053	7e 43		 jle	 SHORT $L88554
  00055	89 44 24 0c	 mov	 DWORD PTR tv134[esp+44], eax
  00059	57		 push	 edi
  0005a	8d 9b 00 00 00
	00		 npad	 6
$L92690:

; 306  : 	{
; 307  : 		LinefeedIndex = g_GetStringIndexByWidth (&sz_src[srcIndex], linewidth, hfont);

  00060	8b 54 24 40	 mov	 edx, DWORD PTR _hfont$[esp+44]
  00064	8b 44 24 3c	 mov	 eax, DWORD PTR _linewidth$[esp+44]
  00068	52		 push	 edx
  00069	50		 push	 eax
  0006a	8d 0c 2b	 lea	 ecx, DWORD PTR [ebx+ebp]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 ?g_GetStringIndexByWidth@@YAHPBDHPAUHFONT__@@@Z ; g_GetStringIndexByWidth
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	8b f8		 mov	 edi, eax

; 308  : 		destIndex += LinefeedIndex;
; 309  : 		resultString.insert(destIndex, "\n");

  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  0007d	03 f7		 add	 esi, edi
  0007f	56		 push	 esi
  00080	8d 4c 24 20	 lea	 ecx, DWORD PTR _resultString$[esp+56]
  00084	e8 00 00 00 00	 call	 ?insert@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@IPBD@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert
  00089	8b 44 24 10	 mov	 eax, DWORD PTR tv134[esp+48]

; 310  : 		destIndex ++;

  0008d	46		 inc	 esi

; 311  : 		srcIndex += LinefeedIndex;

  0008e	03 ef		 add	 ebp, edi
  00090	48		 dec	 eax
  00091	89 44 24 10	 mov	 DWORD PTR tv134[esp+48], eax
  00095	75 c9		 jne	 SHORT $L92690
  00097	5f		 pop	 edi
$L88554:

; 312  : 	}
; 313  : 	return resultString;

  00098	8b 74 24 30	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+40]
  0009c	8d 54 24 14	 lea	 edx, DWORD PTR _resultString$[esp+44]
  000a0	52		 push	 edx
  000a1	8b ce		 mov	 ecx, esi
  000a3	e8 00 00 00 00	 call	 ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@ABV01@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
  000a8	8b 4c 24 14	 mov	 ecx, DWORD PTR _resultString$[esp+44]
  000ac	8b 44 24 1c	 mov	 eax, DWORD PTR _resultString$[esp+52]
  000b0	2b c1		 sub	 eax, ecx
  000b2	85 c9		 test	 ecx, ecx
  000b4	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR $T92607[esp+44], 1
  000bc	c6 44 24 28 00	 mov	 BYTE PTR __$EHRec$[esp+52], 0
  000c1	74 2e		 je	 SHORT $L92689
  000c3	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000c8	76 1d		 jbe	 SHORT $L92678
  000ca	51		 push	 ecx
  000cb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d0	83 c4 04	 add	 esp, 4
  000d3	8b c6		 mov	 eax, esi
  000d5	5e		 pop	 esi
  000d6	5d		 pop	 ebp
  000d7	5b		 pop	 ebx

; 314  : }

  000d8	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e3	83 c4 20	 add	 esp, 32			; 00000020H
  000e6	c3		 ret	 0

; 312  : 	}
; 313  : 	return resultString;

$L92678:
  000e7	50		 push	 eax
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 ?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z ; _STL::__node_alloc<1,0>::_M_deallocate
  000ee	83 c4 08	 add	 esp, 8
$L92689:

; 314  : }

  000f1	8b 4c 24 20	 mov	 ecx, DWORD PTR __$EHRec$[esp+44]
  000f5	8b c6		 mov	 eax, esi
  000f7	5e		 pop	 esi
  000f8	5d		 pop	 ebp
  000f9	5b		 pop	 ebx
  000fa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00101	83 c4 20	 add	 esp, 32			; 00000020H
  00104	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L92605:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _resultString$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
$L92606:
  00008	8b 45 e4	 mov	 eax, DWORD PTR $T92607[ebp]
  0000b	83 e0 01	 and	 eax, 1
  0000e	0f 84 0c 00 00
	00		 je	 $L92608
  00014	83 65 e4 fe	 and	 DWORD PTR $T92607[ebp], -2 ; fffffffeH
  00018	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
$L92608:
  00020	c3		 ret	 0
__ehhandler$?g_MakeLinefeedString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@PADHPAUHFONT__@@@Z:
  00021	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T92686
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?g_MakeLinefeedString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@PADHPAUHFONT__@@@Z ENDP ; g_MakeLinefeedString
PUBLIC	?g_DrawText@@YAXPAUtagRECT@@PBDPAUPrintInfo@@@Z	; g_DrawText
EXTRN	__imp__DrawTextA@20:NEAR
;	COMDAT xdata$x
; File c:\stlport-4.6.1\stlport\stl\_new.h
xdata$x	SEGMENT
$T92808	DD	0ffffffffH
	DD	FLAT:$L92698
$T92803	DD	019930520H
	DD	01H
	DD	FLAT:$T92808
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\new - vs_ui\src\hangul\fl2.cpp
xdata$x	ENDS
;	COMDAT ?g_DrawText@@YAXPAUtagRECT@@PBDPAUPrintInfo@@@Z
_TEXT	SEGMENT
_hfont$88570 = -48					; size = 4
tv91 = -44						; size = 4
_srcStr$88572 = -40					; size = 12
_sRt$88581 = -28					; size = 16
__$EHRec$ = -12						; size = 12
_LinefeedCount$88569 = 8				; size = 4
_pRt$ = 8						; size = 4
_sz_str$ = 12						; size = 4
_p_print_info$ = 16					; size = 4
?g_DrawText@@YAXPAUtagRECT@@PBDPAUPrintInfo@@@Z PROC NEAR ; g_DrawText, COMDAT

; 317  : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?g_DrawText@@YAXPAUtagRECT@@PBDPAUPrintInfo@@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 24	 sub	 esp, 36			; 00000024H
  00018	57		 push	 edi

; 318  : 	if(!pRt || !sz_str) return;

  00019	8b 7c 24 38	 mov	 edi, DWORD PTR _pRt$[esp+48]
  0001d	85 ff		 test	 edi, edi
  0001f	0f 84 5d 01 00
	00		 je	 $L92796
  00025	53		 push	 ebx
  00026	8b 5c 24 40	 mov	 ebx, DWORD PTR _sz_str$[esp+52]
  0002a	85 db		 test	 ebx, ebx
  0002c	0f 84 4f 01 00
	00		 je	 $L92807

; 319  : 
; 320  : 	assert(!gpC_base->m_p_DDSurface_back->IsLock());
; 321  : 	if (sz_str!=NULL)
; 322  : 	{
; 323  : 		//assert(sz_str != NULL);
; 324  : 		assert(gpC_fl2_surface != NULL);
; 325  : 
; 326  : 		//sz_strÕÉ ?øË?Ðë ?ø·ËÔ pRtÕÉ ?? ý§ÛÎ??, ?Öð?? äùÖï??? ? ??? Ðá ?Ý¤Êµõµ.
; 327  : 
; 328  : 		int str_length = strlen(sz_str);
; 329  : 		int destWidth = pRt->right - pRt->left;

  00032	8b 17		 mov	 edx, DWORD PTR [edi]
  00034	55		 push	 ebp

; 330  : 		int strWidth = g_GetStringWidth(sz_str, p_print_info->hfont);

  00035	8b 6c 24 48	 mov	 ebp, DWORD PTR _p_print_info$[esp+56]
  00039	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0003c	56		 push	 esi
  0003d	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00040	50		 push	 eax
  00041	53		 push	 ebx
  00042	2b f2		 sub	 esi, edx
  00044	e8 00 00 00 00	 call	 ?g_GetStringWidth@@YAHPBDPAUHFONT__@@@Z ; g_GetStringWidth

; 331  : 		int LinefeedCount = strWidth / destWidth;

  00049	99		 cdq
  0004a	f7 fe		 idiv	 esi

; 332  : 		HFONT hfont = NULL;
; 333  : 		if (p_print_info)
; 334  : 			hfont = p_print_info->hfont;
; 335  : 		
; 336  : 		std::string srcStr = g_MakeLinefeedString ((char*)sz_str, destWidth, hfont);//sz_str;

  0004c	8d 4c 24 20	 lea	 ecx, DWORD PTR _srcStr$88572[esp+72]
  00050	89 44 24 4c	 mov	 DWORD PTR _LinefeedCount$88569[esp+68], eax
  00054	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00057	50		 push	 eax
  00058	56		 push	 esi
  00059	53		 push	 ebx
  0005a	51		 push	 ecx
  0005b	89 54 24 2c	 mov	 DWORD PTR tv91[esp+88], edx
  0005f	89 44 24 28	 mov	 DWORD PTR _hfont$88570[esp+88], eax
  00063	e8 00 00 00 00	 call	 ?g_MakeLinefeedString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@PADHPAUHFONT__@@@Z ; g_MakeLinefeedString

; 337  : 
; 338  : 	
; 339  : /*		int srcIndex = 0;
; 340  : 		int destIndex = 0;
; 341  : 		int LinefeedIndex = 0;
; 342  : 		for (int i=0; i<LinefeedCount; i++)
; 343  : 		{
; 344  : 			LinefeedIndex = g_GetStringIndexByWidth (&sz_str[srcIndex], destWidth, hfont);
; 345  : 			destIndex += LinefeedIndex;
; 346  : 			srcStr.insert(destIndex, "\n");
; 347  : 			destIndex ++;
; 348  : 			srcIndex += LinefeedIndex;
; 349  : 		}*/
; 350  : 
; 351  : 		int strHeight = g_GetStringHeight(sz_str, hfont);

  00068	8b 54 24 28	 mov	 edx, DWORD PTR _hfont$88570[esp+88]
  0006c	52		 push	 edx
  0006d	53		 push	 ebx
  0006e	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+104], 0
  00076	e8 00 00 00 00	 call	 ?g_GetStringHeight@@YAHPBDPAUHFONT__@@@Z ; g_GetStringHeight

; 352  : 		int destHeight = pRt->bottom - pRt->top;
; 353  : 		if (strWidth%destWidth) LinefeedCount++;

  0007b	8b 4c 24 34	 mov	 ecx, DWORD PTR tv91[esp+96]
  0007f	83 c4 20	 add	 esp, 32			; 00000020H
  00082	85 c9		 test	 ecx, ecx
  00084	74 04		 je	 SHORT $L92805
  00086	ff 44 24 44	 inc	 DWORD PTR _LinefeedCount$88569[esp+60]
$L92805:

; 354  : 		pRt->bottom = pRt->top + strHeight * LinefeedCount;

  0008a	0f af 44 24 44	 imul	 eax, DWORD PTR _LinefeedCount$88569[esp+60]
  0008f	03 47 04	 add	 eax, DWORD PTR [edi+4]
  00092	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 355  : 
; 356  : 		// no Release exception handling code for speed.
; 357  : 
; 358  : 		HDC hdc;
; 359  : 
; 360  : 		bool bGetDC = g_FL2_GetDC();

  00095	e8 00 00 00 00	 call	 ?g_FL2_GetDC@@YA_NXZ	; g_FL2_GetDC

; 361  : 
; 362  : 		hdc = gh_FL2_DC;

  0009a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gh_FL2_DC@@3PAUHDC__@@A ; gh_FL2_DC
  000a0	8a d8		 mov	 bl, al

; 363  : 
; 364  : 		if (p_print_info != NULL)
; 365  : 		{
; 366  : 			SetTextAlign(hdc, p_print_info->text_align);

  000a2	8b 45 10	 mov	 eax, DWORD PTR [ebp+16]
  000a5	50		 push	 eax
  000a6	56		 push	 esi
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextAlign@8

; 367  : 			SetBkMode(hdc, p_print_info->bk_mode);

  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  000b0	51		 push	 ecx
  000b1	56		 push	 esi
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkMode@8

; 368  : 			SetBkColor(hdc, p_print_info->back_color);

  000b8	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  000bb	52		 push	 edx
  000bc	56		 push	 esi
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8

; 369  : 			SelectObject(hdc, p_print_info->hfont);

  000c3	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  000c6	50		 push	 eax
  000c7	56		 push	 esi
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 370  : //øÉÜÝÖð Øó?
; 371  : 			SetTextColor(hdc, 0);

  000ce	6a 00		 push	 0
  000d0	56		 push	 esi
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8

; 372  : 			RECT sRt = {pRt->left+1, pRt->top+1, pRt->right+1, pRt->bottom+1};

  000d7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000d9	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000dc	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000df	41		 inc	 ecx
  000e0	42		 inc	 edx
  000e1	89 4c 24 24	 mov	 DWORD PTR _sRt$88581[esp+64], ecx
  000e5	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000e8	40		 inc	 eax
  000e9	89 54 24 28	 mov	 DWORD PTR _sRt$88581[esp+68], edx

; 373  : 			DrawText(hdc, srcStr.c_str(), srcStr.length(), &sRt, p_print_info->text_align);

  000ed	8b 55 10	 mov	 edx, DWORD PTR [ebp+16]
  000f0	52		 push	 edx
  000f1	89 44 24 30	 mov	 DWORD PTR _sRt$88581[esp+76], eax
  000f5	41		 inc	 ecx
  000f6	8d 44 24 28	 lea	 eax, DWORD PTR _sRt$88581[esp+68]
  000fa	50		 push	 eax
  000fb	8b 44 24 20	 mov	 eax, DWORD PTR _srcStr$88572[esp+72]
  000ff	89 4c 24 38	 mov	 DWORD PTR _sRt$88581[esp+84], ecx
  00103	8b 4c 24 24	 mov	 ecx, DWORD PTR _srcStr$88572[esp+76]
  00107	2b c8		 sub	 ecx, eax
  00109	51		 push	 ecx
  0010a	50		 push	 eax
  0010b	56		 push	 esi
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawTextA@20

; 374  : //?Öð? Øó?
; 375  : 			SetTextColor(hdc, p_print_info->text_color);

  00112	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  00115	52		 push	 edx
  00116	56		 push	 esi
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8

; 376  : 			DrawText(hdc, srcStr.c_str(), srcStr.length(), pRt, p_print_info->text_align);

  0011d	8b 45 10	 mov	 eax, DWORD PTR [ebp+16]
  00120	8b 4c 24 1c	 mov	 ecx, DWORD PTR _srcStr$88572[esp+68]
  00124	50		 push	 eax
  00125	8b 44 24 1c	 mov	 eax, DWORD PTR _srcStr$88572[esp+68]
  00129	57		 push	 edi
  0012a	2b c8		 sub	 ecx, eax
  0012c	51		 push	 ecx
  0012d	50		 push	 eax
  0012e	56		 push	 esi
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawTextA@20

; 377  : 
; 378  : 		}
; 379  : 		else
; 380  : 			DrawText(hdc, srcStr.c_str(), srcStr.length(), pRt, DT_LEFT);
; 381  : 
; 382  : 		if(bGetDC)

  00135	84 db		 test	 bl, bl
  00137	5e		 pop	 esi
  00138	5d		 pop	 ebp
  00139	74 05		 je	 SHORT $L88583

; 383  : 			g_FL2_ReleaseDC();

  0013b	e8 00 00 00 00	 call	 ?g_FL2_ReleaseDC@@YA_NXZ ; g_FL2_ReleaseDC
$L88583:

; 384  : 
; 385  : 	}

  00140	8b 4c 24 10	 mov	 ecx, DWORD PTR _srcStr$88572[esp+56]
  00144	8b 44 24 18	 mov	 eax, DWORD PTR _srcStr$88572[esp+64]
  00148	2b c1		 sub	 eax, ecx
  0014a	85 c9		 test	 ecx, ecx
  0014c	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+64], -1
  00154	74 2b		 je	 SHORT $L92807
  00156	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0015b	76 1a		 jbe	 SHORT $L92795
  0015d	51		 push	 ecx
  0015e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00163	83 c4 04	 add	 esp, 4
  00166	5b		 pop	 ebx
  00167	5f		 pop	 edi

; 386  : }

  00168	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  0016c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00173	83 c4 30	 add	 esp, 48			; 00000030H
  00176	c3		 ret	 0

; 384  : 
; 385  : 	}

$L92795:
  00177	50		 push	 eax
  00178	51		 push	 ecx
  00179	e8 00 00 00 00	 call	 ?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z ; _STL::__node_alloc<1,0>::_M_deallocate
  0017e	83 c4 08	 add	 esp, 8
$L92807:
  00181	5b		 pop	 ebx
$L92796:

; 386  : }

  00182	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  00186	5f		 pop	 edi
  00187	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0018e	83 c4 30	 add	 esp, 48			; 00000030H
  00191	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L92698:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _srcStr$88572[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
__ehhandler$?g_DrawText@@YAXPAUtagRECT@@PBDPAUPrintInfo@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T92803
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?g_DrawText@@YAXPAUtagRECT@@PBDPAUPrintInfo@@@Z ENDP	; g_DrawText
PUBLIC	?g_GetNumberString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@H@Z ; g_GetNumberString
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
EXTRN	__imp__wsprintfA:NEAR
;	COMDAT xdata$x
; File c:\stlport-4.6.1\stlport\stl\_new.h
xdata$x	SEGMENT
$T92909	DD	0ffffffffH
	DD	FLAT:$L92817
	DD	00H
	DD	FLAT:$L92816
$T92903	DD	019930520H
	DD	02H
	DD	FLAT:$T92909
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\new - vs_ui\src\hangul\fl2.cpp
CONST	ENDS
;	COMDAT ?g_GetNumberString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@H@Z
_TEXT	SEGMENT
_sstr$ = -52						; size = 12
$T92818 = -40						; size = 4
_sz_temp$ = -36						; size = 20
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
$T92815 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
_number$ = 12						; size = 4
?g_GetNumberString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@H@Z PROC NEAR ; g_GetNumberString, COMDAT

; 752  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?g_GetNumberString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@H@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 28	 sub	 esp, 40			; 00000028H
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	89 44 24 24	 mov	 DWORD PTR __$ArrayPad$[esp+52], eax

; 753  : 	char sz_temp[20];
; 754  : 	wsprintf(sz_temp, "%d", number);

  00021	8b 44 24 3c	 mov	 eax, DWORD PTR _number$[esp+48]
  00025	56		 push	 esi
  00026	50		 push	 eax
  00027	8d 4c 24 18	 lea	 ecx, DWORD PTR _sz_temp$[esp+60]
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00030	51		 push	 ecx
  00031	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T92818[esp+68], 0
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 755  : 	std::string sstr = sz_temp;

  00042	8d 54 24 3c	 lea	 edx, DWORD PTR $T92815[esp+52]
  00046	52		 push	 edx
  00047	8d 44 24 18	 lea	 eax, DWORD PTR _sz_temp$[esp+60]
  0004b	50		 push	 eax
  0004c	8d 4c 24 0c	 lea	 ecx, DWORD PTR _sstr$[esp+64]
  00050	e8 00 00 00 00	 call	 ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@PBDABV?$allocator@D@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >

; 756  : 	for(int i = 3; i <= 13; i += 4)

  00055	8b 44 24 08	 mov	 eax, DWORD PTR _sstr$[esp+60]
  00059	8b 4c 24 04	 mov	 ecx, DWORD PTR _sstr$[esp+56]
  0005d	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+64], 1
  00065	be 03 00 00 00	 mov	 esi, 3
  0006a	8d 9b 00 00 00
	00		 npad	 6
$L88770:

; 757  : 		if((int)sstr.size() > i)sstr.insert(sstr.size()-i, ",");

  00070	8b d0		 mov	 edx, eax
  00072	2b d1		 sub	 edx, ecx
  00074	3b d6		 cmp	 edx, esi
  00076	7e 1b		 jle	 SHORT $L88771
  00078	2b c6		 sub	 eax, esi
  0007a	2b c1		 sub	 eax, ecx
  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01IHBHIGKO@?0?$AA@
  00081	50		 push	 eax
  00082	8d 4c 24 0c	 lea	 ecx, DWORD PTR _sstr$[esp+64]
  00086	e8 00 00 00 00	 call	 ?insert@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV12@IPBD@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::insert
  0008b	8b 44 24 08	 mov	 eax, DWORD PTR _sstr$[esp+60]
  0008f	8b 4c 24 04	 mov	 ecx, DWORD PTR _sstr$[esp+56]
$L88771:
  00093	83 c6 04	 add	 esi, 4
  00096	83 fe 0d	 cmp	 esi, 13			; 0000000dH
  00099	7e d5		 jle	 SHORT $L88770

; 758  : 
; 759  : 	return sstr;

  0009b	8b 74 24 3c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+52]
  0009f	8d 44 24 04	 lea	 eax, DWORD PTR _sstr$[esp+56]
  000a3	50		 push	 eax
  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@ABV01@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
  000ab	8b 4c 24 04	 mov	 ecx, DWORD PTR _sstr$[esp+56]
  000af	8b 44 24 0c	 mov	 eax, DWORD PTR _sstr$[esp+64]
  000b3	2b c1		 sub	 eax, ecx
  000b5	85 c9		 test	 ecx, ecx
  000b7	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR $T92818[esp+56], 1
  000bf	c6 44 24 34 00	 mov	 BYTE PTR __$EHRec$[esp+64], 0
  000c4	74 1c		 je	 SHORT $L92906
  000c6	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000cb	76 0b		 jbe	 SHORT $L92896
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d3	83 c4 04	 add	 esp, 4
  000d6	eb 0a		 jmp	 SHORT $L92906
$L92896:
  000d8	50		 push	 eax
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 ?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z ; _STL::__node_alloc<1,0>::_M_deallocate
  000df	83 c4 08	 add	 esp, 8
$L92906:

; 760  : }

  000e2	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$EHRec$[esp+56]
  000e6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ed	8b 4c 24 28	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  000f1	8b c6		 mov	 eax, esi
  000f3	5e		 pop	 esi
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	83 c4 34	 add	 esp, 52			; 00000034H
  000fc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L92816:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR _sstr$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
$L92817:
  00008	8b 45 d8	 mov	 eax, DWORD PTR $T92818[ebp]
  0000b	83 e0 01	 and	 eax, 1
  0000e	0f 84 0c 00 00
	00		 je	 $L92819
  00014	83 65 d8 fe	 and	 DWORD PTR $T92818[ebp], -2 ; fffffffeH
  00018	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
$L92819:
  00020	c3		 ret	 0
__ehhandler$?g_GetNumberString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@H@Z:
  00021	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T92903
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?g_GetNumberString@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@H@Z ENDP ; g_GetNumberString
PUBLIC	??Y?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::operator+=
; Function compile flags: /Ogty
; File c:\stlport-4.6.1\stlport\stl\_string.h
;	COMDAT ??Y?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
$T92940 = 8						; size = 1
___s$ = 8						; size = 4
??Y?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD@Z PROC NEAR ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 481  :   _Self& operator+=(const _CharT* __s) { _STLP_FIX_LITERAL_BUG(__s) return append(__s); }

  00000	56		 push	 esi
  00001	8b 74 24 08	 mov	 esi, DWORD PTR ___s$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L92942:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $L92942
  00017	2b c7		 sub	 eax, edi
  00019	8d 54 24 0c	 lea	 edx, DWORD PTR $T92940[esp+4]
  0001d	52		 push	 edx
  0001e	03 c6		 add	 eax, esi
  00020	50		 push	 eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>
  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	c2 04 00	 ret	 4
??Y?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAEAAV01@PBD@Z ENDP ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	?g_GetStringByMoney@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@K@Z ; g_GetStringByMoney
PUBLIC	??_C@_04JCJOPEPL@?$CFd?$LO?o?$AA@		; `string'
PUBLIC	??_C@_04GDOJEDNK@?$CFd?$LI?$LI?$AA@		; `string'
;	COMDAT xdata$x
; File c:\stlport-4.6.1\stlport\stl\_new.h
xdata$x	SEGMENT
$T93149	DD	0ffffffffH
	DD	FLAT:$L92948
	DD	00H
	DD	FLAT:$L92947
$T93142	DD	019930520H
	DD	02H
	DD	FLAT:$T93149
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_04JCJOPEPL@?$CFd?$LO?o?$AA@
CONST	SEGMENT
??_C@_04JCJOPEPL@?$CFd?$LO?o?$AA@ DB '%d', 0beH, 0efH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GDOJEDNK@?$CFd?$LI?$LI?$AA@
CONST	SEGMENT
??_C@_04GDOJEDNK@?$CFd?$LI?$LI?$AA@ DB '%d', 0b8H, 0b8H, 00H ; `string'
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\new - vs_ui\src\hangul\fl2.cpp
CONST	ENDS
;	COMDAT ?g_GetStringByMoney@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@K@Z
_TEXT	SEGMENT
_sstr$ = -64						; size = 12
$T92949 = -52						; size = 4
_TempBuffer$ = -48					; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
$T93070 = 12						; size = 1
$T93029 = 12						; size = 1
$T92989 = 12						; size = 1
_dwMoney$ = 12						; size = 4
?g_GetStringByMoney@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@K@Z PROC NEAR ; g_GetStringByMoney, COMDAT

; 764  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?g_GetStringByMoney@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@K@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 34	 sub	 esp, 52			; 00000034H
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	89 44 24 30	 mov	 DWORD PTR __$ArrayPad$[esp+64], eax
  00021	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR $T92949[esp+64], 0

; 765  : 	char TempBuffer[32] = {0,};

  00029	33 c0		 xor	 eax, eax
  0002b	89 44 24 11	 mov	 DWORD PTR _TempBuffer$[esp+65], eax
  0002f	89 44 24 15	 mov	 DWORD PTR _TempBuffer$[esp+69], eax
  00033	89 44 24 19	 mov	 DWORD PTR _TempBuffer$[esp+73], eax
  00037	89 44 24 1d	 mov	 DWORD PTR _TempBuffer$[esp+77], eax
  0003b	89 44 24 21	 mov	 DWORD PTR _TempBuffer$[esp+81], eax
  0003f	89 44 24 25	 mov	 DWORD PTR _TempBuffer$[esp+85], eax
  00043	89 44 24 29	 mov	 DWORD PTR _TempBuffer$[esp+89], eax
  00047	56		 push	 esi
  00048	66 89 44 24 31	 mov	 WORD PTR _TempBuffer$[esp+97], ax
  0004d	57		 push	 edi

; 766  : 	std::string sstr;

  0004e	8d 4c 24 08	 lea	 ecx, DWORD PTR _sstr$[esp+72]
  00052	c6 44 24 18 00	 mov	 BYTE PTR _TempBuffer$[esp+72], 0
  00057	88 44 24 37	 mov	 BYTE PTR _TempBuffer$[esp+103], al
  0005b	e8 00 00 00 00	 call	 ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >

; 767  : 	DWORD TempMoney = 0;
; 768  : 	if(dwMoney>=100000000) // ?

  00060	8b 74 24 50	 mov	 esi, DWORD PTR _dwMoney$[esp+68]
  00064	81 fe 00 e1 f5
	05		 cmp	 esi, 100000000		; 05f5e100H
  0006a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__wsprintfA
  00070	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+80], 1
  00078	72 47		 jb	 SHORT $L92979

; 769  : 	{
; 770  : 		TempMoney = dwMoney / 100000000;

  0007a	b8 89 3b e6 55	 mov	 eax, 1441151881		; 55e63b89H
  0007f	f7 e6		 mul	 esi
  00081	c1 ea 19	 shr	 edx, 25			; 00000019H

; 771  : 		if(TempMoney)

  00084	85 d2		 test	 edx, edx
  00086	74 39		 je	 SHORT $L92979

; 772  : 		{
; 773  : 			wsprintf(TempBuffer, "%d¾ï", TempMoney);

  00088	52		 push	 edx
  00089	8d 4c 24 1c	 lea	 ecx, DWORD PTR _TempBuffer$[esp+76]
  0008d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JCJOPEPL@?$CFd?$LO?o?$AA@
  00092	51		 push	 ecx
  00093	ff d7		 call	 edi

; 774  : 			sstr+= TempBuffer;

  00095	8d 44 24 24	 lea	 eax, DWORD PTR _TempBuffer$[esp+84]
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0009f	90		 npad	 1
$L93143:
  000a0	8a 08		 mov	 cl, BYTE PTR [eax]
  000a2	40		 inc	 eax
  000a3	84 c9		 test	 cl, cl
  000a5	75 f9		 jne	 SHORT $L93143
  000a7	2b c2		 sub	 eax, edx
  000a9	8d 54 24 50	 lea	 edx, DWORD PTR $T92989[esp+68]
  000ad	52		 push	 edx
  000ae	8d 44 04 1c	 lea	 eax, DWORD PTR _TempBuffer$[esp+eax+76]
  000b2	50		 push	 eax
  000b3	8d 4c 24 20	 lea	 ecx, DWORD PTR _TempBuffer$[esp+80]
  000b7	51		 push	 ecx
  000b8	8d 4c 24 14	 lea	 ecx, DWORD PTR _sstr$[esp+84]
  000bc	e8 00 00 00 00	 call	 ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>
$L92979:

; 775  : 		}
; 776  : 	}
; 777  : 	if(dwMoney>=10000) // Ý«

  000c1	81 fe 10 27 00
	00		 cmp	 esi, 10000		; 00002710H
  000c7	72 58		 jb	 SHORT $L93019

; 778  : 	{
; 779  : 		TempMoney = (dwMoney%100000000) / 10000;

  000c9	33 d2		 xor	 edx, edx
  000cb	8b c6		 mov	 eax, esi
  000cd	b9 00 e1 f5 05	 mov	 ecx, 100000000		; 05f5e100H
  000d2	f7 f1		 div	 ecx
  000d4	b8 59 17 b7 d1	 mov	 eax, -776530087		; d1b71759H
  000d9	f7 e2		 mul	 edx
  000db	c1 ea 0d	 shr	 edx, 13			; 0000000dH

; 780  : 		if(TempMoney)

  000de	85 d2		 test	 edx, edx
  000e0	74 3f		 je	 SHORT $L93019

; 781  : 		{
; 782  : 			wsprintf(TempBuffer, "%d¸¸", TempMoney);

  000e2	52		 push	 edx
  000e3	8d 54 24 1c	 lea	 edx, DWORD PTR _TempBuffer$[esp+76]
  000e7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04GDOJEDNK@?$CFd?$LI?$LI?$AA@
  000ec	52		 push	 edx
  000ed	ff d7		 call	 edi

; 783  : 			sstr+= TempBuffer;

  000ef	8d 44 24 24	 lea	 eax, DWORD PTR _TempBuffer$[esp+84]
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f6	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  000f9	8d a4 24 00 00
	00 00		 npad	 7
$L93144:
  00100	8a 08		 mov	 cl, BYTE PTR [eax]
  00102	40		 inc	 eax
  00103	84 c9		 test	 cl, cl
  00105	75 f9		 jne	 SHORT $L93144
  00107	2b c2		 sub	 eax, edx
  00109	8d 4c 24 50	 lea	 ecx, DWORD PTR $T93029[esp+68]
  0010d	51		 push	 ecx
  0010e	8d 54 04 1c	 lea	 edx, DWORD PTR _TempBuffer$[esp+eax+76]
  00112	52		 push	 edx
  00113	8d 44 24 20	 lea	 eax, DWORD PTR _TempBuffer$[esp+80]
  00117	50		 push	 eax
  00118	8d 4c 24 14	 lea	 ecx, DWORD PTR _sstr$[esp+84]
  0011c	e8 00 00 00 00	 call	 ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>
$L93019:

; 784  : 		}
; 785  : 	}
; 786  : 	
; 787  : 	TempMoney = (dwMoney%10000);

  00121	33 d2		 xor	 edx, edx
  00123	8b c6		 mov	 eax, esi
  00125	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0012a	f7 f1		 div	 ecx

; 788  : 	if(TempMoney || 0 == dwMoney)

  0012c	85 d2		 test	 edx, edx
  0012e	75 04		 jne	 SHORT $L88790
  00130	85 f6		 test	 esi, esi
  00132	75 3d		 jne	 SHORT $L93059
$L88790:

; 789  : 	{
; 790  : 		wsprintf(TempBuffer, "%d", TempMoney);

  00134	52		 push	 edx
  00135	8d 54 24 1c	 lea	 edx, DWORD PTR _TempBuffer$[esp+76]
  00139	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  0013e	52		 push	 edx
  0013f	ff d7		 call	 edi

; 791  : 		sstr+= TempBuffer;

  00141	8d 44 24 24	 lea	 eax, DWORD PTR _TempBuffer$[esp+84]
  00145	83 c4 0c	 add	 esp, 12			; 0000000cH
  00148	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0014b	eb 03 8d 49 00	 npad	 5
$L93145:
  00150	8a 08		 mov	 cl, BYTE PTR [eax]
  00152	40		 inc	 eax
  00153	84 c9		 test	 cl, cl
  00155	75 f9		 jne	 SHORT $L93145
  00157	2b c2		 sub	 eax, edx
  00159	8d 4c 24 50	 lea	 ecx, DWORD PTR $T93070[esp+68]
  0015d	51		 push	 ecx
  0015e	8d 54 04 1c	 lea	 edx, DWORD PTR _TempBuffer$[esp+eax+76]
  00162	52		 push	 edx
  00163	8d 44 24 20	 lea	 eax, DWORD PTR _TempBuffer$[esp+80]
  00167	50		 push	 eax
  00168	8d 4c 24 14	 lea	 ecx, DWORD PTR _sstr$[esp+84]
  0016c	e8 00 00 00 00	 call	 ??$append@PBD@?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@AAEAAV01@PBD0ABUforward_iterator_tag@1@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::append<char const *>
$L93059:

; 792  : 	}
; 793  : 
; 794  : 	return sstr;

  00171	8b 74 24 4c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+68]
  00175	8d 4c 24 08	 lea	 ecx, DWORD PTR _sstr$[esp+72]
  00179	51		 push	 ecx
  0017a	8b ce		 mov	 ecx, esi
  0017c	e8 00 00 00 00	 call	 ??0?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@ABV01@@Z ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
  00181	8b 4c 24 08	 mov	 ecx, DWORD PTR _sstr$[esp+72]
  00185	8b 44 24 10	 mov	 eax, DWORD PTR _sstr$[esp+80]
  00189	2b c1		 sub	 eax, ecx
  0018b	85 c9		 test	 ecx, ecx
  0018d	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR $T92949[esp+72], 1
  00195	c6 44 24 44 00	 mov	 BYTE PTR __$EHRec$[esp+80], 0
  0019a	74 1c		 je	 SHORT $L93146
  0019c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  001a1	76 0b		 jbe	 SHORT $L93136
  001a3	51		 push	 ecx
  001a4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001a9	83 c4 04	 add	 esp, 4
  001ac	eb 0a		 jmp	 SHORT $L93146
$L93136:
  001ae	50		 push	 eax
  001af	51		 push	 ecx
  001b0	e8 00 00 00 00	 call	 ?_M_deallocate@?$__node_alloc@$00$0A@@_STL@@CAXPAXI@Z ; _STL::__node_alloc<1,0>::_M_deallocate
  001b5	83 c4 08	 add	 esp, 8
$L93146:

; 795  : }

  001b8	8b 4c 24 3c	 mov	 ecx, DWORD PTR __$EHRec$[esp+72]
  001bc	5f		 pop	 edi
  001bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c4	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+68]
  001c8	8b c6		 mov	 eax, esi
  001ca	5e		 pop	 esi
  001cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d0	83 c4 40	 add	 esp, 64			; 00000040H
  001d3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L92947:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _sstr$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
$L92948:
  00008	8b 45 cc	 mov	 eax, DWORD PTR $T92949[ebp]
  0000b	83 e0 01	 and	 eax, 1
  0000e	0f 84 0c 00 00
	00		 je	 $L92950
  00014	83 65 cc fe	 and	 DWORD PTR $T92949[ebp], -2 ; fffffffeH
  00018	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@QAE@XZ ; _STL::basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >::~basic_string<char,_STL::char_traits<char>,_STL::allocator<char> >
$L92950:
  00020	c3		 ret	 0
__ehhandler$?g_GetStringByMoney@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@K@Z:
  00021	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T93142
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?g_GetStringByMoney@@YA?AV?$basic_string@DV?$char_traits@D@_STL@@V?$allocator@D@2@@_STL@@K@Z ENDP ; g_GetStringByMoney
END
