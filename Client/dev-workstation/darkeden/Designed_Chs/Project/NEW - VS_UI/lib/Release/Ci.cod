; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\darkeden\Designed_Common\Project\New - vs_ui\src\hangul\Ci.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?Is565@CDirectDraw@@SA_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClipLeftTop@CDirectDrawSurface@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClipRightBottom@CDirectDrawSurface@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsKorean@CI@@UAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsChinese@CI@@UAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsJapanese@CI@@UAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEnglish@CI@@UAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ImeRunning@CI@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IME_MessageProcessor@CI@@UAEXIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Timer_BlinkCursor@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RunCursorBlinker@CI@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CI@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CI@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEngInput@CI@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetEngInput@CI@@QAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinishImeRunning@CI@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ForceShowCursor@CI@@QBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCursorBlink@CI@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEndOfIME@CI@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CI@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearCurrentIMEComposition@CI@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IME_MessageProcessor@CI_KOREAN@@UAEXIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IME_MessageProcessor@CI_CHINESE@@UAEXIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IMEObjectConvert@CI_JAPAN@@QAEXPAGAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IME_MessageProcessor@CI_JAPAN@@UAEXIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetJapanInput@CI@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$__char_traits_base@DH@_STL@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$__char_traits_base@DH@_STL@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$__char_traits_base@DH@_STL@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@_STL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@_STL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_return@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE?AV?$fpos@H@2@JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Filebuf_Tmp_Buf@D@_STL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Filebuf_Tmp_Buf@D@_STL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@_STL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_input_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_switch_to_output_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_output_error@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_deallocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_seek_init@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_setup_codecvt@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@PADPADU?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@@_STL@@YA_NPAD00U?$_Eq_traits@V?$char_traits@D@_STL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_exit_putback_mode@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$_Eq_traits@V?$char_traits@D@_STL@@@_STL@@QBE_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_unshift@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_allocate_buffers@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$max@H@_STL@@YAABHABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@_STL@@@_STL@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CI@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CI@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CI@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCI@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CI@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?__page_size@_Filebuf_base@_STL@@SAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_M_write@?$basic_filebuf@DV?$char_traits@D@_STL@@@_STL@@QAE_NPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@_STL@@QBE?AW4result@codecvt_base@2@AAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@?$codecvt@DDH@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?encoding@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_length@?$codecvt@DDH@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__o_mode@_Filebuf_base@_STL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_O_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_FILE_I_set@_STL@@YAXPAU_iobuf@@PAD11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DV?$char_traits@D@_STL@@@_STL@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__is_open@_Filebuf_base@_STL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$__char_traits_base@DH@_STL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?iBeforeLen@?CG@??IME_MessageProcessor@CI_JAPAN@@UAEXIIJ@Z@4HA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?pass@?1??IME_MessageProcessor@CI_KOREAN@@UAEXIIJ@Z@4HA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7CI@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?gC_ci@@3PAVCI@@A				; gC_ci
_BSS	SEGMENT
?gC_ci@@3PAVCI@@A DD 01H DUP (?)			; gC_ci
_gbl_draw_cursor DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_g_tid_cursor_blink DD 0ffffffffH
_DATA	ENDS
PUBLIC	?ImeRunning@CI@@QBE_NXZ				; CI::ImeRunning
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\new - vs_ui\src\hangul\ci.h
;	COMDAT ?ImeRunning@CI@@QBE_NXZ
_TEXT	SEGMENT
?ImeRunning@CI@@QBE_NXZ PROC NEAR			; CI::ImeRunning, COMDAT
; _this$ = ecx

; 65   : 	bool	ImeRunning() const { return m_bl_ime_running; } // IME가 실행중?

  00000	8a 41 06	 mov	 al, BYTE PTR [ecx+6]
  00003	c3		 ret	 0
?ImeRunning@CI@@QBE_NXZ ENDP				; CI::ImeRunning
_TEXT	ENDS
PUBLIC	?Timer_BlinkCursor@@YAXXZ			; Timer_BlinkCursor
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\new - vs_ui\src\hangul\ci.cpp
;	COMDAT ?Timer_BlinkCursor@@YAXXZ
_TEXT	SEGMENT
?Timer_BlinkCursor@@YAXXZ PROC NEAR			; Timer_BlinkCursor, COMDAT

; 28   : 	gbl_draw_cursor = !gbl_draw_cursor;

  00000	a0 00 00 00 00	 mov	 al, BYTE PTR _gbl_draw_cursor
  00005	84 c0		 test	 al, al
  00007	0f 94 c0	 sete	 al
  0000a	a2 00 00 00 00	 mov	 BYTE PTR _gbl_draw_cursor, al

; 29   : }

  0000f	c3		 ret	 0
?Timer_BlinkCursor@@YAXXZ ENDP				; Timer_BlinkCursor
_TEXT	ENDS
PUBLIC	?RunCursorBlinker@CI@@QAEXXZ			; CI::RunCursorBlinker
EXTRN	?Continue@C_TIMER2@@QAEXJ@Z:NEAR		; C_TIMER2::Continue
EXTRN	?Add@C_TIMER2@@QAEJKP6AXXZ@Z:NEAR		; C_TIMER2::Add
EXTRN	?gC_timer2@@3VC_TIMER2@@A:BYTE			; gC_timer2
; Function compile flags: /Ogty
;	COMDAT ?RunCursorBlinker@CI@@QAEXXZ
_TEXT	SEGMENT
?RunCursorBlinker@CI@@QAEXXZ PROC NEAR			; CI::RunCursorBlinker, COMDAT
; _this$ = ecx

; 39   : 	g_tid_cursor_blink = gC_timer2.Add(700, Timer_BlinkCursor);

  00000	68 00 00 00 00	 push	 OFFSET FLAT:?Timer_BlinkCursor@@YAXXZ ; Timer_BlinkCursor
  00005	68 bc 02 00 00	 push	 700			; 000002bcH
  0000a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?gC_timer2@@3VC_TIMER2@@A
  0000f	e8 00 00 00 00	 call	 ?Add@C_TIMER2@@QAEJKP6AXXZ@Z ; C_TIMER2::Add

; 40   : 	gC_timer2.Continue(g_tid_cursor_blink);

  00014	50		 push	 eax
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?gC_timer2@@3VC_TIMER2@@A
  0001a	a3 00 00 00 00	 mov	 DWORD PTR _g_tid_cursor_blink, eax
  0001f	e8 00 00 00 00	 call	 ?Continue@C_TIMER2@@QAEXJ@Z ; C_TIMER2::Continue

; 41   : }

  00024	c3		 ret	 0
?RunCursorBlinker@CI@@QAEXXZ ENDP			; CI::RunCursorBlinker
_TEXT	ENDS
PUBLIC	??1CI@@QAE@XZ					; CI::~CI
PUBLIC	?IsKorean@CI@@UAE_NXZ				; CI::IsKorean
PUBLIC	?IsChinese@CI@@UAE_NXZ				; CI::IsChinese
PUBLIC	?IsJapanese@CI@@UAE_NXZ				; CI::IsJapanese
PUBLIC	?IsEnglish@CI@@UAE_NXZ				; CI::IsEnglish
PUBLIC	?IME_MessageProcessor@CI@@UAEXIIJ@Z		; CI::IME_MessageProcessor
PUBLIC	??_7CI@@6B@					; CI::`vftable'
PUBLIC	??_R4CI@@6B@					; CI::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCI@@@8					; CI `RTTI Type Descriptor'
PUBLIC	??_R3CI@@8					; CI::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CI@@8					; CI::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CI@@8				; CI::`RTTI Base Class Descriptor at (0,-1,0,0)'
EXTRN	__purecall:NEAR
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_7CI@@6B@
CONST	SEGMENT
??_7CI@@6B@ DD	FLAT:??_R4CI@@6B@			; CI::`vftable'
	DD	FLAT:?IsKorean@CI@@UAE_NXZ
	DD	FLAT:?IsChinese@CI@@UAE_NXZ
	DD	FLAT:?IsJapanese@CI@@UAE_NXZ
	DD	FLAT:?IsEnglish@CI@@UAE_NXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?IME_MessageProcessor@CI@@UAEXIIJ@Z
CONST	ENDS
;	COMDAT ??_R4CI@@6B@
rdata$r	SEGMENT
??_R4CI@@6B@ DD	00H					; CI::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCI@@@8
	DD	FLAT:??_R3CI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCI@@@8
_DATA	SEGMENT
??_R0?AVCI@@@8 DD FLAT:??_7type_info@@6B@		; CI `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCI@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CI@@8
rdata$r	SEGMENT
??_R3CI@@8 DD	00H					; CI::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CI@@8
rdata$r	ENDS
;	COMDAT ??_R2CI@@8
rdata$r	SEGMENT
??_R2CI@@8 DD	FLAT:??_R1A@?0A@A@CI@@8			; CI::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CI@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CI@@8 DD FLAT:??_R0?AVCI@@@8		; CI::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Ogty
rdata$r	ENDS
;	COMDAT ??1CI@@QAE@XZ
_TEXT	SEGMENT
??1CI@@QAE@XZ PROC NEAR					; CI::~CI, COMDAT
; _this$ = ecx

; 60   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CI@@6B@

; 61   : 
; 62   : }

  00006	c3		 ret	 0
??1CI@@QAE@XZ ENDP					; CI::~CI
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\new - vs_ui\src\hangul\ci.h
_TEXT	ENDS
;	COMDAT ?IsKorean@CI@@UAE_NXZ
_TEXT	SEGMENT
?IsKorean@CI@@UAE_NXZ PROC NEAR				; CI::IsKorean, COMDAT
; _this$ = ecx

; 49   : 	virtual	bool	IsKorean()	{ return true; }

  00000	b0 01		 mov	 al, 1
  00002	c3		 ret	 0
?IsKorean@CI@@UAE_NXZ ENDP				; CI::IsKorean
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?IsChinese@CI@@UAE_NXZ
_TEXT	SEGMENT
?IsChinese@CI@@UAE_NXZ PROC NEAR			; CI::IsChinese, COMDAT
; _this$ = ecx

; 50   : 	virtual bool	IsChinese() { return false; }

  00000	32 c0		 xor	 al, al
  00002	c3		 ret	 0
?IsChinese@CI@@UAE_NXZ ENDP				; CI::IsChinese
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?IsJapanese@CI@@UAE_NXZ
_TEXT	SEGMENT
?IsJapanese@CI@@UAE_NXZ PROC NEAR			; CI::IsJapanese, COMDAT
; _this$ = ecx

; 51   : 	virtual bool	IsJapanese() { return false; }

  00000	32 c0		 xor	 al, al
  00002	c3		 ret	 0
?IsJapanese@CI@@UAE_NXZ ENDP				; CI::IsJapanese
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?IsEnglish@CI@@UAE_NXZ
_TEXT	SEGMENT
?IsEnglish@CI@@UAE_NXZ PROC NEAR			; CI::IsEnglish, COMDAT
; _this$ = ecx

; 52   : 	virtual bool	IsEnglish() { return false; }

  00000	32 c0		 xor	 al, al
  00002	c3		 ret	 0
?IsEnglish@CI@@UAE_NXZ ENDP				; CI::IsEnglish
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?IME_MessageProcessor@CI@@UAEXIIJ@Z
_TEXT	SEGMENT
_message$ = 8						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
?IME_MessageProcessor@CI@@UAEXIIJ@Z PROC NEAR		; CI::IME_MessageProcessor, COMDAT
; _this$ = ecx

; 80   : 	virtual void	IME_MessageProcessor(UINT message, WPARAM wParam, LPARAM lParam = 0){}

  00000	c2 0c 00	 ret	 12			; 0000000cH
?IME_MessageProcessor@CI@@UAEXIIJ@Z ENDP		; CI::IME_MessageProcessor
_TEXT	ENDS
PUBLIC	?IsEngInput@CI@@QBE_NXZ				; CI::IsEngInput
EXTRN	_ImmGetContext@4:NEAR
EXTRN	_ImmGetOpenStatus@4:NEAR
EXTRN	?g_hWnd@@3PAUHWND__@@A:DWORD			; g_hWnd
; Function compile flags: /Ogty
; File c:\darkeden\designed_common\project\new - vs_ui\src\hangul\ci.cpp
;	COMDAT ?IsEngInput@CI@@QBE_NXZ
_TEXT	SEGMENT
?IsEngInput@CI@@QBE_NXZ PROC NEAR			; CI::IsEngInput, COMDAT
; _this$ = ecx

; 71   : 	return !ImmGetOpenStatus(ImmGetContext(g_hWnd));

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 _ImmGetContext@4
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _ImmGetOpenStatus@4
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 72   : }

  00016	c3		 ret	 0
?IsEngInput@CI@@QBE_NXZ ENDP				; CI::IsEngInput
_TEXT	ENDS
PUBLIC	?ForceShowCursor@CI@@QBEXXZ			; CI::ForceShowCursor
EXTRN	?Refresh@C_TIMER2@@QAEXJ@Z:NEAR			; C_TIMER2::Refresh
; Function compile flags: /Ogty
;	COMDAT ?ForceShowCursor@CI@@QBEXXZ
_TEXT	SEGMENT
?ForceShowCursor@CI@@QBEXXZ PROC NEAR			; CI::ForceShowCursor, COMDAT
; _this$ = ecx

; 101  : 	gbl_draw_cursor = true;
; 102  : 	gC_timer2.Refresh(g_tid_cursor_blink);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_tid_cursor_blink
  00005	50		 push	 eax
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?gC_timer2@@3VC_TIMER2@@A
  0000b	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _gbl_draw_cursor, 1
  00012	e8 00 00 00 00	 call	 ?Refresh@C_TIMER2@@QAEXJ@Z ; C_TIMER2::Refresh

; 103  : }

  00017	c3		 ret	 0
?ForceShowCursor@CI@@QBEXXZ ENDP			; CI::ForceShowCursor
_TEXT	ENDS
PUBLIC	?GetCursorBlink@CI@@QBE_NXZ			; CI::GetCursorBlink
; Function compile flags: /Ogty
;	COMDAT ?GetCursorBlink@CI@@QBE_NXZ
_TEXT	SEGMENT
?GetCursorBlink@CI@@QBE_NXZ PROC NEAR			; CI::GetCursorBlink, COMDAT
; _this$ = ecx

; 112  : 	return gbl_draw_cursor;

  00000	a0 00 00 00 00	 mov	 al, BYTE PTR _gbl_draw_cursor

; 113  : }

  00005	c3		 ret	 0
?GetCursorBlink@CI@@QBE_NXZ ENDP			; CI::GetCursorBlink
_TEXT	ENDS
PUBLIC	?GetEndOfIME@CI@@QAE_NXZ			; CI::GetEndOfIME
; Function compile flags: /Ogty
;	COMDAT ?GetEndOfIME@CI@@QAE_NXZ
_TEXT	SEGMENT
?GetEndOfIME@CI@@QAE_NXZ PROC NEAR			; CI::GetEndOfIME, COMDAT
; _this$ = ecx

; 122  : 	bool state = m_bl_end_of_ime;

  00000	8a 41 05	 mov	 al, BYTE PTR [ecx+5]

; 123  : 	m_bl_end_of_ime = false;

  00003	c6 41 05 00	 mov	 BYTE PTR [ecx+5], 0

; 124  : 
; 125  : 	return state;
; 126  : }

  00007	c3		 ret	 0
?GetEndOfIME@CI@@QAE_NXZ ENDP				; CI::GetEndOfIME
_TEXT	ENDS
PUBLIC	?ClearCurrentIMEComposition@CI@@QAEXXZ		; CI::ClearCurrentIMEComposition
EXTRN	_ImmNotifyIME@16:NEAR
; Function compile flags: /Ogty
;	COMDAT ?ClearCurrentIMEComposition@CI@@QAEXXZ
_TEXT	SEGMENT
?ClearCurrentIMEComposition@CI@@QAEXXZ PROC NEAR	; CI::ClearCurrentIMEComposition, COMDAT
; _this$ = ecx

; 152  : 	ImmNotifyIME(ImmGetContext(g_hWnd), NI_COMPOSITIONSTR, CPS_CANCEL, 0);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  00005	6a 00		 push	 0
  00007	6a 04		 push	 4
  00009	6a 15		 push	 21			; 00000015H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _ImmGetContext@4
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 153  : }

  00017	c3		 ret	 0
?ClearCurrentIMEComposition@CI@@QAEXXZ ENDP		; CI::ClearCurrentIMEComposition
_TEXT	ENDS
PUBLIC	?IME_MessageProcessor@CI_KOREAN@@UAEXIIJ@Z	; CI_KOREAN::IME_MessageProcessor
EXTRN	?IME_StartComposition@@YAXXZ:NEAR		; IME_StartComposition
EXTRN	?IME_EndComposition@@YAXXZ:NEAR			; IME_EndComposition
EXTRN	?IME_Normal@@YAXIIJ@Z:NEAR			; IME_Normal
;	COMDAT ?pass@?1??IME_MessageProcessor@CI_KOREAN@@UAEXIIJ@Z@4HA
_BSS	SEGMENT
?pass@?1??IME_MessageProcessor@CI_KOREAN@@UAEXIIJ@Z@4HA DD 01H DUP (?) ; `CI_KOREAN::IME_MessageProcessor'::`2'::pass
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT ?IME_MessageProcessor@CI_KOREAN@@UAEXIIJ@Z
_TEXT	SEGMENT
_message$ = 8						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
?IME_MessageProcessor@CI_KOREAN@@UAEXIIJ@Z PROC NEAR	; CI_KOREAN::IME_MessageProcessor, COMDAT
; _this$ = ecx

; 162  : 	//pass 는 윸이란뒤에 아스키가 오면 0xc05d 식으로 뒷부분에 날라오는게 아스키 범위내의 코드가 날라와서 '윸D'이런식으로 된다.
; 163  : 	//그걸 방지하기위해 endcomposition이후에 오는 wm_char두개를 무시하게 했는데
; 164  : 	//그러고 나니 e5코드가 들어오지 않는다.
; 165  : 	static int pass = 0;
; 166  : 	
; 167  : 	//이건 웈기 식으로 end안거칠때의 처리
; 168  : 	if(message == WM_CHAR && m_bl_ime_running)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _message$[esp-4]
  00004	81 fa 02 01 00
	00		 cmp	 edx, 258		; 00000102H
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	75 0b		 jne	 SHORT $L81292
  0000f	8a 46 06	 mov	 al, BYTE PTR [esi+6]
  00012	84 c0		 test	 al, al
  00014	0f 85 c1 00 00
	00		 jne	 $L81295
$L81292:

; 169  : 		return;
; 170  : 
; 171  : 	//아래에서 e5코드가 있는경우는 미리 pass--를 해주므로 0xe5가 혹시나? 들어올 경우는 처리하지 않는다.
; 172  : 	//lParam이 1일경우가 ime에서 나오는 WM_CHAR메세지다
; 173  : 	if(pass > 0 && message == WM_CHAR && wParam != 0xe5 && lParam == 1)

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pass@?1??IME_MessageProcessor@CI_KOREAN@@UAEXIIJ@Z@4HA
  0001f	85 c0		 test	 eax, eax
  00021	8b 4c 24 0c	 mov	 ecx, DWORD PTR _wParam$[esp]
  00025	53		 push	 ebx
  00026	8b 5c 24 14	 mov	 ebx, DWORD PTR _lParam$[esp+4]
  0002a	7e 20		 jle	 SHORT $L81685
  0002c	81 fa 02 01 00
	00		 cmp	 edx, 258		; 00000102H
  00032	75 18		 jne	 SHORT $L81685
  00034	81 f9 e5 00 00
	00		 cmp	 ecx, 229		; 000000e5H
  0003a	74 10		 je	 SHORT $L81685
  0003c	83 fb 01	 cmp	 ebx, 1
  0003f	75 0b		 jne	 SHORT $L81685

; 174  : 	{
; 175  : 		pass--;

  00041	48		 dec	 eax
  00042	5b		 pop	 ebx
  00043	a3 00 00 00 00	 mov	 DWORD PTR ?pass@?1??IME_MessageProcessor@CI_KOREAN@@UAEXIIJ@Z@4HA, eax
  00048	5e		 pop	 esi

; 219  : 			break;
; 220  : 	}
; 221  : }

  00049	c2 0c 00	 ret	 12			; 0000000cH
$L81685:

; 176  : 		return;
; 177  : 	}
; 178  : 
; 179  : 
; 180  : 	switch (message)

  0004c	8b c2		 mov	 eax, edx
  0004e	2d 0d 01 00 00	 sub	 eax, 269		; 0000010dH
  00053	74 78		 je	 SHORT $L81298
  00055	48		 dec	 eax
  00056	74 38		 je	 SHORT $L81299
  00058	48		 dec	 eax
  00059	74 10		 je	 SHORT $L81302

; 215  : 			break;
; 216  : 			
; 217  : 		default:
; 218  : 			IME_Normal(message, wParam, lParam);

  0005b	53		 push	 ebx
  0005c	51		 push	 ecx
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 ?IME_Normal@@YAXIIJ@Z	; IME_Normal
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	5b		 pop	 ebx
  00067	5e		 pop	 esi

; 219  : 			break;
; 220  : 	}
; 221  : }

  00068	c2 0c 00	 ret	 12			; 0000000cH
$L81302:

; 201  : 			}
; 202  : 			break;
; 203  : 
; 204  : 		case WM_IME_COMPOSITION:
; 205  : 			//
; 206  : 			// wParam의 상하위 byte 위치를 바꿔야 정상적으로 출력된다.
; 207  : 			//
; 208  : 			m_composing_char[0] = (char_t)(wParam<<8);
; 209  : 			m_composing_char[0] |= (char_t)((wParam>>8)&0x00FF);
; 210  : 			
; 211  : 			if ((lParam&GCS_COMPSTR) == 0)

  0006b	f6 c3 08	 test	 bl, 8
  0006e	66 0f b6 c5	 movzx	 ax, ch
  00072	8a e1		 mov	 ah, cl

; 212  : 				IME_NextComposition();

  00074	8b ce		 mov	 ecx, esi
  00076	66 89 46 0a	 mov	 WORD PTR [esi+10], ax
  0007a	75 0a		 jne	 SHORT $L81305
  0007c	8b 16		 mov	 edx, DWORD PTR [esi]
  0007e	ff 52 10	 call	 DWORD PTR [edx+16]
  00081	5b		 pop	 ebx
  00082	5e		 pop	 esi

; 219  : 			break;
; 220  : 	}
; 221  : }

  00083	c2 0c 00	 ret	 12			; 0000000cH
$L81305:

; 213  : 			else
; 214  : 				IME_Composition();

  00086	8b 06		 mov	 eax, DWORD PTR [esi]
  00088	ff 50 14	 call	 DWORD PTR [eax+20]
  0008b	5b		 pop	 ebx
  0008c	5e		 pop	 esi

; 219  : 			break;
; 220  : 	}
; 221  : }

  0008d	c2 0c 00	 ret	 12			; 0000000cH
$L81299:

; 186  : 			break;
; 187  : 
; 188  : 		case WM_IME_ENDCOMPOSITION:
; 189  : 			m_bl_end_of_ime = true;

  00090	c6 46 05 01	 mov	 BYTE PTR [esi+5], 1

; 190  : 			m_bl_ime_running = false;

  00094	c6 46 06 00	 mov	 BYTE PTR [esi+6], 0

; 191  : 			IME_EndComposition();

  00098	e8 00 00 00 00	 call	 ?IME_EndComposition@@YAXXZ ; IME_EndComposition

; 192  : 
; 193  : 			//만들던 글자가 있으면
; 194  : 			if(m_composing_char[0])

  0009d	0f b7 76 0a	 movzx	 esi, WORD PTR [esi+10]
  000a1	66 85 f6	 test	 si, si
  000a4	74 34		 je	 SHORT $L81686

; 195  : 			{
; 196  : 				pass = 2;
; 197  : 				
; 198  : 				//위에서 말한 e5코드는 wm_char로 들어오지 않으므로 여기서 pass를 줄여준다
; 199  : 				if((m_composing_char[0] & 0xff00) == 0xe500)

  000a6	81 e6 00 ff 00
	00		 and	 esi, 65280		; 0000ff00H
  000ac	81 fe 00 e5 00
	00		 cmp	 esi, 58624		; 0000e500H
  000b2	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?pass@?1??IME_MessageProcessor@CI_KOREAN@@UAEXIIJ@Z@4HA, 2
  000bc	75 1c		 jne	 SHORT $L81686
  000be	5b		 pop	 ebx

; 200  : 					pass--;

  000bf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?pass@?1??IME_MessageProcessor@CI_KOREAN@@UAEXIIJ@Z@4HA, 1
  000c9	5e		 pop	 esi

; 219  : 			break;
; 220  : 	}
; 221  : }

  000ca	c2 0c 00	 ret	 12			; 0000000cH
$L81298:

; 181  : 	{
; 182  : 		case WM_IME_STARTCOMPOSITION:
; 183  : 			m_bl_end_of_ime = false;

  000cd	c6 46 05 00	 mov	 BYTE PTR [esi+5], 0

; 184  : 			m_bl_ime_running = true;

  000d1	c6 46 06 01	 mov	 BYTE PTR [esi+6], 1

; 185  : 			IME_StartComposition();

  000d5	e8 00 00 00 00	 call	 ?IME_StartComposition@@YAXXZ ; IME_StartComposition
$L81686:
  000da	5b		 pop	 ebx
$L81295:
  000db	5e		 pop	 esi

; 219  : 			break;
; 220  : 	}
; 221  : }

  000dc	c2 0c 00	 ret	 12			; 0000000cH
?IME_MessageProcessor@CI_KOREAN@@UAEXIIJ@Z ENDP		; CI_KOREAN::IME_MessageProcessor
_TEXT	ENDS
PUBLIC	?IME_MessageProcessor@CI_CHINESE@@UAEXIIJ@Z	; CI_CHINESE::IME_MessageProcessor
EXTRN	_ImmGetDefaultIMEWnd@4:NEAR
EXTRN	__imp__SetFocus@4:NEAR
EXTRN	_ImmReleaseContext@8:NEAR
EXTRN	_ImmGetCompositionStringA@16:NEAR
EXTRN	?gbl_skip_escape@@3_NA:BYTE			; gbl_skip_escape
EXTRN	__imp__ShowWindow@8:NEAR
EXTRN	?SetAcquire@CDirectInput@@QAEJ_N@Z:NEAR		; CDirectInput::SetAcquire
EXTRN	?g_pDXInput@@3PAVCDirectInput@@A:DWORD		; g_pDXInput
; Function compile flags: /Ogty
;	COMDAT ?IME_MessageProcessor@CI_CHINESE@@UAEXIIJ@Z
_TEXT	SEGMENT
_message$ = 8						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
?IME_MessageProcessor@CI_CHINESE@@UAEXIIJ@Z PROC NEAR	; CI_CHINESE::IME_MessageProcessor, COMDAT
; _this$ = ecx

; 229  : {

  00000	55		 push	 ebp

; 230  : 	int len;
; 231  : 	if(wParam == 0xe5) return;

  00001	8b 6c 24 0c	 mov	 ebp, DWORD PTR _wParam$[esp]
  00005	81 fd e5 00 00
	00		 cmp	 ebp, 229		; 000000e5H
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	0f 84 10 01 00
	00		 je	 $L81320
  00014	53		 push	 ebx

; 232  : 	
; 233  : 	//이건 웈기 식으로 end안거칠때의 처리
; 234  : 	if(message == WM_CHAR && ImeRunning())

  00015	8b 5c 24 10	 mov	 ebx, DWORD PTR _message$[esp+8]
  00019	81 fb 02 01 00
	00		 cmp	 ebx, 258		; 00000102H
  0001f	75 0b		 jne	 SHORT $L81316
  00021	8a 46 06	 mov	 al, BYTE PTR [esi+6]
  00024	84 c0		 test	 al, al
  00026	0f 85 f7 00 00
	00		 jne	 $L81695
$L81316:

; 235  : 		return;
; 236  : 	
; 237  : 	HIMC m_hIMC=NULL;
; 238  : 	HWND ImehWnd=ImmGetDefaultIMEWnd(g_hWnd);

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  00031	57		 push	 edi
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _ImmGetDefaultIMEWnd@4
  00038	8b f8		 mov	 edi, eax

; 239  : 				
; 240  : 	switch (message)

  0003a	8b c3		 mov	 eax, ebx
  0003c	2d 0d 01 00 00	 sub	 eax, 269		; 0000010dH
  00041	0f 84 9d 00 00
	00		 je	 $L81323
  00047	48		 dec	 eax
  00048	0f 84 8a 00 00
	00		 je	 $L81324
  0004e	48		 dec	 eax
  0004f	74 16		 je	 SHORT $L81325

; 278  : 		break;			
; 279  : 	default:
; 280  : 		IME_Normal(message, wParam, lParam);

  00051	8b 4c 24 1c	 mov	 ecx, DWORD PTR _lParam$[esp+12]
  00055	51		 push	 ecx
  00056	55		 push	 ebp
  00057	53		 push	 ebx
  00058	e8 00 00 00 00	 call	 ?IME_Normal@@YAXIIJ@Z	; IME_Normal
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	5f		 pop	 edi
  00061	5b		 pop	 ebx
  00062	5e		 pop	 esi
  00063	5d		 pop	 ebp

; 281  : 		break;
; 282  : 	}	
; 283  : }

  00064	c2 0c 00	 ret	 12			; 0000000cH
$L81325:

; 260  : 		break;
; 261  : 	case WM_IME_COMPOSITION:			
; 262  : 		//			SetGapEscape();
; 263  : 		gbl_skip_escape = true;
; 264  : 		m_hIMC = ImmGetContext(g_hWnd);

  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  0006d	52		 push	 edx
  0006e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?gbl_skip_escape@@3_NA, 1 ; gbl_skip_escape
  00075	e8 00 00 00 00	 call	 _ImmGetContext@4
  0007a	8b d8		 mov	 ebx, eax

; 265  : 		if(lParam & GCS_RESULTSTR)

  0007c	8b 44 24 1c	 mov	 eax, DWORD PTR _lParam$[esp+12]
  00080	f6 c4 08	 test	 ah, 8
  00083	74 3f		 je	 SHORT $L81327

; 266  : 		{
; 267  : 			if ((len = ImmGetCompositionString(m_hIMC, GCS_RESULTSTR, NULL, 0)) > 0)

  00085	6a 00		 push	 0
  00087	6a 00		 push	 0
  00089	68 00 08 00 00	 push	 2048			; 00000800H
  0008e	53		 push	 ebx
  0008f	e8 00 00 00 00	 call	 _ImmGetCompositionStringA@16
  00094	8b e8		 mov	 ebp, eax
  00096	85 ed		 test	 ebp, ebp
  00098	7e 2a		 jle	 SHORT $L81327

; 268  : 			{
; 269  : 				//					SetStartComposition();
; 270  : 				ImmGetCompositionString(m_hIMC, GCS_RESULTSTR,m_composing_string, len);

  0009a	55		 push	 ebp
  0009b	8d 7e 0e	 lea	 edi, DWORD PTR [esi+14]
  0009e	57		 push	 edi
  0009f	68 00 08 00 00	 push	 2048			; 00000800H
  000a4	53		 push	 ebx
  000a5	e8 00 00 00 00	 call	 _ImmGetCompositionStringA@16

; 271  : 				m_composing_string[len] = NULL;

  000aa	c6 44 2e 0e 00	 mov	 BYTE PTR [esi+ebp+14], 0

; 272  : 				IME_NextComposition();

  000af	8b 06		 mov	 eax, DWORD PTR [esi]
  000b1	8b ce		 mov	 ecx, esi
  000b3	ff 50 10	 call	 DWORD PTR [eax+16]

; 273  : 				memset(m_composing_string,0,sizeof(m_composing_string));

  000b6	33 c0		 xor	 eax, eax
  000b8	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  000bd	f3 ab		 rep stosd

; 274  : 				gbl_skip_escape = false;

  000bf	a2 00 00 00 00	 mov	 BYTE PTR ?gbl_skip_escape@@3_NA, al ; gbl_skip_escape
$L81327:

; 275  : 			}				
; 276  : 		} 
; 277  : 		ImmReleaseContext(g_hWnd,m_hIMC);

  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  000ca	53		 push	 ebx
  000cb	51		 push	 ecx
  000cc	e8 00 00 00 00	 call	 _ImmReleaseContext@8
  000d1	5f		 pop	 edi
  000d2	5b		 pop	 ebx
  000d3	5e		 pop	 esi
  000d4	5d		 pop	 ebp

; 281  : 		break;
; 282  : 	}	
; 283  : }

  000d5	c2 0c 00	 ret	 12			; 0000000cH
$L81324:

; 250  : 		
; 251  : 		//			SetStartComposition();
; 252  : 		//			IME_StartComposition();
; 253  : 		//			SetGapEscape();
; 254  : 		break;
; 255  : 	case WM_IME_ENDCOMPOSITION:
; 256  : 		//			if(ImeRunning() || !m_bl_end_of_ime)
; 257  : 		//				SetGapEscape();
; 258  : 		//			SetEndComposition();
; 259  : 		IME_EndComposition();

  000d8	e8 00 00 00 00	 call	 ?IME_EndComposition@@YAXXZ ; IME_EndComposition
  000dd	5f		 pop	 edi
  000de	5b		 pop	 ebx
  000df	5e		 pop	 esi
  000e0	5d		 pop	 ebp

; 281  : 		break;
; 282  : 	}	
; 283  : }

  000e1	c2 0c 00	 ret	 12			; 0000000cH
$L81323:

; 241  : 	{
; 242  : 	case WM_IME_STARTCOMPOSITION:
; 243  : 		// When focus change, enter garbage value in input buffer.
; 244  : 		gbl_skip_escape = true;
; 245  : 		g_pDXInput->SetAcquire(false);

  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pDXInput@@3PAVCDirectInput@@A ; g_pDXInput
  000ea	6a 00		 push	 0
  000ec	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?gbl_skip_escape@@3_NA, 1 ; gbl_skip_escape
  000f3	e8 00 00 00 00	 call	 ?SetAcquire@CDirectInput@@QAEJ_N@Z ; CDirectInput::SetAcquire

; 246  : 		ShowWindow( ImehWnd , SW_HIDE );

  000f8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ShowWindow@8
  000fe	6a 00		 push	 0
  00100	57		 push	 edi
  00101	ff d6		 call	 esi

; 247  : 		ShowWindow( ImehWnd , SW_SHOWNORMAL );

  00103	6a 01		 push	 1
  00105	57		 push	 edi
  00106	ff d6		 call	 esi

; 248  : 		SetFocus(g_hWnd);

  00108	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  0010e	52		 push	 edx
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 249  : 		g_pDXInput->SetAcquire(true);

  00115	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pDXInput@@3PAVCDirectInput@@A ; g_pDXInput
  0011b	6a 01		 push	 1
  0011d	e8 00 00 00 00	 call	 ?SetAcquire@CDirectInput@@QAEJ_N@Z ; CDirectInput::SetAcquire
  00122	5f		 pop	 edi
$L81695:
  00123	5b		 pop	 ebx
$L81320:
  00124	5e		 pop	 esi
  00125	5d		 pop	 ebp

; 281  : 		break;
; 282  : 	}	
; 283  : }

  00126	c2 0c 00	 ret	 12			; 0000000cH
?IME_MessageProcessor@CI_CHINESE@@UAEXIIJ@Z ENDP	; CI_CHINESE::IME_MessageProcessor
_TEXT	ENDS
PUBLIC	?IMEObjectConvert@CI_JAPAN@@QAEXPAGAAH@Z	; CI_JAPAN::IMEObjectConvert
EXTRN	__imp__WideCharToMultiByte@32:NEAR
; Function compile flags: /Ogty
;	COMDAT ?IMEObjectConvert@CI_JAPAN@@QAEXPAGAAH@Z
_TEXT	SEGMENT
_StrIMEWide$ = 8					; size = 4
_StrIMEWideSize$ = 12					; size = 4
?IMEObjectConvert@CI_JAPAN@@QAEXPAGAAH@Z PROC NEAR	; CI_JAPAN::IMEObjectConvert, COMDAT
; _this$ = ecx

; 287  : {

  00000	53		 push	 ebx

; 288  : 	//===============================================================================================================
; 289  : 	int		StrIMESize = WideCharToMultiByte(932 , 0, StrIMEWide, StrIMEWideSize, NULL, 0, NULL, NULL)	;

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _StrIMEWideSize$[esp]
  00005	8b 03		 mov	 eax, DWORD PTR [ebx]
  00007	55		 push	 ebp
  00008	8b 6c 24 0c	 mov	 ebp, DWORD PTR _StrIMEWide$[esp+4]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	50		 push	 eax
  00017	55		 push	 ebp
  00018	6a 00		 push	 0
  0001a	68 a4 03 00 00	 push	 932			; 000003a4H
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 290  : 	WideCharToMultiByte(932 , 0, StrIMEWide, StrIMEWideSize, m_composing_string, StrIMESize, NULL, NULL)			;

  00027	8b 13		 mov	 edx, DWORD PTR [ebx]
  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	8b f0		 mov	 esi, eax
  0002f	56		 push	 esi
  00030	8d 4f 0e	 lea	 ecx, DWORD PTR [edi+14]
  00033	51		 push	 ecx
  00034	52		 push	 edx
  00035	55		 push	 ebp
  00036	6a 00		 push	 0
  00038	68 a4 03 00 00	 push	 932			; 000003a4H
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 291  : 	
; 292  : 	int len = StrIMESize ; 
; 293  : 	memset(m_composing_string +  len , 0 , sizeof(m_composing_string) - len ) ; 

  00043	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00048	2b ce		 sub	 ecx, esi
  0004a	8b d1		 mov	 edx, ecx
  0004c	8d 7c 3e 0e	 lea	 edi, DWORD PTR [esi+edi+14]
  00050	c1 e9 02	 shr	 ecx, 2
  00053	33 c0		 xor	 eax, eax
  00055	f3 ab		 rep stosd
  00057	8b ca		 mov	 ecx, edx
  00059	83 e1 03	 and	 ecx, 3
  0005c	f3 aa		 rep stosb
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5d		 pop	 ebp
  00061	5b		 pop	 ebx

; 294  : 	//===============================================================================================================
; 295  : }

  00062	c2 08 00	 ret	 8
?IMEObjectConvert@CI_JAPAN@@QAEXPAGAAH@Z ENDP		; CI_JAPAN::IMEObjectConvert
_TEXT	ENDS
PUBLIC	?SetJapanInput@CI@@QAEXXZ			; CI::SetJapanInput
; Function compile flags: /Ogty
;	COMDAT ?SetJapanInput@CI@@QAEXXZ
_TEXT	SEGMENT
?SetJapanInput@CI@@QAEXXZ PROC NEAR			; CI::SetJapanInput, COMDAT
; _this$ = ecx

; 474  : //	HIMC hIMC = ::ImmGetContext ( g_hWnd ) ;
; 475  :   //  ::ImmSetConversionStatus ( hIMC,29, 8 ) ;
; 476  :     //::ImmReleaseContext ( g_hWnd, hIMC ) ;
; 477  : //	m_bCompsition		= false ; 
; 478  : }

  00000	c3		 ret	 0
?SetJapanInput@CI@@QAEXXZ ENDP				; CI::SetJapanInput
_TEXT	ENDS
PUBLIC	?FinishImeRunning@CI@@QAEXXZ			; CI::FinishImeRunning
; Function compile flags: /Ogty
;	COMDAT ?FinishImeRunning@CI@@QAEXXZ
_TEXT	SEGMENT
?FinishImeRunning@CI@@QAEXXZ PROC NEAR			; CI::FinishImeRunning, COMDAT
; _this$ = ecx

; 87   : 	ClearCurrentIMEComposition();

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  00005	56		 push	 esi
  00006	6a 00		 push	 0
  00008	6a 04		 push	 4
  0000a	6a 15		 push	 21			; 00000015H
  0000c	50		 push	 eax
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 _ImmGetContext@4
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 88   : 	m_bl_ime_running = false;

  0001a	c6 46 06 00	 mov	 BYTE PTR [esi+6], 0
  0001e	5e		 pop	 esi

; 89   : 
; 90   : 	//SendMessage(g_hWnd, WM_IME_ENDCOMPOSITION, 0, 0);
; 91   : 	//SendMessage(CDirectDraw::GetHwnd(), WM_KEYDOWN, VK_LEFT, 0);
; 92   : }

  0001f	c3		 ret	 0
?FinishImeRunning@CI@@QAEXXZ ENDP			; CI::FinishImeRunning
_TEXT	ENDS
PUBLIC	?Init@CI@@QAEXXZ				; CI::Init
; Function compile flags: /Ogty
;	COMDAT ?Init@CI@@QAEXXZ
_TEXT	SEGMENT
?Init@CI@@QAEXXZ PROC NEAR				; CI::Init, COMDAT
; _this$ = ecx

; 135  : 	m_composing_char[0] = 0;

  00000	33 c0		 xor	 eax, eax

; 136  : 	m_composing_char[1] = 0;
; 137  : 	m_bl_insert_mode = true;
; 138  : 	m_bl_end_of_ime = false;
; 139  : 	m_bl_ime_running = false;
; 140  : 	m_bCompositionMode	= false ;
; 141  : 
; 142  : 	ClearCurrentIMEComposition();

  00002	50		 push	 eax
  00003	6a 04		 push	 4
  00005	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax
  00009	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax
  0000d	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1
  00011	88 41 05	 mov	 BYTE PTR [ecx+5], al
  00014	88 41 06	 mov	 BYTE PTR [ecx+6], al
  00017	88 41 08	 mov	 BYTE PTR [ecx+8], al
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  0001f	6a 15		 push	 21			; 00000015H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _ImmGetContext@4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 143  : }

  0002d	c3		 ret	 0
?Init@CI@@QAEXXZ ENDP					; CI::Init
_TEXT	ENDS
PUBLIC	?IME_MessageProcessor@CI_JAPAN@@UAEXIIJ@Z	; CI_JAPAN::IME_MessageProcessor
EXTRN	_ImmGetCompositionStringW@16:NEAR
EXTRN	_free:NEAR
EXTRN	__imp__MultiByteToWideChar@24:NEAR
EXTRN	_malloc:NEAR
;	COMDAT ?iBeforeLen@?CG@??IME_MessageProcessor@CI_JAPAN@@UAEXIIJ@Z@4HA
_BSS	SEGMENT
?iBeforeLen@?CG@??IME_MessageProcessor@CI_JAPAN@@UAEXIIJ@Z@4HA DD 01H DUP (?) ; `CI_JAPAN::IME_MessageProcessor'::`38'::iBeforeLen
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT ?IME_MessageProcessor@CI_JAPAN@@UAEXIIJ@Z
_TEXT	SEGMENT
_temp$81390 = -8					; size = 4
_StrIMEWideSize$81359 = -8				; size = 4
_StrIMEWideSize$81393 = -4				; size = 4
_StrIMEWideSize$81381 = -4				; size = 4
_ImehWnd$ = -4						; size = 4
_StrIMEWide$81370 = 8					; size = 2
_message$ = 8						; size = 4
_wParam$ = 12						; size = 4
_StrIMEWideSize$81371 = 16				; size = 4
_lParam$ = 16						; size = 4
?IME_MessageProcessor@CI_JAPAN@@UAEXIIJ@Z PROC NEAR	; CI_JAPAN::IME_MessageProcessor, COMDAT
; _this$ = ecx

; 298  : 	
; 299  : 	//char		composing_string[128];
; 300  : 	//char	temp ;
; 301  : 
; 302  : 	//std::wstring		m_input;
; 303  : 
; 304  : 	//char str[2048];
; 305  : 	
; 306  : 	int len;
; 307  : 	if(wParam == 0xe5) 

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _wParam$[esp-4]
  00004	83 ec 08	 sub	 esp, 8
  00007	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx
  0000f	0f 84 e8 03 00
	00		 je	 $L81363
  00015	57		 push	 edi

; 308  : 		return;
; 309  : 	
; 310  : 	//이건 웈기 식으로 end안거칠때의 처리
; 311  : 	if(message == WM_CHAR && ImeRunning())

  00016	8b 7c 24 14	 mov	 edi, DWORD PTR _message$[esp+12]
  0001a	81 ff 02 01 00
	00		 cmp	 edi, 258		; 00000102H
  00020	75 0b		 jne	 SHORT $L81344
  00022	8a 46 06	 mov	 al, BYTE PTR [esi+6]
  00025	84 c0		 test	 al, al
  00027	0f 85 cf 03 00
	00		 jne	 $L81740
$L81344:

; 312  : 		return;
; 313  : 	
; 314  : 	HIMC m_hIMC=NULL;
; 315  : 	HWND ImehWnd=ImmGetDefaultIMEWnd(g_hWnd);

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  00032	53		 push	 ebx
  00033	55		 push	 ebp
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _ImmGetDefaultIMEWnd@4
  0003a	8b e8		 mov	 ebp, eax

; 316  : 
; 317  : 	
; 318  : 	// 229 , 256
; 319  : 	// Japan Language keyboade half , full world , hiragane , kataka convert key , hanka , etc convert key process logic
; 320  : 	if(((wParam == 244  || wParam == 243 || wParam == 240)  &&  message == 257)  ||
; 321  : 		((wParam == 256)  &&  message == 257) ||
; 322  : 		((wParam == 28)  &&  message == 257  && !gC_ci->IsEngInput())
; 323  : 	)

  0003c	8b 44 24 20	 mov	 eax, DWORD PTR _wParam$[esp+20]
  00040	3d f4 00 00 00	 cmp	 eax, 244		; 000000f4H
  00045	89 6c 24 14	 mov	 DWORD PTR _ImehWnd$[esp+24], ebp
  00049	74 0e		 je	 SHORT $L81350
  0004b	3d f3 00 00 00	 cmp	 eax, 243		; 000000f3H
  00050	74 07		 je	 SHORT $L81350
  00052	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  00057	75 08		 jne	 SHORT $L81349
$L81350:
  00059	81 ff 01 01 00
	00		 cmp	 edi, 257		; 00000101H
  0005f	74 40		 je	 SHORT $L81734
$L81349:
  00061	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00066	75 0d		 jne	 SHORT $L81351
  00068	81 ff 01 01 00
	00		 cmp	 edi, 257		; 00000101H
  0006e	74 46		 je	 SHORT $L81731
  00070	e9 e2 00 00 00	 jmp	 $L81736
$L81351:
  00075	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  00078	0f 85 d9 00 00
	00		 jne	 $L81736
  0007e	81 ff 01 01 00
	00		 cmp	 edi, 257		; 00000101H
  00084	0f 85 cd 00 00
	00		 jne	 $L81736
  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gC_ci@@3PAVCI@@A ; gC_ci
  00090	e8 00 00 00 00	 call	 ?IsEngInput@CI@@QBE_NXZ	; CI::IsEngInput
  00095	84 c0		 test	 al, al
  00097	0f 85 b6 00 00
	00		 jne	 $L81735
  0009d	8b 44 24 20	 mov	 eax, DWORD PTR _wParam$[esp+20]
$L81734:

; 324  : 	{
; 325  : 		if(wParam == 240 || wParam == 28)
; 326  : 		{
; 327  : 		}
; 328  : 
; 329  : 		if(!(wParam == 28) && message == 257 && !gC_ci->IsEngInput())

  000a1	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  000a4	0f 84 ad 00 00
	00		 je	 $L81736
  000aa	81 ff 01 01 00
	00		 cmp	 edi, 257		; 00000101H
  000b0	0f 85 a1 00 00
	00		 jne	 $L81736
$L81731:
  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 _ImmGetContext@4
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _ImmGetOpenStatus@4
  000c8	85 c0		 test	 eax, eax
  000ca	0f 84 83 00 00
	00		 je	 $L81735

; 330  : 		{
; 331  : 			m_hIMC = ImmGetContext(g_hWnd);	

  000d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  000d6	52		 push	 edx
  000d7	e8 00 00 00 00	 call	 _ImmGetContext@4

; 332  : 			if ((len = ImmGetCompositionStringW(m_hIMC, GCS_COMPSTR, NULL, 0)) > 0)

  000dc	6a 00		 push	 0
  000de	6a 00		 push	 0
  000e0	8b d8		 mov	 ebx, eax
  000e2	6a 08		 push	 8
  000e4	53		 push	 ebx
  000e5	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  000ea	8b f8		 mov	 edi, eax
  000ec	85 ff		 test	 edi, edi
  000ee	7e 63		 jle	 SHORT $L81735

; 333  : 			{
; 334  : 				
; 335  : 				wchar_t* temp = (wchar_t*)malloc(len*sizeof(wchar_t));

  000f0	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _malloc
  000f9	83 c4 04	 add	 esp, 4

; 336  : 				ImmGetCompositionStringW(m_hIMC, GCS_COMPSTR, temp, len);

  000fc	57		 push	 edi
  000fd	8b e8		 mov	 ebp, eax
  000ff	55		 push	 ebp
  00100	6a 08		 push	 8
  00102	53		 push	 ebx
  00103	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16

; 337  : 				
; 338  : 				int		 StrIMEWideSize = len  /sizeof(wchar_t) ; 
; 339  : 				IMEObjectConvert(temp , StrIMEWideSize )	;

  00108	8d 4c 24 10	 lea	 ecx, DWORD PTR _StrIMEWideSize$81359[esp+24]
  0010c	51		 push	 ecx
  0010d	d1 ef		 shr	 edi, 1
  0010f	55		 push	 ebp
  00110	8b ce		 mov	 ecx, esi
  00112	89 7c 24 18	 mov	 DWORD PTR _StrIMEWideSize$81359[esp+32], edi
  00116	e8 00 00 00 00	 call	 ?IMEObjectConvert@CI_JAPAN@@QAEXPAGAAH@Z ; CI_JAPAN::IMEObjectConvert

; 340  : 				int tempSize = ImmGetCompositionStringW(m_hIMC, GCS_COMPSTR, NULL, 0);

  0011b	6a 00		 push	 0
  0011d	6a 00		 push	 0
  0011f	6a 08		 push	 8
  00121	53		 push	 ebx
  00122	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16

; 341  : 
; 342  : 				IME_NextComposition();

  00127	8b 16		 mov	 edx, DWORD PTR [esi]
  00129	8b ce		 mov	 ecx, esi
  0012b	ff 52 10	 call	 DWORD PTR [edx+16]

; 343  : 				memset(m_composing_string,0,sizeof(m_composing_string));

  0012e	33 c0		 xor	 eax, eax
  00130	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00135	8d 7e 0e	 lea	 edi, DWORD PTR [esi+14]
  00138	f3 ab		 rep stosd

; 344  : 				gbl_skip_escape = false;
; 345  : 				FinishImeRunning() ; 

  0013a	8b ce		 mov	 ecx, esi
  0013c	a2 00 00 00 00	 mov	 BYTE PTR ?gbl_skip_escape@@3_NA, al ; gbl_skip_escape
  00141	e8 00 00 00 00	 call	 ?FinishImeRunning@CI@@QAEXXZ ; CI::FinishImeRunning

; 346  : 				free(temp);

  00146	55		 push	 ebp
  00147	e8 00 00 00 00	 call	 _free
  0014c	8b 6c 24 18	 mov	 ebp, DWORD PTR _ImehWnd$[esp+28]
  00150	83 c4 04	 add	 esp, 4
$L81735:
  00153	8b 44 24 20	 mov	 eax, DWORD PTR _wParam$[esp+20]
$L81736:

; 347  : 			}
; 348  : 		}
; 349  : 		
; 350  : 	}
; 351  : 
; 352  : 
; 353  : 	switch (message)

  00157	8b 4c 24 1c	 mov	 ecx, DWORD PTR _message$[esp+20]
  0015b	81 c1 fe fe ff
	ff		 add	 ecx, -258		; fffffefeH
  00161	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00164	0f 87 7d 02 00
	00		 ja	 $L81397
  0016a	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $L81732[ecx]
  00171	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L81744[ecx*4]
$L81366:

; 354  : 	{
; 355  : 		
; 356  : 	case WM_CHAR : 
; 357  : 		{	
; 358  : 			if(wParam == 130 
; 359  : #if __CONTENTS(__JAPAN_UI)
; 360  : 				|| lParam == 1
; 361  : #endif //__JAPAN_UI
; 362  : 				) 

  00178	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  0017d	0f 84 77 02 00
	00		 je	 $L81741

; 363  : 			{
; 364  : 				return ; 
; 365  : 
; 366  : 			}
; 367  : 			else if((wParam > 31) && !m_bCompsition)

  00183	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00186	0f 86 6e 02 00
	00		 jbe	 $L81741
  0018c	8a 46 07	 mov	 al, BYTE PTR [esi+7]
  0018f	84 c0		 test	 al, al
  00191	0f 85 63 02 00
	00		 jne	 $L81741

; 368  : 			{				
; 369  : 				m_hIMC = ImmGetContext(g_hWnd);

  00197	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  0019d	52		 push	 edx
  0019e	e8 00 00 00 00	 call	 _ImmGetContext@4

; 370  : 				//===============================================================================================================
; 371  : 				wchar_t StrIMEWide				; 
; 372  : 				int		StrIMEWideSize	=	1	;

  001a3	bb 01 00 00 00	 mov	 ebx, 1

; 373  : 				//===============================================================================================================
; 374  : 				MultiByteToWideChar(932 , 0, (char*)&wParam , 1, &StrIMEWide, StrIMEWideSize)	;

  001a8	53		 push	 ebx
  001a9	8d 44 24 20	 lea	 eax, DWORD PTR _StrIMEWide$81370[esp+24]
  001ad	50		 push	 eax
  001ae	53		 push	 ebx
  001af	8d 4c 24 2c	 lea	 ecx, DWORD PTR _wParam$[esp+32]
  001b3	51		 push	 ecx
  001b4	6a 00		 push	 0
  001b6	68 a4 03 00 00	 push	 932			; 000003a4H
  001bb	89 5c 24 3c	 mov	 DWORD PTR _StrIMEWideSize$81371[esp+44], ebx
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 375  : 				
; 376  : 
; 377  : 				IMEObjectConvert(&StrIMEWide , StrIMEWideSize)	;

  001c5	8d 54 24 24	 lea	 edx, DWORD PTR _StrIMEWideSize$81371[esp+20]
  001c9	52		 push	 edx
  001ca	8d 44 24 20	 lea	 eax, DWORD PTR _StrIMEWide$81370[esp+24]
  001ce	50		 push	 eax
  001cf	8b ce		 mov	 ecx, esi
  001d1	e8 00 00 00 00	 call	 ?IMEObjectConvert@CI_JAPAN@@QAEXPAGAAH@Z ; CI_JAPAN::IMEObjectConvert

; 378  : 				
; 379  : 				IME_NextComposition(); 

  001d6	8b 16		 mov	 edx, DWORD PTR [esi]
  001d8	8b ce		 mov	 ecx, esi
  001da	ff 52 10	 call	 DWORD PTR [edx+16]
  001dd	5d		 pop	 ebp

; 380  : 				memset(m_composing_string,0,sizeof(m_composing_string));

  001de	33 c0		 xor	 eax, eax
  001e0	8d 7e 0e	 lea	 edi, DWORD PTR [esi+14]
  001e3	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  001e8	5b		 pop	 ebx
  001e9	f3 ab		 rep stosd
  001eb	5f		 pop	 edi

; 381  : 				gbl_skip_escape = false;

  001ec	a2 00 00 00 00	 mov	 BYTE PTR ?gbl_skip_escape@@3_NA, al ; gbl_skip_escape
  001f1	5e		 pop	 esi

; 468  : 		break;
; 469  : 	}
; 470  : }

  001f2	83 c4 08	 add	 esp, 8
  001f5	c2 0c 00	 ret	 12			; 0000000cH
$L81373:

; 382  : 				
; 383  : 			}
; 384  : 		}
; 385  : 		 break;
; 386  : 		 
; 387  : 	case WM_IME_STARTCOMPOSITION:
; 388  : 		gbl_skip_escape = true;

  001f8	bb 01 00 00 00	 mov	 ebx, 1
  001fd	88 1d 00 00 00
	00		 mov	 BYTE PTR ?gbl_skip_escape@@3_NA, bl ; gbl_skip_escape

; 389  : 		m_bCompositionMode	= true;

  00203	88 5e 08	 mov	 BYTE PTR [esi+8], bl

; 390  : 		g_pDXInput->SetAcquire(false);

  00206	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pDXInput@@3PAVCDirectInput@@A ; g_pDXInput
  0020c	6a 00		 push	 0
  0020e	e8 00 00 00 00	 call	 ?SetAcquire@CDirectInput@@QAEJ_N@Z ; CDirectInput::SetAcquire

; 391  : 		ShowWindow( ImehWnd , SW_HIDE );

  00213	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ShowWindow@8
  00219	6a 00		 push	 0
  0021b	55		 push	 ebp
  0021c	ff d6		 call	 esi

; 392  : 		ShowWindow( ImehWnd , SW_SHOWNORMAL );

  0021e	53		 push	 ebx
  0021f	55		 push	 ebp
  00220	ff d6		 call	 esi

; 393  : 		SetFocus(g_hWnd);

  00222	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  00227	50		 push	 eax
  00228	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 394  : 		g_pDXInput->SetAcquire(true);

  0022e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pDXInput@@3PAVCDirectInput@@A ; g_pDXInput
  00234	53		 push	 ebx
  00235	e8 00 00 00 00	 call	 ?SetAcquire@CDirectInput@@QAEJ_N@Z ; CDirectInput::SetAcquire
  0023a	5d		 pop	 ebp
  0023b	5b		 pop	 ebx
  0023c	5f		 pop	 edi
  0023d	5e		 pop	 esi

; 468  : 		break;
; 469  : 	}
; 470  : }

  0023e	83 c4 08	 add	 esp, 8
  00241	c2 0c 00	 ret	 12			; 0000000cH
$L81374:

; 395  : 		break;
; 396  : 	case WM_IME_ENDCOMPOSITION:
; 397  : 		// m_bl_end_of_ime = true;
; 398  : 		 //m_bl_ime_running = false;
; 399  : 		m_bCompositionMode	= false;

  00244	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0

; 400  : 		IME_EndComposition();

  00248	e8 00 00 00 00	 call	 ?IME_EndComposition@@YAXXZ ; IME_EndComposition
  0024d	5d		 pop	 ebp
  0024e	5b		 pop	 ebx
  0024f	5f		 pop	 edi
  00250	5e		 pop	 esi

; 468  : 		break;
; 469  : 	}
; 470  : }

  00251	83 c4 08	 add	 esp, 8
  00254	c2 0c 00	 ret	 12			; 0000000cH
$L81375:

; 401  : 		break;
; 402  : 	case WM_IME_COMPOSITION:	
; 403  : 		//			SetGapEscape();
; 404  : 		gbl_skip_escape = true;
; 405  : 		m_hIMC = ImmGetContext(g_hWnd);

  00257	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  0025d	51		 push	 ecx
  0025e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?gbl_skip_escape@@3_NA, 1 ; gbl_skip_escape
  00265	e8 00 00 00 00	 call	 _ImmGetContext@4
  0026a	8b d8		 mov	 ebx, eax

; 406  : 		if(lParam & GCS_RESULTSTR)

  0026c	8b 44 24 24	 mov	 eax, DWORD PTR _lParam$[esp+20]
  00270	f6 c4 08	 test	 ah, 8
  00273	74 6f		 je	 SHORT $L81376

; 407  : 		{
; 408  : 			if ((len = ImmGetCompositionStringW(m_hIMC, GCS_RESULTSTR, NULL, 0)) > 0)

  00275	6a 00		 push	 0
  00277	6a 00		 push	 0
  00279	68 00 08 00 00	 push	 2048			; 00000800H
  0027e	53		 push	 ebx
  0027f	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  00284	8b f8		 mov	 edi, eax
  00286	85 ff		 test	 edi, edi
  00288	0f 8e 48 01 00
	00		 jle	 $L81737

; 409  : 			{
; 410  : 				wchar_t* temp = (wchar_t*)malloc(len*sizeof(wchar_t));

  0028e	8d 14 3f	 lea	 edx, DWORD PTR [edi+edi]
  00291	52		 push	 edx
  00292	e8 00 00 00 00	 call	 _malloc
  00297	83 c4 04	 add	 esp, 4

; 411  : 				ImmGetCompositionStringW(m_hIMC, GCS_RESULTSTR, temp, len);

  0029a	57		 push	 edi
  0029b	8b e8		 mov	 ebp, eax
  0029d	55		 push	 ebp
  0029e	68 00 08 00 00	 push	 2048			; 00000800H
  002a3	53		 push	 ebx
  002a4	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16

; 412  : 				
; 413  : 				int		 StrIMEWideSize = len  /sizeof(wchar_t) ; 
; 414  : 				IMEObjectConvert(temp , StrIMEWideSize )	;

  002a9	8d 44 24 14	 lea	 eax, DWORD PTR _StrIMEWideSize$81381[esp+24]
  002ad	50		 push	 eax
  002ae	d1 ef		 shr	 edi, 1
  002b0	55		 push	 ebp
  002b1	8b ce		 mov	 ecx, esi
  002b3	89 7c 24 1c	 mov	 DWORD PTR _StrIMEWideSize$81381[esp+32], edi
  002b7	e8 00 00 00 00	 call	 ?IMEObjectConvert@CI_JAPAN@@QAEXPAGAAH@Z ; CI_JAPAN::IMEObjectConvert

; 415  : 				int tempSize = ImmGetCompositionStringW(m_hIMC, GCS_RESULTSTR, NULL, 0);

  002bc	6a 00		 push	 0
  002be	6a 00		 push	 0
  002c0	68 00 08 00 00	 push	 2048			; 00000800H
  002c5	53		 push	 ebx
  002c6	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16

; 416  : 
; 417  : 				IME_NextComposition();

  002cb	8b 16		 mov	 edx, DWORD PTR [esi]
  002cd	8b ce		 mov	 ecx, esi
  002cf	ff 52 10	 call	 DWORD PTR [edx+16]

; 418  : 				memset(m_composing_string,0,sizeof(m_composing_string));

  002d2	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  002d7	33 c0		 xor	 eax, eax
  002d9	8d 7e 0e	 lea	 edi, DWORD PTR [esi+14]
  002dc	f3 ab		 rep stosd

; 419  : 				gbl_skip_escape = false;
; 420  : 				free(temp);

  002de	55		 push	 ebp

; 421  : 			}
; 422  : 		}
; 423  : 
; 424  : 		else	if(lParam & GCS_COMPSTR)

  002df	e9 e3 00 00 00	 jmp	 $L81743
$L81376:
  002e4	a8 08		 test	 al, 8
  002e6	0f 84 ea 00 00
	00		 je	 $L81737

; 425  : 		{
; 426  : 			m_hIMC = ImmGetContext(g_hWnd);

  002ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  002f1	50		 push	 eax
  002f2	e8 00 00 00 00	 call	 _ImmGetContext@4

; 427  : 			 
; 428  : 			static int iBeforeLen = 0 ; 
; 429  : 			len = ImmGetCompositionStringW(m_hIMC, GCS_COMPSTR, NULL, 0) ;

  002f7	6a 00		 push	 0
  002f9	6a 00		 push	 0
  002fb	8b d8		 mov	 ebx, eax
  002fd	6a 08		 push	 8
  002ff	53		 push	 ebx
  00300	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  00305	8b e8		 mov	 ebp, eax

; 430  : 
; 431  : 			if(iBeforeLen > len)

  00307	39 2d 00 00 00
	00		 cmp	 DWORD PTR ?iBeforeLen@?CG@??IME_MessageProcessor@CI_JAPAN@@UAEXIIJ@Z@4HA, ebp
  0030d	7e 22		 jle	 SHORT $L81388

; 432  : 			{
; 433  : 				strcpy(m_composing_string , m_Before_composing_string) ; 

  0030f	8d 86 0e 04 00
	00		 lea	 eax, DWORD PTR [esi+1038]
  00315	8d 56 0e	 lea	 edx, DWORD PTR [esi+14]
  00318	2b d0		 sub	 edx, eax
  0031a	8d 9b 00 00 00
	00		 npad	 6
$L81718:
  00320	8a 08		 mov	 cl, BYTE PTR [eax]
  00322	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00325	40		 inc	 eax
  00326	84 c9		 test	 cl, cl
  00328	75 f6		 jne	 SHORT $L81718

; 434  : 
; 435  : 				IME_NextComposition();

  0032a	8b 16		 mov	 edx, DWORD PTR [esi]
  0032c	8b ce		 mov	 ecx, esi
  0032e	ff 52 10	 call	 DWORD PTR [edx+16]
$L81388:

; 436  : 			}
; 437  : 
; 438  : 
; 439  : 			if (len > 0)

  00331	85 ed		 test	 ebp, ebp
  00333	0f 8e 9d 00 00
	00		 jle	 $L81737

; 440  : 			{
; 441  : 				wchar_t* temp = (wchar_t*)malloc(len*sizeof(wchar_t));

  00339	8d 44 2d 00	 lea	 eax, DWORD PTR [ebp+ebp]
  0033d	50		 push	 eax
  0033e	e8 00 00 00 00	 call	 _malloc
  00343	83 c4 04	 add	 esp, 4

; 442  : 				ImmGetCompositionStringW(m_hIMC, GCS_COMPSTR, temp, len);

  00346	55		 push	 ebp
  00347	8b f8		 mov	 edi, eax
  00349	57		 push	 edi
  0034a	6a 08		 push	 8
  0034c	53		 push	 ebx
  0034d	89 7c 24 20	 mov	 DWORD PTR _temp$81390[esp+40], edi
  00351	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16

; 443  : 				
; 444  : 				int		 StrIMEWideSize = len  /sizeof(wchar_t) ; 

  00356	8b cd		 mov	 ecx, ebp
  00358	d1 e9		 shr	 ecx, 1

; 445  : 				IMEObjectConvert(temp , StrIMEWideSize )	;

  0035a	8d 54 24 14	 lea	 edx, DWORD PTR _StrIMEWideSize$81393[esp+24]
  0035e	52		 push	 edx
  0035f	89 4c 24 18	 mov	 DWORD PTR _StrIMEWideSize$81393[esp+28], ecx
  00363	57		 push	 edi
  00364	8b ce		 mov	 ecx, esi
  00366	e8 00 00 00 00	 call	 ?IMEObjectConvert@CI_JAPAN@@QAEXPAGAAH@Z ; CI_JAPAN::IMEObjectConvert

; 446  : 				int tempSize = ImmGetCompositionStringW(m_hIMC, GCS_COMPSTR, NULL, 0);

  0036b	6a 00		 push	 0
  0036d	6a 00		 push	 0
  0036f	6a 08		 push	 8
  00371	53		 push	 ebx
  00372	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16

; 447  : 				if(len > 80) 

  00377	83 fd 50	 cmp	 ebp, 80			; 00000050H
  0037a	7e 0e		 jle	 SHORT $L81396

; 448  : 				{	
; 449  : 					IME_NextComposition();

  0037c	8b 06		 mov	 eax, DWORD PTR [esi]
  0037e	8b ce		 mov	 ecx, esi
  00380	ff 50 10	 call	 DWORD PTR [eax+16]

; 450  : 					
; 451  : 					
; 452  : 					FinishImeRunning() ; 

  00383	8b ce		 mov	 ecx, esi
  00385	e8 00 00 00 00	 call	 ?FinishImeRunning@CI@@QAEXXZ ; CI::FinishImeRunning
$L81396:

; 453  : 					iBeforeLen = 0;
; 454  : 				}
; 455  : 				strcpy(m_Before_composing_string , m_composing_string) ; 

  0038a	8d 7e 0e	 lea	 edi, DWORD PTR [esi+14]
  0038d	81 c6 0e 04 00
	00		 add	 esi, 1038		; 0000040eH
  00393	8b d6		 mov	 edx, esi
  00395	8b c7		 mov	 eax, edi
  00397	2b d7		 sub	 edx, edi
  00399	8d a4 24 00 00
	00 00		 npad	 7
$L81719:
  003a0	8a 08		 mov	 cl, BYTE PTR [eax]
  003a2	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  003a5	40		 inc	 eax
  003a6	84 c9		 test	 cl, cl
  003a8	75 f6		 jne	 SHORT $L81719

; 456  : 				memset(m_composing_string,0,sizeof(m_composing_string));

  003aa	33 c0		 xor	 eax, eax
  003ac	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  003b1	f3 ab		 rep stosd

; 457  : 				memset(m_Before_composing_string,0,sizeof(m_Before_composing_string));

  003b3	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  003b8	8b fe		 mov	 edi, esi
  003ba	f3 ab		 rep stosd

; 458  : 				iBeforeLen = len ;  
; 459  : 				gbl_skip_escape = false;
; 460  : 				free(temp);

  003bc	8b 4c 24 10	 mov	 ecx, DWORD PTR _temp$81390[esp+24]
  003c0	89 2d 00 00 00
	00		 mov	 DWORD PTR ?iBeforeLen@?CG@??IME_MessageProcessor@CI_JAPAN@@UAEXIIJ@Z@4HA, ebp
  003c6	51		 push	 ecx
$L81743:
  003c7	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gbl_skip_escape@@3_NA, 0 ; gbl_skip_escape
  003ce	e8 00 00 00 00	 call	 _free
  003d3	83 c4 04	 add	 esp, 4
$L81737:

; 461  : 			}
; 462  : 
; 463  : 
; 464  : 		}
; 465  : 		ImmReleaseContext(g_hWnd, m_hIMC);

  003d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  003dc	53		 push	 ebx
  003dd	52		 push	 edx
  003de	e8 00 00 00 00	 call	 _ImmReleaseContext@8
  003e3	8b 44 24 20	 mov	 eax, DWORD PTR _wParam$[esp+20]
$L81397:

; 466  : 	default:
; 467  : 		IME_Normal(message, wParam, lParam);

  003e7	8b 4c 24 24	 mov	 ecx, DWORD PTR _lParam$[esp+20]
  003eb	8b 54 24 1c	 mov	 edx, DWORD PTR _message$[esp+20]
  003ef	51		 push	 ecx
  003f0	50		 push	 eax
  003f1	52		 push	 edx
  003f2	e8 00 00 00 00	 call	 ?IME_Normal@@YAXIIJ@Z	; IME_Normal
  003f7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L81741:
  003fa	5d		 pop	 ebp
  003fb	5b		 pop	 ebx
$L81740:
  003fc	5f		 pop	 edi
$L81363:
  003fd	5e		 pop	 esi

; 468  : 		break;
; 469  : 	}
; 470  : }

  003fe	83 c4 08	 add	 esp, 8
  00401	c2 0c 00	 ret	 12			; 0000000cH
$L81744:
  00404	00 00 00 00	 DD	 $L81366
  00408	00 00 00 00	 DD	 $L81373
  0040c	00 00 00 00	 DD	 $L81374
  00410	00 00 00 00	 DD	 $L81375
  00414	00 00 00 00	 DD	 $L81397
$L81732:
  00418	00		 DB	 0
  00419	04		 DB	 4
  0041a	04		 DB	 4
  0041b	04		 DB	 4
  0041c	04		 DB	 4
  0041d	04		 DB	 4
  0041e	04		 DB	 4
  0041f	04		 DB	 4
  00420	04		 DB	 4
  00421	04		 DB	 4
  00422	04		 DB	 4
  00423	01		 DB	 1
  00424	02		 DB	 2
  00425	03		 DB	 3
?IME_MessageProcessor@CI_JAPAN@@UAEXIIJ@Z ENDP		; CI_JAPAN::IME_MessageProcessor
_TEXT	ENDS
PUBLIC	??0CI@@QAE@XZ					; CI::CI
; Function compile flags: /Ogty
;	COMDAT ??0CI@@QAE@XZ
_TEXT	SEGMENT
??0CI@@QAE@XZ PROC NEAR					; CI::CI, COMDAT
; _this$ = ecx

; 50   : 	m_bCompsition		= false ;

  00000	33 c0		 xor	 eax, eax
  00002	56		 push	 esi
  00003	8b f1		 mov	 esi, ecx

; 51   : 	Init();

  00005	50		 push	 eax
  00006	6a 04		 push	 4
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CI@@6B@
  0000e	88 46 07	 mov	 BYTE PTR [esi+7], al
  00011	66 89 46 0a	 mov	 WORD PTR [esi+10], ax
  00015	66 89 46 0c	 mov	 WORD PTR [esi+12], ax
  00019	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  0001d	88 46 05	 mov	 BYTE PTR [esi+5], al
  00020	88 46 06	 mov	 BYTE PTR [esi+6], al
  00023	88 46 08	 mov	 BYTE PTR [esi+8], al
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  0002b	6a 15		 push	 21			; 00000015H
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _ImmGetContext@4
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 52   : }

  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi
  0003c	c3		 ret	 0
??0CI@@QAE@XZ ENDP					; CI::CI
_TEXT	ENDS
PUBLIC	?SetEngInput@CI@@QAEX_N@Z			; CI::SetEngInput
EXTRN	_ImmSetConversionStatus@12:NEAR
; Function compile flags: /Ogty
;	COMDAT ?SetEngInput@CI@@QAEX_N@Z
_TEXT	SEGMENT
_bHangul$ = 8						; size = 1
?SetEngInput@CI@@QAEX_N@Z PROC NEAR			; CI::SetEngInput, COMDAT
; _this$ = ecx

; 76   : 	FinishImeRunning();

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  00005	56		 push	 esi
  00006	6a 00		 push	 0
  00008	6a 04		 push	 4
  0000a	6a 15		 push	 21			; 00000015H
  0000c	50		 push	 eax
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 _ImmGetContext@4
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 77   : 	ImmSetConversionStatus(ImmGetContext(g_hWnd), bHangul, NULL);

  0001a	0f b6 4c 24 08	 movzx	 ecx, BYTE PTR _bHangul$[esp]
  0001f	6a 00		 push	 0
  00021	c6 46 06 00	 mov	 BYTE PTR [esi+6], 0
  00025	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A ; g_hWnd
  0002b	51		 push	 ecx
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 _ImmGetContext@4
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _ImmSetConversionStatus@12
  00038	5e		 pop	 esi

; 78   : }

  00039	c2 04 00	 ret	 4
?SetEngInput@CI@@QAEX_N@Z ENDP				; CI::SetEngInput
_TEXT	ENDS
END
